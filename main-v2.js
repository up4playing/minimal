var version = 2, appName = "Minimal";
var _basePath = "";
function log(value) {console.log(value);}
var int_maxValue = 2147483647;
var int_minValue = -2147483648;
function int_modulo_int(a, b) {
	return ((a % b) + b) % b
}
function int_enumerate(from, to, selector) {
	let result = []
	for(let i=from; i < to; ++i)
		result.push(selector(i))
	return result
}
function float_modulo_float(a, b) {
	return ((a % b) + b) % b
}
String.prototype.getUntil = function(value, start) {
	let index = this.indexOf(value)
	if(index != -1) return this.substring(start, index)
	else return this
}
String.prototype.getExtension = function() {
	let dot = this.lastIndexOf(".")
	if(dot != -1) return this.substring(dot+1)
	else return ""
}
String.prototype.get = function(index) {
	return index >= 0 ? this[index] : this[this.length+index]
}
String.prototype.get2 = function(from, to) {
	return this.substring(from >= 0 ? from : this.length+from, to >= 0 ? to : this.length+to)
}
String.prototype.get3 = function(from) {
	return this.substring(from >= 0 ? from : this.length+from) 
}
var List_temporaryCopy;
function List_init() {
	List_temporaryCopy = null;
}
Array.prototype.eachDistinct = function(selector, $do) {
	if(this.length > 0) {
		let _subject = this.sort((a,b) => selector(a) - selector(b))
		for(let _nextIndex=1, it = selector(_subject[0]), i=0; _nextIndex<_subject.length; ++_nextIndex) { 
			let _nextIt = selector(_subject[_nextIndex]);
			if(_nextIt != it) {
				let items = _subject.slice(i, _nextIndex);
				$do(it, items, i)
				it = _nextIt;
				i = _nextIndex;
			}
		}
	}
}
Array.prototype.remove = function(item) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove2 = function(item, item2) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove3 = function(item, item2, item3) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove4 = function(item, item2, item3, item4) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item4);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove5 = function(item, item2, item3, item4, item5) {
	var index = this.indexOf(item);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item2);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item3);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item4);
	if(index > -1) this.splice(index, 1);
	var index = this.indexOf(item5);
	if(index > -1) this.splice(index, 1);
}
Array.prototype.remove6 = function(items) {
	for(let item of items) {
		var index = this.indexOf(item);
		if(index > -1) this.splice(index, 1);
	}
}
Array.prototype.removeWhere = function(condition) {
	for(let _subject=this, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(condition(it)) {
			this.splice(i, 1);
		}
	}}
	return null;
}
Array.prototype.removeFirstWhere = function(condition) {
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.splice(i, 1);
			return it;
		}
	}}
	return null;
}
Array.prototype.ensure = function(item) {
	if(!this.includes(item))
		this.push(item)
}
Array.prototype.ensure2 = function(items) {
	for(let it of items)
		if(!this.includes(it))
			this.push(it)
}
Array.prototype.setFilteredList = function(list, condition) {
	this.length = 0;
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.push(it);
		}
	}}
}
Array.prototype.setFilteredList2 = function(list, condition, maxCount) {
	this.length = 0;
	let count = 0;
	for(let i=0, _subject=list, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			this.push(it);
			if(++count >= maxCount) {
				break;
			}
		}
	}}
}
Array.prototype.popWhere = function(condition) {
	for(let i=0; i<this.length; ++i) {
		let item = this.get(i);
		if(condition(item)) {
			this.splice(i, 1);
			return item;
		}
	}
	return null;
}
Array.prototype.popFirst = function() {
	if(this.length == 0) return null
	let firstItem = this[0]
	this.splice(0, 1)
	return firstItem
}
Array.prototype.setLength = function(length) {
	this.length = length
}
Array.prototype.toString = function() {
	let result = "";
	for(let item of this) {
		if(result) result += ", ";
		result += item;
	}
	return "["+result+"]"
}
Array.prototype.random = function() {
	let randomInteger = math_randomInteger2(this.length);
	return this.get(randomInteger);
}
Array.prototype.popRandom = function() {
	let index = math_randomInteger2(this.length);
	let item = this.get(index);
	this.splice(index, 1);
	return item;
}
Array.prototype.next = function(currentItem) {
	let index = this.indexOf(currentItem);
	return this.get(int_modulo_int((index + 1), this.length));
}
Array.prototype.next2 = function(currentItem, where) {
	let baseIndex = this.indexOf(currentItem);
	for(let i=0; i<this.length; ++i) {
		let item = this.get(int_modulo_int((baseIndex + i + 1), this.length));
		if(where(item)) {
			return item;
		}
	}
	return null;
}
Array.prototype.prev = function(currentItem) {
	let index = this.indexOf(currentItem);
	return (index != -1 ? this.get(int_modulo_int((index - 1), this.length)) : this.get(this.length - 1));
}
Array.prototype.pickWithinRangeOrClosest = function(selector, min, max) {
	let closestDistance = Number.POSITIVE_INFINITY;
	let closestIndex = -1;
	let closestItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		let distance = 0.0;
		if(value > max) {
			distance = value - max;
		} else {
			if(value < min) {
				distance = min - value;
			} else {
				this.splice(i, 1);
				return it;
			}
		}
		if(distance < closestDistance) {
			closestDistance = distance;
			closestIndex = i;
			closestItem = it;
		}
	}}
	if(closestIndex != -1) {
		this.splice(closestIndex, 1);
	}
	return closestItem;
}
Array.prototype.moveToBack = function(item) {
	var index = this.indexOf(item);
	if(index != -1) {
		let endIndex = this.length-1;
		for(let i=index; i<endIndex; ++i) {
			this[i] = this[i+1]
		}
		this[endIndex] = item
	}
}
Array.prototype.moveToFront = function(item) {
	var index = this.indexOf(item);
	if(index != -1) {
		for(let i=index; i>0; --i) {
			this[i] = this[i-1]
		}
		this[0] = item
	}
}
Array.prototype.orderBy = function(expression) {
	return this.sort((a,b) => expression(a) - expression(b));
}
Array.prototype.orderBy2 = function(expression, thenBy) {
	return this.sort((a,b) => expression(a) - expression(b) || thenBy(a) - thenBy(b));
}
Array.prototype.orderBy3 = function(expression) {
	return this.sort((a,b) => expression(a)-expression(b));
}
Array.prototype.orderBy4 = function(expression) {
	return this.sort((a,b) => expression(a)-expression(b));
}
Array.prototype.orderBy5 = function(expression) {
	return this.sort((a,b) => expression(a).localeCompare(expression(b)));
}
Array.prototype.orderBy6 = function(expression, order) {
	if(order == 0/*Ascending*/) {
		return this.sort((a,b) => expression(a) - expression(b));
	} else {
		return this.sort((a,b) => expression(b) - expression(a));
	}
}
Array.prototype.findLast = function(condition) {
	for(let _subject=this, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(condition(it)) {
			return it;
		}
	}}
	return null;
}
Array.prototype.indexWhere = function(condition) {
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(condition(it)) {
			return i;
		}
	}}
	return -1;
}
Array.prototype.indexWhere2 = function(condition) {
	for(let _subject=this, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(condition(it)) {
			return i;
		}
	}}
	return -1;
}
Array.prototype.total = function(selector) {
	let sum = new Vector2(0, 0, null);
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		Vector2_plusAssign_Vector2(sum, selector(it));
	}}
	return sum;
}
Array.prototype.total2 = function(selector) {
	let sum = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum += selector(it);
	}}
	return sum;
}
Array.prototype.total3 = function(selector, where) {
	let sum = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			sum += selector(it);
		}
	}}
	return sum;
}
Array.prototype.total4 = function(selector) {
	let sum = 0.0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		sum += selector(it);
	}}
	return sum;
}
Array.prototype.sum = function() {
	let sum = 0;
	for(let i=0; i<this.length; i++)
		sum += this[i];
	return sum;
}
Array.prototype.average = function() {
	return this.length > 0 ? this.sum() / this.length : 0
}
Array.prototype.joinToString = function(selector, separator) {
	let result = "";
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(result) {
			result += separator;
		}
		result += selector(it);
	}}
	return result;
}
Array.prototype.shuffle = function() {
	for(let i=this.length-1; i>=1; --i) {
		let j = Math.floor(math_randomFloat2(1.0) * (i + 1));
		let temp = this.get(i);
		this.set(i, this.get(j));
		this.set(j, temp);
	}
	return this;
}
Array.prototype.percentile = function(value) {
	if(this.length == 0) return 0
	if(this.length == 1) return this[0]
	if(!List_temporaryCopy) List_temporaryCopy = []
	const len = List_temporaryCopy.length = this.length
	for(let i=0; i<len; ++i) List_temporaryCopy[i] = this[i] 
	List_temporaryCopy.sort((a,b) => a - b)
	return List_temporaryCopy[Math.round((List_temporaryCopy.length-1) * value / 100)]
}
Array.prototype.min = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min2 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min3 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value<resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min4 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.min5 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max2 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max3 = function(selector, threshold, $default) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value>resultValue) {
			resultValue = value;
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max4 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max5 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.max6 = function(selector, threshold, $default, where) {
	let resultValue = threshold;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value>resultValue) {
				resultValue = value;
			}
		}
	}}
	return (resultValue != threshold ? resultValue : $default);
}
Array.prototype.minIndex = function(selector, threshold) {
	let resultValue = threshold;
	let index = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
			index = i;
		}
	}}
	return index;
}
Array.prototype.maxIndex = function(selector, threshold) {
	let resultValue = threshold;
	let index = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			index = i;
		}
	}}
	return index;
}
Array.prototype.withMin = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value < resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin3 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value<resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin4 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin5 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value < resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMin6 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value<resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax3 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value>resultValue) {
			resultValue = value;
			resultItem = it;
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax4 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.withMax5 = function(selector, threshold, where) {
	let resultValue = threshold;
	let resultItem = null;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(where(it)) {
			let value = selector(it);
			if(value > resultValue) {
				resultValue = value;
				resultItem = it;
			}
		}
	}}
	return (resultValue != threshold ? resultItem : null);
}
Array.prototype.popMax = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	let resultIndex = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
			resultIndex = i;
		}
	}}
	if(resultIndex != -1) {
		this.splice(resultIndex, 1);
	}
	return resultItem;
}
Array.prototype.popMax2 = function(selector, threshold) {
	let resultValue = threshold;
	let resultItem = null;
	let resultIndex = -1;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let value = selector(it);
		if(value > resultValue) {
			resultValue = value;
			resultItem = it;
			resultIndex = i;
		}
	}}
	if(resultIndex != -1) {
		this.splice(resultIndex, 1);
	}
	return resultItem;
}
Array.prototype.count = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(predicate(it)) {
			count++;
		}
	}}
	return count;
}
Array.prototype.countNot = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(!predicate(it)) {
			count++;
		}
	}}
	return count;
}
Array.prototype.rotate = function() {
	this.splice(0, 0, this.pop());
}
Array.prototype.intersectWith = function(other) {
	const a = this || []
	const b = other || []
	const result = [];
	const map = {};
	for (let i = 0, length = b.length; i < length; ++i) {
		map[b[i]] = true;
	}
	for (let i = 0, length = a.length; i < length; ++i) {
		if (a[i] in map) result.push(a[i]);
	}
	return result;
}
Array.prototype.get = function(index) {
	return index >= 0 ? this[index] : this[this.length+index]
}
Array.prototype.get2 = function(from, to) {
	return this.slice(from, to)
}
Array.prototype.get3 = function(from) {
	return this.slice(from)
}
Array.prototype.set = function(index, value) {
	return index >= 0 ? this[index] = value : this[this.length+index] = value
}
Array.prototype.addToItem = function(index, value) {
	return index >= 0 ? this[index] += value : this[this.length+index] += value
}
Array.prototype.subtractFromItem = function(index, value) {
	return index >= 0 ? this[index] -= value : this[this.length+index] -= value
}
Array.prototype.multiplyItem = function(index, value) {
	return index >= 0 ? this[index] *= value : this[this.length+index] *= value
}
Array.prototype.divideItem = function(index, value) {
	return index >= 0 ? this[index] /= value : this[this.length+index] /= value
}
Array.prototype.incrementItem = function(index) {
	return index >= 0 ? this[index]++ : this[this.length+index]++
}
Array.prototype.decrementItem = function(index) {
	return index >= 0 ? this[index]-- : this[this.length+index]--
}
Map.prototype.setAndReturn = function(key, value) {
	this.set(key, value);
	return value;
}
function SourceCodeLocation(file, start, end, left, right) {
	this.file = file;
	this.start = start;
	this.end = end;
	this.left = left;
	this.right = right;
}
SourceCodeLocation.prototype.find = function(file, pos) {
	if(this.file && this.file == file && pos >= this.start && pos <= this.end) {
		return this;
	}
	if(this.left != null) {
		let result = this.left.find(file, pos);
		if(result != null) {
			return result;
		}
	}
	if(this.right != null) {
		let result = this.right.find(file, pos);
		if(result != null) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.find2 = function(location) {
	if(this.file == location.file && this.start == location.start && this.end == location.end) {
		return this;
	}
	if(this.left != null) {
		let result = this.left.find2(location);
		if(result != null) {
			return result;
		}
	}
	if(this.right != null) {
		let result = this.right.find2(location);
		if(result != null) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.leaf = function() {
	if(this.file) {
		return this;
	}
	if((this.right != null)) {
		let result = this.right.leaf();
		if((result != null)) {
			return result;
		}
	}
	if((this.left != null)) {
		let result = this.left.leaf();
		if((result != null)) {
			return result;
		}
	}
	return null;
}
SourceCodeLocation.prototype.clone = function() {
	let clone = new _SourceCodeLocation();
	clone.file = this.file;
	clone.start = this.start;
	clone.end = this.end;
	clone.left = this.left;
	clone.right = this.right;
	return clone;
}
function _SourceCodeLocation() {};
_SourceCodeLocation.prototype = SourceCodeLocation.prototype;
function object_stringify(subject, depth) {
	switch(typeof subject)
	{
		case "object":
			if(subject === null) return "null"
			let result = ""
			if(subject.constructor) result += "_type: " + subject.constructor.name
			if(depth > 0) {
				for(let name in subject) {
					let item = object_stringify(subject[name], depth-1)
					if(item != "") {
						if(result) result += ", "
						result += name + ": " + item
					}
				}
			}
			return "\{" + result + "\}"
			
		case "string":
			return "\"" + subject + "\""
			
		case "undefined":
			return "\"undefined\""
			
		case "function":
			return ""
			
		default:
			return subject.toString()
	}
}
function Player(id, index, color, pointerPosition, score) {
	this.id = id;
	this.index = index;
	this.color = color;
	this.pointerPosition = pointerPosition?.clone();
	this.touches = [];
	this.enableTouch = true;
	this.textInput = "";
	this.keysCurrentlyDown = [];
	this.controller = new GameController(false, 0/*Keyboard*/);
	this.controllerKeyDownFrame = [0, 0, 0, 0, 0, 0];
	this.lostAtFrame = 0;
	this.isReadyInLobby = false;
	this.score = score;
	this.dir = Direction_diagonalDirections.get(this.index);
	this.pos = IntVector2_multiply_IntVector2(this.dir.vector, new IntVector2(690, 265, null))?.toVector2()?.clone();
}
Player.prototype.tick = function() {
	graphics_drawImage(Image_Coin, new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
}
Player.prototype.toString = function() {
	object_stringify(this, 3);
	return ((this.color != null) ? this.color.name : "");
}
Player.prototype.clearEvents = function() {
	let hasTouch = this.touches.some(a => a.type == 3/*Touch*/);
	for(let _subject=this.touches, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if((it.phase == 3/*Up*/ && it.type >= 3/*Touch*/) || (hasTouch && it.type != 3/*Touch*/)) {
			this.touches.remove(it);
		}
	}}
}
Player.prototype.clone = function() {
	let clone = new _Player();
	clone.id = this.id;
	clone.index = this.index;
	clone.color = this.color;
	clone.pointerPosition = this.pointerPosition.clone();
	clone.touches = this.touches;
	clone.enableTouch = this.enableTouch;
	clone.textInput = this.textInput;
	clone.keysCurrentlyDown = this.keysCurrentlyDown;
	clone.controller = this.controller;
	clone.controllerKeyDownFrame = this.controllerKeyDownFrame;
	clone.lostAtFrame = this.lostAtFrame;
	clone.isReadyInLobby = this.isReadyInLobby;
	clone.score = this.score;
	clone.dir = this.dir;
	clone.pos = this.pos.clone();
	return clone;
}
function _Player() {};
_Player.prototype = Player.prototype;
Player.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.id);
	buffer.writeInt32(this.index);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.pointerPosition || new _Vector2()).serialize_internal(buffer);
	let touches = this.touches
	if(touches) {
		var index = _objectCacheIndex.get(touches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(touches, index = _objectCache.length);
			_objectCache.push(touches);
			buffer.writeInt32(-index);
			touches._objectIndex = index;
			buffer.writeInt32(touches.length);
			for(let i=0, len=touches.length; i<len; ++i) {
				let touches_item = touches[i]
				if(touches_item) {
					var index = _objectCacheIndex.get(touches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(touches_item, index = _objectCache.length);
						_objectCache.push(touches_item);
						buffer.writeInt32(-index);
						touches_item._objectIndex = index;
						touches_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.enableTouch);
	buffer.writeString(this.textInput);
	let keysCurrentlyDown = this.keysCurrentlyDown
	if(keysCurrentlyDown) {
		var index = _objectCacheIndex.get(keysCurrentlyDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keysCurrentlyDown, index = _objectCache.length);
			_objectCache.push(keysCurrentlyDown);
			buffer.writeInt32(-index);
			keysCurrentlyDown._objectIndex = index;
			buffer.writeInt32(keysCurrentlyDown.length);
			for(let i=0, len=keysCurrentlyDown.length; i<len; ++i) {
				buffer.writeInt32(keysCurrentlyDown[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let controller = this.controller
	if(controller) {
		var index = _objectCacheIndex.get(controller);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controller, index = _objectCache.length);
			_objectCache.push(controller);
			buffer.writeInt32(-index);
			controller._objectIndex = index;
			controller.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let controllerKeyDownFrame = this.controllerKeyDownFrame
	if(controllerKeyDownFrame) {
		var index = _objectCacheIndex.get(controllerKeyDownFrame);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controllerKeyDownFrame, index = _objectCache.length);
			_objectCache.push(controllerKeyDownFrame);
			buffer.writeInt32(-index);
			controllerKeyDownFrame._objectIndex = index;
			buffer.writeInt32(controllerKeyDownFrame.length);
			for(let i=0, len=controllerKeyDownFrame.length; i<len; ++i) {
				buffer.writeInt32(controllerKeyDownFrame[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.lostAtFrame);
	buffer.writeBool(this.isReadyInLobby);
	buffer.writeInt32(this.score);
	let dir = this.dir
	if(dir) {
		var index = _objectCacheIndex.get(dir);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(dir, index = _objectCache.length);
			_objectCache.push(dir);
			buffer.writeInt32(-index);
			dir._objectIndex = index;
			dir.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.pos || new _Vector2()).serialize_internal(buffer);
}
Player.prototype.deserialize_internal = function(buffer) {
	this.id = buffer.readInt32();
	this.index = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	(this.pointerPosition || (this.pointerPosition = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.touches = _objectCache[index];
	} else {
		let touches = this.touches
		if(!touches || touches._objectIndex != -index) this.touches = touches = [];
		_objectCache[-index] = touches;
		for(let i=0, len = touches.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					touches[i] = _objectCache[index];
				} else {
					let touches_item = touches[i]
					if(!touches_item || touches_item._objectIndex != -index)
						touches[i] = touches_item = new _Touch();
					(_objectCache[-index] = touches_item).deserialize_internal(buffer);
				}
		}
	}
	this.enableTouch = buffer.readBool();
	this.textInput = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.keysCurrentlyDown = _objectCache[index];
	} else {
		let keysCurrentlyDown = this.keysCurrentlyDown
		if(!keysCurrentlyDown || keysCurrentlyDown._objectIndex != -index) this.keysCurrentlyDown = keysCurrentlyDown = [];
		_objectCache[-index] = keysCurrentlyDown;
		for(let i=0, len = keysCurrentlyDown.length = buffer.readInt32(); i<len; ++i) {
				keysCurrentlyDown[i] = buffer.readInt32();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.controller = _objectCache[index];
	} else {
		let controller = this.controller
		if(!controller || controller._objectIndex != -index)
			this.controller = controller = new _GameController();
		(_objectCache[-index] = controller).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.controllerKeyDownFrame = _objectCache[index];
	} else {
		let controllerKeyDownFrame = this.controllerKeyDownFrame
		if(!controllerKeyDownFrame || controllerKeyDownFrame._objectIndex != -index) this.controllerKeyDownFrame = controllerKeyDownFrame = [];
		_objectCache[-index] = controllerKeyDownFrame;
		for(let i=0, len = controllerKeyDownFrame.length = buffer.readInt32(); i<len; ++i) {
				controllerKeyDownFrame[i] = buffer.readInt32();
		}
	}
	this.lostAtFrame = buffer.readInt32();
	this.isReadyInLobby = buffer.readBool();
	this.score = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.dir = _objectCache[index];
	} else {
		let dir = this.dir
		if(!dir || dir._objectIndex != -index)
			this.dir = dir = new _Direction();
		(_objectCache[-index] = dir).deserialize_internal(buffer);
	}
	(this.pos || (this.pos = new _Vector2())).deserialize_internal(buffer);
}
Player.prototype.serialize_external = function(buffer) {
	buffer.writeString("id");
	buffer.writeInt32(4);
	buffer.writeInt32(this.id);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("pointerPosition");
	let pointerPosition_startPos = buffer.reserveSize();
	(this.pointerPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(pointerPosition_startPos);
	buffer.writeString("touches");
	let touches = this.touches
	let touches_startPos = buffer.reserveSize();
	if(touches) {
		var index = _objectCacheIndex.get(touches);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(touches, index = _objectCache.length);
			_objectCache.push(touches);
			buffer.writeInt32(-index);
			touches._objectIndex = index;
			buffer.writeInt32(touches.length);
			for(let i=0, len=touches.length; i<len; ++i) {
				let touches_item = touches[i]
				if(touches_item) {
					var index = _objectCacheIndex.get(touches_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(touches_item, index = _objectCache.length);
						_objectCache.push(touches_item);
						buffer.writeInt32(-index);
						touches_item._objectIndex = index;
						touches_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(touches_startPos);
	buffer.writeString("enableTouch");
	buffer.writeInt32(1);
	buffer.writeBool(this.enableTouch);
	buffer.writeString("textInput");
	buffer.writeString(this.textInput);
	buffer.writeString("keysCurrentlyDown");
	let keysCurrentlyDown = this.keysCurrentlyDown
	let keysCurrentlyDown_startPos = buffer.reserveSize();
	if(keysCurrentlyDown) {
		var index = _objectCacheIndex.get(keysCurrentlyDown);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(keysCurrentlyDown, index = _objectCache.length);
			_objectCache.push(keysCurrentlyDown);
			buffer.writeInt32(-index);
			keysCurrentlyDown._objectIndex = index;
			buffer.writeInt32(keysCurrentlyDown.length);
			for(let i=0, len=keysCurrentlyDown.length; i<len; ++i) {
				buffer.writeInt32(keysCurrentlyDown[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(keysCurrentlyDown_startPos);
	buffer.writeString("controller");
	let controller_startPos = buffer.reserveSize();
	let controller = this.controller
	if(controller) {
		var index = _objectCacheIndex.get(controller);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controller, index = _objectCache.length);
			_objectCache.push(controller);
			buffer.writeInt32(-index);
			controller._objectIndex = index;
			controller.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(controller_startPos);
	buffer.writeString("controllerKeyDownFrame");
	let controllerKeyDownFrame = this.controllerKeyDownFrame
	let controllerKeyDownFrame_startPos = buffer.reserveSize();
	if(controllerKeyDownFrame) {
		var index = _objectCacheIndex.get(controllerKeyDownFrame);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(controllerKeyDownFrame, index = _objectCache.length);
			_objectCache.push(controllerKeyDownFrame);
			buffer.writeInt32(-index);
			controllerKeyDownFrame._objectIndex = index;
			buffer.writeInt32(controllerKeyDownFrame.length);
			for(let i=0, len=controllerKeyDownFrame.length; i<len; ++i) {
				buffer.writeInt32(controllerKeyDownFrame[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(controllerKeyDownFrame_startPos);
	buffer.writeString("lostAtFrame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.lostAtFrame);
	buffer.writeString("isReadyInLobby");
	buffer.writeInt32(1);
	buffer.writeBool(this.isReadyInLobby);
	buffer.writeString("score");
	buffer.writeInt32(4);
	buffer.writeInt32(this.score);
	buffer.writeString("dir");
	let dir_startPos = buffer.reserveSize();
	let dir = this.dir
	if(dir) {
		var index = _objectCacheIndex.get(dir);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(dir, index = _objectCache.length);
			_objectCache.push(dir);
			buffer.writeInt32(-index);
			dir._objectIndex = index;
			dir.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(dir_startPos);
	buffer.writeString("pos");
	let pos_startPos = buffer.reserveSize();
	(this.pos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(pos_startPos);
	buffer.writeString("");
}
Player.prototype.deserialize_external = function(buffer) {
	let id_is_set = false, index_is_set = false, color_is_set = false, pointerPosition_is_set = false, touches_is_set = false, enableTouch_is_set = false, textInput_is_set = false, keysCurrentlyDown_is_set = false, controller_is_set = false, controllerKeyDownFrame_is_set = false, lostAtFrame_is_set = false, isReadyInLobby_is_set = false, score_is_set = false, dir_is_set = false, pos_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "id":
				buffer.readInt32();
				this.id = buffer.readInt32();
				id_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "pointerPosition":
				buffer.readInt32();
				(this.pointerPosition || (this.pointerPosition = new _Vector2())).deserialize_external(buffer);
				pointerPosition_is_set = true;
				break;
			case "touches":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.touches = _objectCache[index];
				} else {
					let touches = this.touches
					if(!touches || touches._objectIndex != -index) this.touches = touches = [];
					_objectCache[-index] = touches;
					for(let i=0, len = touches.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								touches[i] = _objectCache[index];
							} else {
								let touches_item = touches[i]
								if(!touches_item || touches_item._objectIndex != -index)
									touches[i] = touches_item = new _Touch();
								(_objectCache[-index] = touches_item).deserialize_external(buffer);
							}
					}
				}
				touches_is_set = true;
				break;
			case "enableTouch":
				buffer.readInt32();
				this.enableTouch = buffer.readBool();
				enableTouch_is_set = true;
				break;
			case "textInput":
				this.textInput = buffer.readString();
				textInput_is_set = true;
				break;
			case "keysCurrentlyDown":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.keysCurrentlyDown = _objectCache[index];
				} else {
					let keysCurrentlyDown = this.keysCurrentlyDown
					if(!keysCurrentlyDown || keysCurrentlyDown._objectIndex != -index) this.keysCurrentlyDown = keysCurrentlyDown = [];
					_objectCache[-index] = keysCurrentlyDown;
					for(let i=0, len = keysCurrentlyDown.length = buffer.readInt32(); i<len; ++i) {
							keysCurrentlyDown[i] = buffer.readInt32();
					}
				}
				keysCurrentlyDown_is_set = true;
				break;
			case "controller":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.controller = _objectCache[index];
				} else {
					let controller = this.controller
					if(!controller || controller._objectIndex != -index)
						this.controller = controller = new _GameController();
					(_objectCache[-index] = controller).deserialize_external(buffer);
				}
				controller_is_set = true;
				break;
			case "controllerKeyDownFrame":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.controllerKeyDownFrame = _objectCache[index];
				} else {
					let controllerKeyDownFrame = this.controllerKeyDownFrame
					if(!controllerKeyDownFrame || controllerKeyDownFrame._objectIndex != -index) this.controllerKeyDownFrame = controllerKeyDownFrame = [];
					_objectCache[-index] = controllerKeyDownFrame;
					for(let i=0, len = controllerKeyDownFrame.length = buffer.readInt32(); i<len; ++i) {
							controllerKeyDownFrame[i] = buffer.readInt32();
					}
				}
				controllerKeyDownFrame_is_set = true;
				break;
			case "lostAtFrame":
				buffer.readInt32();
				this.lostAtFrame = buffer.readInt32();
				lostAtFrame_is_set = true;
				break;
			case "isReadyInLobby":
				buffer.readInt32();
				this.isReadyInLobby = buffer.readBool();
				isReadyInLobby_is_set = true;
				break;
			case "score":
				buffer.readInt32();
				this.score = buffer.readInt32();
				score_is_set = true;
				break;
			case "dir":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.dir = _objectCache[index];
				} else {
					let dir = this.dir
					if(!dir || dir._objectIndex != -index)
						this.dir = dir = new _Direction();
					(_objectCache[-index] = dir).deserialize_external(buffer);
				}
				dir_is_set = true;
				break;
			case "pos":
				buffer.readInt32();
				(this.pos || (this.pos = new _Vector2())).deserialize_external(buffer);
				pos_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!id_is_set) this.id = 0;
				if(!index_is_set) this.index = 0;
				if(!color_is_set) this.color = null;
				if(!pointerPosition_is_set) this.pointerPosition = new Vector2(0.0, 0.0, null);
				if(!touches_is_set) this.touches = [];
				if(!enableTouch_is_set) this.enableTouch = true;
				if(!textInput_is_set) this.textInput = "";
				if(!keysCurrentlyDown_is_set) this.keysCurrentlyDown = [];
				if(!controller_is_set) this.controller = new GameController(false, 0/*Keyboard*/);
				if(!controllerKeyDownFrame_is_set) this.controllerKeyDownFrame = [0, 0, 0, 0, 0, 0];
				if(!lostAtFrame_is_set) this.lostAtFrame = 0;
				if(!isReadyInLobby_is_set) this.isReadyInLobby = false;
				if(!score_is_set) this.score = 0;
				if(!dir_is_set) this.dir = Direction_diagonalDirections.get(this.index);
				if(!pos_is_set) this.pos = IntVector2_multiply_IntVector2(this.dir.vector, new IntVector2(690, 265, null))?.toVector2();
				return;
		}
	}
}
var Image_mainTexture;
var Image_VideoScreen;
var Image_Button;
var Image_Coin;
var Image_Star;
var Image_finger;
var Image_Next;
var Image_ThumbsUp;
var Image_Checkbox;
var Image_Menu;
var Image_New;
var Image_Quit;
var Image_Save;
var Image_Tutorial;
var Image_cameraIcon;
var Image_microphoneIcon;
var Image_settingsIcon;
var Image_speakerIcon;
var Image_starParticle;
var Image_hiddenIcon;
var Image_visibleIcon;
var Image_flipIcon;
var Image_rotateIcon;
var Image_Flag;
var Image_ResizeHandle;
function Image_init() {
	Image_mainTexture = new Texture("data:image/png;base64,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H0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO521xicAAAGjUlEQVSskgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCAWzZn1uV5kKIAAAAAElFTkSuQmCC", new Vector2(1024, 1024, null));
	Image_VideoScreen = new $Image("lib/core/media/VideoScreen0.png", Image_mainTexture, new Vector2(442, 442, null), [new ImageFrame(1, 1, 441, 331, 440, 330), new ImageFrame(1, 333, 441, 773, 440, 440)]);
	Image_Button = new $Image("lib/core/media/Button.png", Image_mainTexture, new Vector2(152, 42, null), [new ImageFrame(443, 1, 593, 41, 150, 40)]);
	Image_Coin = new $Image("lib/core/media/Coin0.png", Image_mainTexture, new Vector2(130, 130, null), [new ImageFrame(443, 43, 571, 171, 128, 128), new ImageFrame(443, 173, 571, 301, 128, 128)]);
	Image_Star = new $Image("lib/core/media/Star0.png", Image_mainTexture, new Vector2(130, 130, null), [new ImageFrame(443, 303, 571, 431, 128, 128), new ImageFrame(443, 433, 571, 561, 128, 128)]);
	Image_finger = new $Image("lib/core/media/finger0.png", Image_mainTexture, new Vector2(55, 78, null), [new ImageFrame(443, 563, 496, 639, 53, 76), new ImageFrame(498, 563, 551, 639, 53, 76)]);
	Image_Next = new $Image("lib/core/media/Next.png", Image_mainTexture, new Vector2(66, 66, null), [new ImageFrame(443, 641, 507, 705, 64, 64)]);
	Image_ThumbsUp = new $Image("lib/core/media/ThumbsUp.png", Image_mainTexture, new Vector2(66, 66, null), [new ImageFrame(509, 641, 573, 705, 64, 64)]);
	Image_Checkbox = new $Image("lib/core/media/Checkbox0.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(443, 707, 491, 755, 48, 48), new ImageFrame(493, 707, 541, 755, 48, 48)]);
	Image_Menu = new $Image("lib/core/media/Menu.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(543, 707, 591, 755, 48, 48)]);
	Image_New = new $Image("lib/core/media/New.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 1, 643, 49, 48, 48)]);
	Image_Quit = new $Image("lib/core/media/Quit.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 51, 643, 99, 48, 48)]);
	Image_Save = new $Image("lib/core/media/Save.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 101, 643, 149, 48, 48)]);
	Image_Tutorial = new $Image("lib/core/media/Tutorial.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 151, 643, 199, 48, 48)]);
	Image_cameraIcon = new $Image("lib/core/media/cameraIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 201, 643, 249, 48, 48)]);
	Image_microphoneIcon = new $Image("lib/core/media/microphoneIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 251, 643, 299, 48, 48)]);
	Image_settingsIcon = new $Image("lib/core/media/settingsIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 301, 643, 349, 48, 48)]);
	Image_speakerIcon = new $Image("lib/core/media/speakerIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 351, 643, 399, 48, 48)]);
	Image_starParticle = new $Image("lib/core/media/starParticle2.png", Image_mainTexture, new Vector2(50, 46, null), [new ImageFrame(595, 733, 621, 757, 26, 24), new ImageFrame(633, 531, 643, 541, 10, 10), new ImageFrame(595, 401, 643, 445, 48, 44)]);
	Image_hiddenIcon = new $Image("lib/core/media/hiddenIcon.png", Image_mainTexture, new Vector2(42, 42, null), [new ImageFrame(595, 447, 635, 487, 40, 40)]);
	Image_visibleIcon = new $Image("lib/core/media/visibleIcon.png", Image_mainTexture, new Vector2(42, 42, null), [new ImageFrame(595, 489, 635, 529, 40, 40)]);
	Image_flipIcon = new $Image("lib/core/media/flipIcon.png", Image_mainTexture, new Vector2(38, 38, null), [new ImageFrame(595, 531, 631, 567, 36, 36)]);
	Image_rotateIcon = new $Image("lib/core/media/rotateIcon.png", Image_mainTexture, new Vector2(38, 38, null), [new ImageFrame(595, 569, 631, 605, 36, 36)]);
	Image_Flag = [new $Image("lib/core/media/Flag-Language1-State0.png", Image_mainTexture, new Vector2(35, 23, null), [new ImageFrame(595, 653, 627, 674, 32, 21), new ImageFrame(595, 676, 627, 697, 32, 21)]), new $Image("lib/core/media/Flag-Language1-State0.png", Image_mainTexture, new Vector2(35, 23, null), [new ImageFrame(595, 607, 628, 628, 33, 21), new ImageFrame(595, 630, 628, 651, 33, 21)])];
	Image_ResizeHandle = new $Image("lib/core/media/ResizeHandle.png", Image_mainTexture, new Vector2(34, 34, null), [new ImageFrame(595, 699, 627, 731, 32, 32)]);
}
function $Image(file, texture, size, frames) {
	this.file = file;
	this.texture = texture;
	this.size = size?.clone();
	this.frames = frames;
}
$Image.prototype.clone = function() {
	let clone = new _Image();
	clone.file = this.file;
	clone.texture = this.texture;
	clone.size = this.size.clone();
	clone.frames = this.frames;
	return clone;
}
function _Image() {};
_Image.prototype = $Image.prototype;
function Image_serialize_internal(buffer) {
	if(Image_mainTexture) {
		var index = _objectCacheIndex.get(Image_mainTexture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_mainTexture, index = _objectCache.length);
			_objectCache.push(Image_mainTexture);
			buffer.writeInt32(-index);
			Image_mainTexture._objectIndex = index;
			Image_mainTexture.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_VideoScreen) {
		var index = _objectCacheIndex.get(Image_VideoScreen);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_VideoScreen, index = _objectCache.length);
			_objectCache.push(Image_VideoScreen);
			buffer.writeInt32(-index);
			Image_VideoScreen._objectIndex = index;
			Image_VideoScreen.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Button) {
		var index = _objectCacheIndex.get(Image_Button);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Button, index = _objectCache.length);
			_objectCache.push(Image_Button);
			buffer.writeInt32(-index);
			Image_Button._objectIndex = index;
			Image_Button.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Coin) {
		var index = _objectCacheIndex.get(Image_Coin);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Coin, index = _objectCache.length);
			_objectCache.push(Image_Coin);
			buffer.writeInt32(-index);
			Image_Coin._objectIndex = index;
			Image_Coin.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Star) {
		var index = _objectCacheIndex.get(Image_Star);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Star, index = _objectCache.length);
			_objectCache.push(Image_Star);
			buffer.writeInt32(-index);
			Image_Star._objectIndex = index;
			Image_Star.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_finger) {
		var index = _objectCacheIndex.get(Image_finger);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_finger, index = _objectCache.length);
			_objectCache.push(Image_finger);
			buffer.writeInt32(-index);
			Image_finger._objectIndex = index;
			Image_finger.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Next) {
		var index = _objectCacheIndex.get(Image_Next);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Next, index = _objectCache.length);
			_objectCache.push(Image_Next);
			buffer.writeInt32(-index);
			Image_Next._objectIndex = index;
			Image_Next.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_ThumbsUp) {
		var index = _objectCacheIndex.get(Image_ThumbsUp);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_ThumbsUp, index = _objectCache.length);
			_objectCache.push(Image_ThumbsUp);
			buffer.writeInt32(-index);
			Image_ThumbsUp._objectIndex = index;
			Image_ThumbsUp.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Checkbox) {
		var index = _objectCacheIndex.get(Image_Checkbox);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Checkbox, index = _objectCache.length);
			_objectCache.push(Image_Checkbox);
			buffer.writeInt32(-index);
			Image_Checkbox._objectIndex = index;
			Image_Checkbox.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Menu) {
		var index = _objectCacheIndex.get(Image_Menu);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Menu, index = _objectCache.length);
			_objectCache.push(Image_Menu);
			buffer.writeInt32(-index);
			Image_Menu._objectIndex = index;
			Image_Menu.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_New) {
		var index = _objectCacheIndex.get(Image_New);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_New, index = _objectCache.length);
			_objectCache.push(Image_New);
			buffer.writeInt32(-index);
			Image_New._objectIndex = index;
			Image_New.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Quit) {
		var index = _objectCacheIndex.get(Image_Quit);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Quit, index = _objectCache.length);
			_objectCache.push(Image_Quit);
			buffer.writeInt32(-index);
			Image_Quit._objectIndex = index;
			Image_Quit.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Save) {
		var index = _objectCacheIndex.get(Image_Save);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Save, index = _objectCache.length);
			_objectCache.push(Image_Save);
			buffer.writeInt32(-index);
			Image_Save._objectIndex = index;
			Image_Save.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Tutorial) {
		var index = _objectCacheIndex.get(Image_Tutorial);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Tutorial, index = _objectCache.length);
			_objectCache.push(Image_Tutorial);
			buffer.writeInt32(-index);
			Image_Tutorial._objectIndex = index;
			Image_Tutorial.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_cameraIcon) {
		var index = _objectCacheIndex.get(Image_cameraIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_cameraIcon, index = _objectCache.length);
			_objectCache.push(Image_cameraIcon);
			buffer.writeInt32(-index);
			Image_cameraIcon._objectIndex = index;
			Image_cameraIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_microphoneIcon) {
		var index = _objectCacheIndex.get(Image_microphoneIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_microphoneIcon, index = _objectCache.length);
			_objectCache.push(Image_microphoneIcon);
			buffer.writeInt32(-index);
			Image_microphoneIcon._objectIndex = index;
			Image_microphoneIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_settingsIcon) {
		var index = _objectCacheIndex.get(Image_settingsIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_settingsIcon, index = _objectCache.length);
			_objectCache.push(Image_settingsIcon);
			buffer.writeInt32(-index);
			Image_settingsIcon._objectIndex = index;
			Image_settingsIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_speakerIcon) {
		var index = _objectCacheIndex.get(Image_speakerIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_speakerIcon, index = _objectCache.length);
			_objectCache.push(Image_speakerIcon);
			buffer.writeInt32(-index);
			Image_speakerIcon._objectIndex = index;
			Image_speakerIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_starParticle) {
		var index = _objectCacheIndex.get(Image_starParticle);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_starParticle, index = _objectCache.length);
			_objectCache.push(Image_starParticle);
			buffer.writeInt32(-index);
			Image_starParticle._objectIndex = index;
			Image_starParticle.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_hiddenIcon) {
		var index = _objectCacheIndex.get(Image_hiddenIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_hiddenIcon, index = _objectCache.length);
			_objectCache.push(Image_hiddenIcon);
			buffer.writeInt32(-index);
			Image_hiddenIcon._objectIndex = index;
			Image_hiddenIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_visibleIcon) {
		var index = _objectCacheIndex.get(Image_visibleIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_visibleIcon, index = _objectCache.length);
			_objectCache.push(Image_visibleIcon);
			buffer.writeInt32(-index);
			Image_visibleIcon._objectIndex = index;
			Image_visibleIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_flipIcon) {
		var index = _objectCacheIndex.get(Image_flipIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_flipIcon, index = _objectCache.length);
			_objectCache.push(Image_flipIcon);
			buffer.writeInt32(-index);
			Image_flipIcon._objectIndex = index;
			Image_flipIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_rotateIcon) {
		var index = _objectCacheIndex.get(Image_rotateIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_rotateIcon, index = _objectCache.length);
			_objectCache.push(Image_rotateIcon);
			buffer.writeInt32(-index);
			Image_rotateIcon._objectIndex = index;
			Image_rotateIcon.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_Flag) {
		var index = _objectCacheIndex.get(Image_Flag);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Flag, index = _objectCache.length);
			_objectCache.push(Image_Flag);
			buffer.writeInt32(-index);
			Image_Flag._objectIndex = index;
			buffer.writeInt32(Image_Flag.length);
			for(let i=0, len=Image_Flag.length; i<len; ++i) {
				let Image_Flag_item = Image_Flag[i]
				if(Image_Flag_item) {
					var index = _objectCacheIndex.get(Image_Flag_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Image_Flag_item, index = _objectCache.length);
						_objectCache.push(Image_Flag_item);
						buffer.writeInt32(-index);
						Image_Flag_item._objectIndex = index;
						Image_Flag_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Image_ResizeHandle) {
		var index = _objectCacheIndex.get(Image_ResizeHandle);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_ResizeHandle, index = _objectCache.length);
			_objectCache.push(Image_ResizeHandle);
			buffer.writeInt32(-index);
			Image_ResizeHandle._objectIndex = index;
			Image_ResizeHandle.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Image_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_mainTexture = _objectCache[index];
	} else {
		if(!Image_mainTexture || Image_mainTexture._objectIndex != -index)
			Image_mainTexture = new _Texture();
		(_objectCache[-index] = Image_mainTexture).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_VideoScreen = _objectCache[index];
	} else {
		if(!Image_VideoScreen || Image_VideoScreen._objectIndex != -index)
			Image_VideoScreen = new _Image();
		(_objectCache[-index] = Image_VideoScreen).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Button = _objectCache[index];
	} else {
		if(!Image_Button || Image_Button._objectIndex != -index)
			Image_Button = new _Image();
		(_objectCache[-index] = Image_Button).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Coin = _objectCache[index];
	} else {
		if(!Image_Coin || Image_Coin._objectIndex != -index)
			Image_Coin = new _Image();
		(_objectCache[-index] = Image_Coin).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Star = _objectCache[index];
	} else {
		if(!Image_Star || Image_Star._objectIndex != -index)
			Image_Star = new _Image();
		(_objectCache[-index] = Image_Star).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_finger = _objectCache[index];
	} else {
		if(!Image_finger || Image_finger._objectIndex != -index)
			Image_finger = new _Image();
		(_objectCache[-index] = Image_finger).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Next = _objectCache[index];
	} else {
		if(!Image_Next || Image_Next._objectIndex != -index)
			Image_Next = new _Image();
		(_objectCache[-index] = Image_Next).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_ThumbsUp = _objectCache[index];
	} else {
		if(!Image_ThumbsUp || Image_ThumbsUp._objectIndex != -index)
			Image_ThumbsUp = new _Image();
		(_objectCache[-index] = Image_ThumbsUp).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Checkbox = _objectCache[index];
	} else {
		if(!Image_Checkbox || Image_Checkbox._objectIndex != -index)
			Image_Checkbox = new _Image();
		(_objectCache[-index] = Image_Checkbox).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Menu = _objectCache[index];
	} else {
		if(!Image_Menu || Image_Menu._objectIndex != -index)
			Image_Menu = new _Image();
		(_objectCache[-index] = Image_Menu).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_New = _objectCache[index];
	} else {
		if(!Image_New || Image_New._objectIndex != -index)
			Image_New = new _Image();
		(_objectCache[-index] = Image_New).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Quit = _objectCache[index];
	} else {
		if(!Image_Quit || Image_Quit._objectIndex != -index)
			Image_Quit = new _Image();
		(_objectCache[-index] = Image_Quit).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Save = _objectCache[index];
	} else {
		if(!Image_Save || Image_Save._objectIndex != -index)
			Image_Save = new _Image();
		(_objectCache[-index] = Image_Save).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Tutorial = _objectCache[index];
	} else {
		if(!Image_Tutorial || Image_Tutorial._objectIndex != -index)
			Image_Tutorial = new _Image();
		(_objectCache[-index] = Image_Tutorial).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_cameraIcon = _objectCache[index];
	} else {
		if(!Image_cameraIcon || Image_cameraIcon._objectIndex != -index)
			Image_cameraIcon = new _Image();
		(_objectCache[-index] = Image_cameraIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_microphoneIcon = _objectCache[index];
	} else {
		if(!Image_microphoneIcon || Image_microphoneIcon._objectIndex != -index)
			Image_microphoneIcon = new _Image();
		(_objectCache[-index] = Image_microphoneIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_settingsIcon = _objectCache[index];
	} else {
		if(!Image_settingsIcon || Image_settingsIcon._objectIndex != -index)
			Image_settingsIcon = new _Image();
		(_objectCache[-index] = Image_settingsIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_speakerIcon = _objectCache[index];
	} else {
		if(!Image_speakerIcon || Image_speakerIcon._objectIndex != -index)
			Image_speakerIcon = new _Image();
		(_objectCache[-index] = Image_speakerIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_starParticle = _objectCache[index];
	} else {
		if(!Image_starParticle || Image_starParticle._objectIndex != -index)
			Image_starParticle = new _Image();
		(_objectCache[-index] = Image_starParticle).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_hiddenIcon = _objectCache[index];
	} else {
		if(!Image_hiddenIcon || Image_hiddenIcon._objectIndex != -index)
			Image_hiddenIcon = new _Image();
		(_objectCache[-index] = Image_hiddenIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_visibleIcon = _objectCache[index];
	} else {
		if(!Image_visibleIcon || Image_visibleIcon._objectIndex != -index)
			Image_visibleIcon = new _Image();
		(_objectCache[-index] = Image_visibleIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_flipIcon = _objectCache[index];
	} else {
		if(!Image_flipIcon || Image_flipIcon._objectIndex != -index)
			Image_flipIcon = new _Image();
		(_objectCache[-index] = Image_flipIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_rotateIcon = _objectCache[index];
	} else {
		if(!Image_rotateIcon || Image_rotateIcon._objectIndex != -index)
			Image_rotateIcon = new _Image();
		(_objectCache[-index] = Image_rotateIcon).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_Flag = _objectCache[index];
	} else {
		if(!Image_Flag || Image_Flag._objectIndex != -index) Image_Flag = [];
		_objectCache[-index] = Image_Flag;
		for(let i=0, len = Image_Flag.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Flag[i] = _objectCache[index];
				} else {
					let Image_Flag_item = Image_Flag[i]
					if(!Image_Flag_item || Image_Flag_item._objectIndex != -index)
						Image_Flag[i] = Image_Flag_item = new _Image();
					(_objectCache[-index] = Image_Flag_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Image_ResizeHandle = _objectCache[index];
	} else {
		if(!Image_ResizeHandle || Image_ResizeHandle._objectIndex != -index)
			Image_ResizeHandle = new _Image();
		(_objectCache[-index] = Image_ResizeHandle).deserialize_internal(buffer);
	}
}
$Image.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	let texture = this.texture
	if(texture) {
		var index = _objectCacheIndex.get(texture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(texture, index = _objectCache.length);
			_objectCache.push(texture);
			buffer.writeInt32(-index);
			texture._objectIndex = index;
			texture.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(this.size || new _Vector2()).serialize_internal(buffer);
	let frames = this.frames
	if(frames) {
		var index = _objectCacheIndex.get(frames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(frames, index = _objectCache.length);
			_objectCache.push(frames);
			buffer.writeInt32(-index);
			frames._objectIndex = index;
			buffer.writeInt32(frames.length);
			for(let i=0, len=frames.length; i<len; ++i) {
				(frames[i] || new _ImageFrame()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
$Image.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.texture = _objectCache[index];
	} else {
		let texture = this.texture
		if(!texture || texture._objectIndex != -index)
			this.texture = texture = new _Texture();
		(_objectCache[-index] = texture).deserialize_internal(buffer);
	}
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.frames = _objectCache[index];
	} else {
		let frames = this.frames
		if(!frames || frames._objectIndex != -index) this.frames = frames = [];
		_objectCache[-index] = frames;
		for(let i=0, len = frames.length = buffer.readInt32(); i<len; ++i) {
				(frames[i] || (frames[i] = new _ImageFrame())).deserialize_internal(buffer);
		}
	}
}
function Image_serialize_external(buffer) {
	buffer.writeString("mainTexture");
	let Image_mainTexture_startPos = buffer.reserveSize();
	if(Image_mainTexture) {
		var index = _objectCacheIndex.get(Image_mainTexture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_mainTexture, index = _objectCache.length);
			_objectCache.push(Image_mainTexture);
			buffer.writeInt32(-index);
			Image_mainTexture._objectIndex = index;
			Image_mainTexture.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_mainTexture_startPos);
	buffer.writeString("VideoScreen");
	let Image_VideoScreen_startPos = buffer.reserveSize();
	if(Image_VideoScreen) {
		var index = _objectCacheIndex.get(Image_VideoScreen);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_VideoScreen, index = _objectCache.length);
			_objectCache.push(Image_VideoScreen);
			buffer.writeInt32(-index);
			Image_VideoScreen._objectIndex = index;
			Image_VideoScreen.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_VideoScreen_startPos);
	buffer.writeString("Button");
	let Image_Button_startPos = buffer.reserveSize();
	if(Image_Button) {
		var index = _objectCacheIndex.get(Image_Button);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Button, index = _objectCache.length);
			_objectCache.push(Image_Button);
			buffer.writeInt32(-index);
			Image_Button._objectIndex = index;
			Image_Button.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Button_startPos);
	buffer.writeString("Coin");
	let Image_Coin_startPos = buffer.reserveSize();
	if(Image_Coin) {
		var index = _objectCacheIndex.get(Image_Coin);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Coin, index = _objectCache.length);
			_objectCache.push(Image_Coin);
			buffer.writeInt32(-index);
			Image_Coin._objectIndex = index;
			Image_Coin.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Coin_startPos);
	buffer.writeString("Star");
	let Image_Star_startPos = buffer.reserveSize();
	if(Image_Star) {
		var index = _objectCacheIndex.get(Image_Star);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Star, index = _objectCache.length);
			_objectCache.push(Image_Star);
			buffer.writeInt32(-index);
			Image_Star._objectIndex = index;
			Image_Star.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Star_startPos);
	buffer.writeString("finger");
	let Image_finger_startPos = buffer.reserveSize();
	if(Image_finger) {
		var index = _objectCacheIndex.get(Image_finger);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_finger, index = _objectCache.length);
			_objectCache.push(Image_finger);
			buffer.writeInt32(-index);
			Image_finger._objectIndex = index;
			Image_finger.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_finger_startPos);
	buffer.writeString("Next");
	let Image_Next_startPos = buffer.reserveSize();
	if(Image_Next) {
		var index = _objectCacheIndex.get(Image_Next);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Next, index = _objectCache.length);
			_objectCache.push(Image_Next);
			buffer.writeInt32(-index);
			Image_Next._objectIndex = index;
			Image_Next.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Next_startPos);
	buffer.writeString("ThumbsUp");
	let Image_ThumbsUp_startPos = buffer.reserveSize();
	if(Image_ThumbsUp) {
		var index = _objectCacheIndex.get(Image_ThumbsUp);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_ThumbsUp, index = _objectCache.length);
			_objectCache.push(Image_ThumbsUp);
			buffer.writeInt32(-index);
			Image_ThumbsUp._objectIndex = index;
			Image_ThumbsUp.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_ThumbsUp_startPos);
	buffer.writeString("Checkbox");
	let Image_Checkbox_startPos = buffer.reserveSize();
	if(Image_Checkbox) {
		var index = _objectCacheIndex.get(Image_Checkbox);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Checkbox, index = _objectCache.length);
			_objectCache.push(Image_Checkbox);
			buffer.writeInt32(-index);
			Image_Checkbox._objectIndex = index;
			Image_Checkbox.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Checkbox_startPos);
	buffer.writeString("Menu");
	let Image_Menu_startPos = buffer.reserveSize();
	if(Image_Menu) {
		var index = _objectCacheIndex.get(Image_Menu);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Menu, index = _objectCache.length);
			_objectCache.push(Image_Menu);
			buffer.writeInt32(-index);
			Image_Menu._objectIndex = index;
			Image_Menu.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Menu_startPos);
	buffer.writeString("New");
	let Image_New_startPos = buffer.reserveSize();
	if(Image_New) {
		var index = _objectCacheIndex.get(Image_New);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_New, index = _objectCache.length);
			_objectCache.push(Image_New);
			buffer.writeInt32(-index);
			Image_New._objectIndex = index;
			Image_New.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_New_startPos);
	buffer.writeString("Quit");
	let Image_Quit_startPos = buffer.reserveSize();
	if(Image_Quit) {
		var index = _objectCacheIndex.get(Image_Quit);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Quit, index = _objectCache.length);
			_objectCache.push(Image_Quit);
			buffer.writeInt32(-index);
			Image_Quit._objectIndex = index;
			Image_Quit.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Quit_startPos);
	buffer.writeString("Save");
	let Image_Save_startPos = buffer.reserveSize();
	if(Image_Save) {
		var index = _objectCacheIndex.get(Image_Save);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Save, index = _objectCache.length);
			_objectCache.push(Image_Save);
			buffer.writeInt32(-index);
			Image_Save._objectIndex = index;
			Image_Save.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Save_startPos);
	buffer.writeString("Tutorial");
	let Image_Tutorial_startPos = buffer.reserveSize();
	if(Image_Tutorial) {
		var index = _objectCacheIndex.get(Image_Tutorial);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Tutorial, index = _objectCache.length);
			_objectCache.push(Image_Tutorial);
			buffer.writeInt32(-index);
			Image_Tutorial._objectIndex = index;
			Image_Tutorial.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Tutorial_startPos);
	buffer.writeString("cameraIcon");
	let Image_cameraIcon_startPos = buffer.reserveSize();
	if(Image_cameraIcon) {
		var index = _objectCacheIndex.get(Image_cameraIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_cameraIcon, index = _objectCache.length);
			_objectCache.push(Image_cameraIcon);
			buffer.writeInt32(-index);
			Image_cameraIcon._objectIndex = index;
			Image_cameraIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_cameraIcon_startPos);
	buffer.writeString("microphoneIcon");
	let Image_microphoneIcon_startPos = buffer.reserveSize();
	if(Image_microphoneIcon) {
		var index = _objectCacheIndex.get(Image_microphoneIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_microphoneIcon, index = _objectCache.length);
			_objectCache.push(Image_microphoneIcon);
			buffer.writeInt32(-index);
			Image_microphoneIcon._objectIndex = index;
			Image_microphoneIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_microphoneIcon_startPos);
	buffer.writeString("settingsIcon");
	let Image_settingsIcon_startPos = buffer.reserveSize();
	if(Image_settingsIcon) {
		var index = _objectCacheIndex.get(Image_settingsIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_settingsIcon, index = _objectCache.length);
			_objectCache.push(Image_settingsIcon);
			buffer.writeInt32(-index);
			Image_settingsIcon._objectIndex = index;
			Image_settingsIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_settingsIcon_startPos);
	buffer.writeString("speakerIcon");
	let Image_speakerIcon_startPos = buffer.reserveSize();
	if(Image_speakerIcon) {
		var index = _objectCacheIndex.get(Image_speakerIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_speakerIcon, index = _objectCache.length);
			_objectCache.push(Image_speakerIcon);
			buffer.writeInt32(-index);
			Image_speakerIcon._objectIndex = index;
			Image_speakerIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_speakerIcon_startPos);
	buffer.writeString("starParticle");
	let Image_starParticle_startPos = buffer.reserveSize();
	if(Image_starParticle) {
		var index = _objectCacheIndex.get(Image_starParticle);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_starParticle, index = _objectCache.length);
			_objectCache.push(Image_starParticle);
			buffer.writeInt32(-index);
			Image_starParticle._objectIndex = index;
			Image_starParticle.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_starParticle_startPos);
	buffer.writeString("hiddenIcon");
	let Image_hiddenIcon_startPos = buffer.reserveSize();
	if(Image_hiddenIcon) {
		var index = _objectCacheIndex.get(Image_hiddenIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_hiddenIcon, index = _objectCache.length);
			_objectCache.push(Image_hiddenIcon);
			buffer.writeInt32(-index);
			Image_hiddenIcon._objectIndex = index;
			Image_hiddenIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_hiddenIcon_startPos);
	buffer.writeString("visibleIcon");
	let Image_visibleIcon_startPos = buffer.reserveSize();
	if(Image_visibleIcon) {
		var index = _objectCacheIndex.get(Image_visibleIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_visibleIcon, index = _objectCache.length);
			_objectCache.push(Image_visibleIcon);
			buffer.writeInt32(-index);
			Image_visibleIcon._objectIndex = index;
			Image_visibleIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_visibleIcon_startPos);
	buffer.writeString("flipIcon");
	let Image_flipIcon_startPos = buffer.reserveSize();
	if(Image_flipIcon) {
		var index = _objectCacheIndex.get(Image_flipIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_flipIcon, index = _objectCache.length);
			_objectCache.push(Image_flipIcon);
			buffer.writeInt32(-index);
			Image_flipIcon._objectIndex = index;
			Image_flipIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_flipIcon_startPos);
	buffer.writeString("rotateIcon");
	let Image_rotateIcon_startPos = buffer.reserveSize();
	if(Image_rotateIcon) {
		var index = _objectCacheIndex.get(Image_rotateIcon);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_rotateIcon, index = _objectCache.length);
			_objectCache.push(Image_rotateIcon);
			buffer.writeInt32(-index);
			Image_rotateIcon._objectIndex = index;
			Image_rotateIcon.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_rotateIcon_startPos);
	buffer.writeString("Flag");
	let Image_Flag_startPos = buffer.reserveSize();
	if(Image_Flag) {
		var index = _objectCacheIndex.get(Image_Flag);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_Flag, index = _objectCache.length);
			_objectCache.push(Image_Flag);
			buffer.writeInt32(-index);
			Image_Flag._objectIndex = index;
			buffer.writeInt32(Image_Flag.length);
			for(let i=0, len=Image_Flag.length; i<len; ++i) {
				let Image_Flag_item = Image_Flag[i]
				if(Image_Flag_item) {
					var index = _objectCacheIndex.get(Image_Flag_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Image_Flag_item, index = _objectCache.length);
						_objectCache.push(Image_Flag_item);
						buffer.writeInt32(-index);
						Image_Flag_item._objectIndex = index;
						Image_Flag_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_Flag_startPos);
	buffer.writeString("ResizeHandle");
	let Image_ResizeHandle_startPos = buffer.reserveSize();
	if(Image_ResizeHandle) {
		var index = _objectCacheIndex.get(Image_ResizeHandle);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Image_ResizeHandle, index = _objectCache.length);
			_objectCache.push(Image_ResizeHandle);
			buffer.writeInt32(-index);
			Image_ResizeHandle._objectIndex = index;
			Image_ResizeHandle.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Image_ResizeHandle_startPos);
	buffer.writeString("");
}
function Image_deserialize_external(buffer) {
	let mainTexture_is_set = false, VideoScreen_is_set = false, Button_is_set = false, Coin_is_set = false, Star_is_set = false, finger_is_set = false, Next_is_set = false, ThumbsUp_is_set = false, Checkbox_is_set = false, Menu_is_set = false, New_is_set = false, Quit_is_set = false, Save_is_set = false, Tutorial_is_set = false, cameraIcon_is_set = false, microphoneIcon_is_set = false, settingsIcon_is_set = false, speakerIcon_is_set = false, starParticle_is_set = false, hiddenIcon_is_set = false, visibleIcon_is_set = false, flipIcon_is_set = false, rotateIcon_is_set = false, Flag_is_set = false, ResizeHandle_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "mainTexture":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_mainTexture = _objectCache[index];
				} else {
					if(!Image_mainTexture || Image_mainTexture._objectIndex != -index)
						Image_mainTexture = new _Texture();
					(_objectCache[-index] = Image_mainTexture).deserialize_external(buffer);
				}
				mainTexture_is_set = true;
				break;
			case "VideoScreen":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_VideoScreen = _objectCache[index];
				} else {
					if(!Image_VideoScreen || Image_VideoScreen._objectIndex != -index)
						Image_VideoScreen = new _Image();
					(_objectCache[-index] = Image_VideoScreen).deserialize_external(buffer);
				}
				VideoScreen_is_set = true;
				break;
			case "Button":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Button = _objectCache[index];
				} else {
					if(!Image_Button || Image_Button._objectIndex != -index)
						Image_Button = new _Image();
					(_objectCache[-index] = Image_Button).deserialize_external(buffer);
				}
				Button_is_set = true;
				break;
			case "Coin":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Coin = _objectCache[index];
				} else {
					if(!Image_Coin || Image_Coin._objectIndex != -index)
						Image_Coin = new _Image();
					(_objectCache[-index] = Image_Coin).deserialize_external(buffer);
				}
				Coin_is_set = true;
				break;
			case "Star":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Star = _objectCache[index];
				} else {
					if(!Image_Star || Image_Star._objectIndex != -index)
						Image_Star = new _Image();
					(_objectCache[-index] = Image_Star).deserialize_external(buffer);
				}
				Star_is_set = true;
				break;
			case "finger":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_finger = _objectCache[index];
				} else {
					if(!Image_finger || Image_finger._objectIndex != -index)
						Image_finger = new _Image();
					(_objectCache[-index] = Image_finger).deserialize_external(buffer);
				}
				finger_is_set = true;
				break;
			case "Next":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Next = _objectCache[index];
				} else {
					if(!Image_Next || Image_Next._objectIndex != -index)
						Image_Next = new _Image();
					(_objectCache[-index] = Image_Next).deserialize_external(buffer);
				}
				Next_is_set = true;
				break;
			case "ThumbsUp":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_ThumbsUp = _objectCache[index];
				} else {
					if(!Image_ThumbsUp || Image_ThumbsUp._objectIndex != -index)
						Image_ThumbsUp = new _Image();
					(_objectCache[-index] = Image_ThumbsUp).deserialize_external(buffer);
				}
				ThumbsUp_is_set = true;
				break;
			case "Checkbox":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Checkbox = _objectCache[index];
				} else {
					if(!Image_Checkbox || Image_Checkbox._objectIndex != -index)
						Image_Checkbox = new _Image();
					(_objectCache[-index] = Image_Checkbox).deserialize_external(buffer);
				}
				Checkbox_is_set = true;
				break;
			case "Menu":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Menu = _objectCache[index];
				} else {
					if(!Image_Menu || Image_Menu._objectIndex != -index)
						Image_Menu = new _Image();
					(_objectCache[-index] = Image_Menu).deserialize_external(buffer);
				}
				Menu_is_set = true;
				break;
			case "New":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_New = _objectCache[index];
				} else {
					if(!Image_New || Image_New._objectIndex != -index)
						Image_New = new _Image();
					(_objectCache[-index] = Image_New).deserialize_external(buffer);
				}
				New_is_set = true;
				break;
			case "Quit":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Quit = _objectCache[index];
				} else {
					if(!Image_Quit || Image_Quit._objectIndex != -index)
						Image_Quit = new _Image();
					(_objectCache[-index] = Image_Quit).deserialize_external(buffer);
				}
				Quit_is_set = true;
				break;
			case "Save":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Save = _objectCache[index];
				} else {
					if(!Image_Save || Image_Save._objectIndex != -index)
						Image_Save = new _Image();
					(_objectCache[-index] = Image_Save).deserialize_external(buffer);
				}
				Save_is_set = true;
				break;
			case "Tutorial":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Tutorial = _objectCache[index];
				} else {
					if(!Image_Tutorial || Image_Tutorial._objectIndex != -index)
						Image_Tutorial = new _Image();
					(_objectCache[-index] = Image_Tutorial).deserialize_external(buffer);
				}
				Tutorial_is_set = true;
				break;
			case "cameraIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_cameraIcon = _objectCache[index];
				} else {
					if(!Image_cameraIcon || Image_cameraIcon._objectIndex != -index)
						Image_cameraIcon = new _Image();
					(_objectCache[-index] = Image_cameraIcon).deserialize_external(buffer);
				}
				cameraIcon_is_set = true;
				break;
			case "microphoneIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_microphoneIcon = _objectCache[index];
				} else {
					if(!Image_microphoneIcon || Image_microphoneIcon._objectIndex != -index)
						Image_microphoneIcon = new _Image();
					(_objectCache[-index] = Image_microphoneIcon).deserialize_external(buffer);
				}
				microphoneIcon_is_set = true;
				break;
			case "settingsIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_settingsIcon = _objectCache[index];
				} else {
					if(!Image_settingsIcon || Image_settingsIcon._objectIndex != -index)
						Image_settingsIcon = new _Image();
					(_objectCache[-index] = Image_settingsIcon).deserialize_external(buffer);
				}
				settingsIcon_is_set = true;
				break;
			case "speakerIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_speakerIcon = _objectCache[index];
				} else {
					if(!Image_speakerIcon || Image_speakerIcon._objectIndex != -index)
						Image_speakerIcon = new _Image();
					(_objectCache[-index] = Image_speakerIcon).deserialize_external(buffer);
				}
				speakerIcon_is_set = true;
				break;
			case "starParticle":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_starParticle = _objectCache[index];
				} else {
					if(!Image_starParticle || Image_starParticle._objectIndex != -index)
						Image_starParticle = new _Image();
					(_objectCache[-index] = Image_starParticle).deserialize_external(buffer);
				}
				starParticle_is_set = true;
				break;
			case "hiddenIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_hiddenIcon = _objectCache[index];
				} else {
					if(!Image_hiddenIcon || Image_hiddenIcon._objectIndex != -index)
						Image_hiddenIcon = new _Image();
					(_objectCache[-index] = Image_hiddenIcon).deserialize_external(buffer);
				}
				hiddenIcon_is_set = true;
				break;
			case "visibleIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_visibleIcon = _objectCache[index];
				} else {
					if(!Image_visibleIcon || Image_visibleIcon._objectIndex != -index)
						Image_visibleIcon = new _Image();
					(_objectCache[-index] = Image_visibleIcon).deserialize_external(buffer);
				}
				visibleIcon_is_set = true;
				break;
			case "flipIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_flipIcon = _objectCache[index];
				} else {
					if(!Image_flipIcon || Image_flipIcon._objectIndex != -index)
						Image_flipIcon = new _Image();
					(_objectCache[-index] = Image_flipIcon).deserialize_external(buffer);
				}
				flipIcon_is_set = true;
				break;
			case "rotateIcon":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_rotateIcon = _objectCache[index];
				} else {
					if(!Image_rotateIcon || Image_rotateIcon._objectIndex != -index)
						Image_rotateIcon = new _Image();
					(_objectCache[-index] = Image_rotateIcon).deserialize_external(buffer);
				}
				rotateIcon_is_set = true;
				break;
			case "Flag":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_Flag = _objectCache[index];
				} else {
					if(!Image_Flag || Image_Flag._objectIndex != -index) Image_Flag = [];
					_objectCache[-index] = Image_Flag;
					for(let i=0, len = Image_Flag.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Image_Flag[i] = _objectCache[index];
							} else {
								let Image_Flag_item = Image_Flag[i]
								if(!Image_Flag_item || Image_Flag_item._objectIndex != -index)
									Image_Flag[i] = Image_Flag_item = new _Image();
								(_objectCache[-index] = Image_Flag_item).deserialize_external(buffer);
							}
					}
				}
				Flag_is_set = true;
				break;
			case "ResizeHandle":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Image_ResizeHandle = _objectCache[index];
				} else {
					if(!Image_ResizeHandle || Image_ResizeHandle._objectIndex != -index)
						Image_ResizeHandle = new _Image();
					(_objectCache[-index] = Image_ResizeHandle).deserialize_external(buffer);
				}
				ResizeHandle_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!mainTexture_is_set) Image_mainTexture = new Texture("data:image/png;base64,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H0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO521xicAAAGjUlEQVSskgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCBoD5A8gnQIAAAQIECBAgQIAAgYeAAeBxZ5UECBAgQIAAAQIECBAgMBcwAMwfQD4BAgQIECBAgAABAgQIPAQMAI87qyRAgAABAgQIECBAgACBuYABYP4A8gkQIECAAAECBAgQIEDgIWAAeNxZJQECBAgQIECAAAECBAjMBQwA8weQT4AAAQIECBAgQIAAAQIPAQPA484qCRAgQIAAAQIECBAgQGAuYACYP4B8AgQIECBAgAABAgQIEHgIGAAed1ZJgAABAgQIECBAgAABAnMBA8D8AeQTIECAAAECBAgQIECAwEPAAPC4s0oCBAgQIECAAAECBAgQmAsYAOYPIJ8AAQIECBAgQIAAAQIEHgIGgMedVRIgQIAAAQIECBAgQIDAXMAAMH8A+QQIECBAgAABAgQIECDwEDAAPO6skgABAgQIECBAgAABAgTmAgaA+QPIJ0CAAAECBAgQIECAAIGHgAHgcWeVBAgQIECAAAECBAgQIDAXMADMH0A+AQIECBAgQIAAAQIECDwEDACPO6skQIAAAQIECBAgQIAAgbmAAWD+APIJECBAgAABAgQIECBA4CFgAHjcWSUBAgQIECBAgAABAgQIzAUMAPMHkE+AAAECBAgQIECAAAECDwEDwOPOKgkQIECAAAECBAgQIEBgLmAAmD+AfAIECBAgQIAAAQIECBB4CBgAHndWSYAAAQIECBAgQIAAAQJzAQPA/AHkEyBAgAABAgQIECBAgMBDwADwuLNKAgQIECBAgAABAgQIEJgLGADmDyCfAAECBAgQIECAAAECBB4CBoDHnVUSIECAAAECBAgQIECAwFzAADB/APkECBAgQIAAAQIECBAg8BAwADzurJIAAQIECBAgQIAAAQIE5gIGgPkDyCdAgAABAgQIECBAgACBh4AB4HFnlQQIECBAgAABAgQIECAwFzAAzB9APgECBAgQIECAAAECBAg8BAwAjzurJECAAAECBAgQIECAAIG5gAFg/gDyCRAgQIAAAQIECBAgQOAhYAB43FklAQIECBAgQIAAAQIECMwFDADzB5BPgAABAgQIECBAgAABAg8BA8DjzioJECBAgAABAgQIECBAYC5gAJg/gHwCBAgQIECAAAECBAgQeAgYAB53VkmAAAECBAgQIECAAAECcwEDwPwB5BMgQIAAAQIECBAgQIDAQ8AA8LizSgIECBAgQIAAAQIECBCYCxgA5g8gnwABAgQIECBAgAABAgQeAgaAx51VEiBAgAABAgQIECBAgMBcwAAwfwD5BAgQIECAAAECBAgQIPAQMAA87qySAAECBAgQIECAAAECBOYCAWzZn1uV5kKIAAAAAElFTkSuQmCC", new Vector2(1024, 1024, null));
				if(!VideoScreen_is_set) Image_VideoScreen = new $Image("lib/core/media/VideoScreen0.png", Image_mainTexture, new Vector2(442, 442, null), [new ImageFrame(1, 1, 441, 331, 440, 330), new ImageFrame(1, 333, 441, 773, 440, 440)]);
				if(!Button_is_set) Image_Button = new $Image("lib/core/media/Button.png", Image_mainTexture, new Vector2(152, 42, null), [new ImageFrame(443, 1, 593, 41, 150, 40)]);
				if(!Coin_is_set) Image_Coin = new $Image("lib/core/media/Coin0.png", Image_mainTexture, new Vector2(130, 130, null), [new ImageFrame(443, 43, 571, 171, 128, 128), new ImageFrame(443, 173, 571, 301, 128, 128)]);
				if(!Star_is_set) Image_Star = new $Image("lib/core/media/Star0.png", Image_mainTexture, new Vector2(130, 130, null), [new ImageFrame(443, 303, 571, 431, 128, 128), new ImageFrame(443, 433, 571, 561, 128, 128)]);
				if(!finger_is_set) Image_finger = new $Image("lib/core/media/finger0.png", Image_mainTexture, new Vector2(55, 78, null), [new ImageFrame(443, 563, 496, 639, 53, 76), new ImageFrame(498, 563, 551, 639, 53, 76)]);
				if(!Next_is_set) Image_Next = new $Image("lib/core/media/Next.png", Image_mainTexture, new Vector2(66, 66, null), [new ImageFrame(443, 641, 507, 705, 64, 64)]);
				if(!ThumbsUp_is_set) Image_ThumbsUp = new $Image("lib/core/media/ThumbsUp.png", Image_mainTexture, new Vector2(66, 66, null), [new ImageFrame(509, 641, 573, 705, 64, 64)]);
				if(!Checkbox_is_set) Image_Checkbox = new $Image("lib/core/media/Checkbox0.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(443, 707, 491, 755, 48, 48), new ImageFrame(493, 707, 541, 755, 48, 48)]);
				if(!Menu_is_set) Image_Menu = new $Image("lib/core/media/Menu.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(543, 707, 591, 755, 48, 48)]);
				if(!New_is_set) Image_New = new $Image("lib/core/media/New.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 1, 643, 49, 48, 48)]);
				if(!Quit_is_set) Image_Quit = new $Image("lib/core/media/Quit.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 51, 643, 99, 48, 48)]);
				if(!Save_is_set) Image_Save = new $Image("lib/core/media/Save.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 101, 643, 149, 48, 48)]);
				if(!Tutorial_is_set) Image_Tutorial = new $Image("lib/core/media/Tutorial.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 151, 643, 199, 48, 48)]);
				if(!cameraIcon_is_set) Image_cameraIcon = new $Image("lib/core/media/cameraIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 201, 643, 249, 48, 48)]);
				if(!microphoneIcon_is_set) Image_microphoneIcon = new $Image("lib/core/media/microphoneIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 251, 643, 299, 48, 48)]);
				if(!settingsIcon_is_set) Image_settingsIcon = new $Image("lib/core/media/settingsIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 301, 643, 349, 48, 48)]);
				if(!speakerIcon_is_set) Image_speakerIcon = new $Image("lib/core/media/speakerIcon.png", Image_mainTexture, new Vector2(50, 50, null), [new ImageFrame(595, 351, 643, 399, 48, 48)]);
				if(!starParticle_is_set) Image_starParticle = new $Image("lib/core/media/starParticle2.png", Image_mainTexture, new Vector2(50, 46, null), [new ImageFrame(595, 733, 621, 757, 26, 24), new ImageFrame(633, 531, 643, 541, 10, 10), new ImageFrame(595, 401, 643, 445, 48, 44)]);
				if(!hiddenIcon_is_set) Image_hiddenIcon = new $Image("lib/core/media/hiddenIcon.png", Image_mainTexture, new Vector2(42, 42, null), [new ImageFrame(595, 447, 635, 487, 40, 40)]);
				if(!visibleIcon_is_set) Image_visibleIcon = new $Image("lib/core/media/visibleIcon.png", Image_mainTexture, new Vector2(42, 42, null), [new ImageFrame(595, 489, 635, 529, 40, 40)]);
				if(!flipIcon_is_set) Image_flipIcon = new $Image("lib/core/media/flipIcon.png", Image_mainTexture, new Vector2(38, 38, null), [new ImageFrame(595, 531, 631, 567, 36, 36)]);
				if(!rotateIcon_is_set) Image_rotateIcon = new $Image("lib/core/media/rotateIcon.png", Image_mainTexture, new Vector2(38, 38, null), [new ImageFrame(595, 569, 631, 605, 36, 36)]);
				if(!Flag_is_set) Image_Flag = [new $Image("lib/core/media/Flag-Language1-State0.png", Image_mainTexture, new Vector2(35, 23, null), [new ImageFrame(595, 653, 627, 674, 32, 21), new ImageFrame(595, 676, 627, 697, 32, 21)]), new $Image("lib/core/media/Flag-Language1-State0.png", Image_mainTexture, new Vector2(35, 23, null), [new ImageFrame(595, 607, 628, 628, 33, 21), new ImageFrame(595, 630, 628, 651, 33, 21)])];
				if(!ResizeHandle_is_set) Image_ResizeHandle = new $Image("lib/core/media/ResizeHandle.png", Image_mainTexture, new Vector2(34, 34, null), [new ImageFrame(595, 699, 627, 731, 32, 32)]);
				return;
		}
	}
}
$Image.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("texture");
	let texture_startPos = buffer.reserveSize();
	let texture = this.texture
	if(texture) {
		var index = _objectCacheIndex.get(texture);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(texture, index = _objectCache.length);
			_objectCache.push(texture);
			buffer.writeInt32(-index);
			texture._objectIndex = index;
			texture.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(texture_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("frames");
	let frames = this.frames
	let frames_startPos = buffer.reserveSize();
	if(frames) {
		var index = _objectCacheIndex.get(frames);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(frames, index = _objectCache.length);
			_objectCache.push(frames);
			buffer.writeInt32(-index);
			frames._objectIndex = index;
			buffer.writeInt32(frames.length);
			for(let i=0, len=frames.length; i<len; ++i) {
				(frames[i] || new _ImageFrame()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(frames_startPos);
	buffer.writeString("");
}
$Image.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, texture_is_set = false, size_is_set = false, frames_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "texture":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.texture = _objectCache[index];
				} else {
					let texture = this.texture
					if(!texture || texture._objectIndex != -index)
						this.texture = texture = new _Texture();
					(_objectCache[-index] = texture).deserialize_external(buffer);
				}
				texture_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "frames":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.frames = _objectCache[index];
				} else {
					let frames = this.frames
					if(!frames || frames._objectIndex != -index) this.frames = frames = [];
					_objectCache[-index] = frames;
					for(let i=0, len = frames.length = buffer.readInt32(); i<len; ++i) {
							(frames[i] || (frames[i] = new _ImageFrame())).deserialize_external(buffer);
					}
				}
				frames_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!texture_is_set) this.texture = null;
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!frames_is_set) this.frames = [];
				return;
		}
	}
}
function Font(name, file, offset, actualHeightFactor) {
	this.name = name;
	this.file = file;
	this.offset = offset?.clone();
	this.actualHeightFactor = actualHeightFactor;
}
Font.prototype.open = async function() {
	if(!window._fontCache) _fontCache = {}
	let font = _fontCache[this.file]
	if(!font) {
		
		let font = new FontFace(this.name, "url("+this.file+")");
		await font.load();
		document.fonts.add(font);
		_fontCache[this.file] = font;
		setTimeout(() => this.calculateOffset(), 0)
	}
	this.calculateOffset()
	return this
}
Font.prototype.calculateOffset = function() {
	const fontsize = 64.0
	const margin = 32.0
	const canvas = document.createElement("canvas");
	const context=canvas.getContext("2d");
	const w = fontsize*2+margin, h = fontsize*2+margin;
	canvas.height = h;
	canvas.width = w;
	context.textBaseline="top";
	context.font=fontsize+"px "+this.name;
	context.fillStyle="red";
	context.fillText("M", margin, margin);
	let pixels = context.getImageData(0,0,w,h).data;
	
	let minY = 0
	findMinY:
	for(var y=0;y<h;y++) {
		for(var x=0;x<w;x++) {
			if(pixels[(y*w+x)*4+3] > 0) {
				minY = y-margin; break findMinY;
			}
		}
	}
	
	let minX = 0
	findMinX:
	for(var x=0;x<w;x++) {
		for(var y=0;y<h;y++) {
			if(pixels[(y*w+x)*4+3] > 0) {
				minX = x-margin; break findMinX;
			}
		}
	}
	this.offset = new Vector2(minX/fontsize, minY/(fontsize*this.actualHeightFactor))
}
Font.prototype.clone = function() {
	let clone = new _Font();
	clone.name = this.name;
	clone.file = this.file;
	clone.offset = this.offset.clone();
	clone.actualHeightFactor = this.actualHeightFactor;
	return clone;
}
function _Font() {};
_Font.prototype = Font.prototype;
Font.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeString(this.file);
	(this.offset || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.actualHeightFactor);
}
Font.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.file = buffer.readString();
	(this.offset || (this.offset = new _Vector2())).deserialize_internal(buffer);
	this.actualHeightFactor = buffer.readFloat64();
}
Font.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("offset");
	let offset_startPos = buffer.reserveSize();
	(this.offset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(offset_startPos);
	buffer.writeString("actualHeightFactor");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.actualHeightFactor);
	buffer.writeString("");
}
Font.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, file_is_set = false, offset_is_set = false, actualHeightFactor_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "offset":
				buffer.readInt32();
				(this.offset || (this.offset = new _Vector2())).deserialize_external(buffer);
				offset_is_set = true;
				break;
			case "actualHeightFactor":
				buffer.readInt32();
				this.actualHeightFactor = buffer.readFloat64();
				actualHeightFactor_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!file_is_set) this.file = "";
				if(!offset_is_set) this.offset = new Vector2(0.0, 0.0, null);
				if(!actualHeightFactor_is_set) this.actualHeightFactor = .76;
				return;
		}
	}
}
var Platform_userCount;
var Platform_supportedUserCount;
var Platform_showSafeArea;
var Platform_showDebugInfo;
var Platform_isLocal;
var Platform_intervalMode;
var Platform_os;
var Platform_isMobile;
var Platform_isBrowser;
var Platform_isDebug;
var Platform_isSmallScreen;
var Platform_isStaging;
var Platform_engineStarted;
var Platform_mode;
var Platform_fastForward;
var Platform_waitingForInitialData;
var Platform_interval;
function Platform_init() {
	Platform_userCount = 4;
	Platform_supportedUserCount = new Range(2, 4);
	Platform_showSafeArea = true;
	Platform_showDebugInfo = false;
	Platform_isLocal = false;
	Platform_intervalMode = 0/*JavaScriptInterval*/;
	Platform_os = 0/*Windows*/;
	Platform_isMobile = false;
	Platform_isBrowser = false;
	Platform_isDebug = false;
	Platform_isSmallScreen = false;
	Platform_isStaging = false;
	Platform_engineStarted = false;
	Platform_mode = 0/*Pause*/;
	Platform_fastForward = false;
	Platform_waitingForInitialData = 0;
	Platform_interval = null;
}
function Platform_openMedia(callback) {
	Promise.all([Image_mainTexture.open()]).then(() => callback())
}
function Platform_protocolAndHost() {
	return (location.host ? "https://" + location.host : "http://localhost");
}
function Platform_setTitle(title) {
	document.title = title
}
function Platform_getLocalStorageObject(key) {
	let str = localStorage.getItem(key)
	return str ? JSON.parse(str) : null 
}
function Platform_setInterval(interval, code) {
	setInterval(code, interval)
}
function Platform_initPlatform() {
	statistics_init();
	Platform_init();
	graphics_init();
	math_init();
	core_init();
	input_init();
	gizmo_init();
	Loca_init();
	core_log("Loading...")
	Platform_isMobile = false;
	Platform_isBrowser = !window.require;
	let platform = navigator.platform
	Platform_os = platform.startsWith("Win") ? 0 : platform.startsWith("Mac") ? 1 : 2
	if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
		|| /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
		Platform_isMobile = true;
	}
	if(!Platform_isMobile) 
		window.onresize = e => { 
			graphics_onResize();
			if(Platform_mode < 3/*Pause,Manipulator,Slide*/ && Platform_engineStarted) core_tick(/*draw*/true);
		}
	if(window.app_init) app_init();
}
async function Platform_start(isDebug, userCount, simulateConnection, showSafeArea) {
	audio_init();
	if(window.Image_init) Image_init();
	if(window.Font_init) Font_init();
	if(window.Sound_init) Sound_init();;
	Platform_initPlatform();
	statistics_startTime = performance.now();
	Platform_engineStarted = false;
	Platform_isDebug = isDebug;
	Platform_userCount = userCount;
	core_simulateConnection = simulateConnection;
	Platform_showSafeArea = showSafeArea;
	Platform_showDebugInfo = Platform_getLocalStorageObject("showDebugInfo") == "true";
	await graphics_setup();
	graphics_onResize();
	if(Platform_mode >= 3/*Play*/) {
		Platform_mode = 0/*Pause*/;
	}
	let path = location.href.getUntil("?", 0).split("/");
	let gameId = path.get(3);
	let roomId = path.get(4);
	let userId = -1;
	if(roomId) {
		let dashIndex = roomId.indexOf("u");
		if(dashIndex != -1) {
			userId = parseInt(roomId.substring(dashIndex + 1));
			roomId = roomId.substring(0, dashIndex);
		}
	}
	Platform_isStaging = isDebug || roomId == "staging" || roomId == "latest" || roomId?.startsWith("-");
	Platform_openMedia(() => {
		Platform_engineStarted = true;
		statistics_loadTime = performance.now();
		Platform_startInterval();
		if(isDebug || Platform_isLocal || roomId == "local" || location.href.startsWith("file")) {
			core_startLocal();
		} else {
			core_join(gameId, roomId, userId);
		}
		if(Platform_isDebug) _sendToEditor({type:"evaluateFinished"});
		if(!isDebug) {
			Platform_record();
		}
	});
}
function Platform_replay() {
	audio_init();
	if(window.Image_init) Image_init();
	if(window.Font_init) Font_init();
	if(window.Sound_init) Sound_init();;
	Platform_openMedia(() => {
		core_goToFrame(core_frame - 1, true);
	});
}
function Platform_startInterval() {
	if(Platform_interval) clearInterval(Platform_interval)
	if(window.tick) return
		
	if(Platform_intervalMode == 0) {
		Platform_interval = setInterval(() => Platform_tick(), 1000/core_targetFps)
	} else {
		window.tick = function() {
			Platform_tick();
			window.requestAnimationFrame(window.tick);
		}
		window.tick();
	}
}
function Platform_tick() {
	if(Platform_mode == 3/*Play*/ || Platform_mode == 4/*Record*/ || Platform_waitingForInitialData) {
		core_animationFrame();
	}
}
function Platform_enterSlideMode(mode) {
	Platform_mode = mode;
	Platform_sendMode();
}
function Platform_stop() {
	Platform_mode = 0/*Pause*/;
	gizmo_clear();
	core_stop();
	Platform_sendMode();
}
function Platform_pause() {
	Platform_mode = 0/*Pause*/;
	gizmo_clear();
	audio_stop();
	core_tick(true);
	Platform_sendMode();
}
function Platform_record() {
	core_adjustStartTimeIfNeeded();
	Platform_mode = 4/*Record*/;
	core_record();
	gizmo_clear();
	Platform_sendMode();
}
function Platform_play() {
	core_adjustStartTimeIfNeeded();
	Platform_mode = 3/*Play*/;
	gizmo_clear();
	Platform_sendMode();
}
function Platform_goToFrame(targetFrame) {
	Platform_pause();
	core_goToFrame(targetFrame, false);
}
function Platform_sendSelectToEditor(cursorFile, cursorPos) {
	_sendToEditor({type:"select", cursorFile, cursorPos})
}
function Platform_sendDeselectToEditor() {
	_sendToEditor({type:"deselect"})
}
function Platform_sendStartManipulationToEditor(influences) {
	_sendToEditor({type:"startManipulation", influences})
}
function Platform_sendMoveManipulationToEditor(influences, codeId) {
	_sendToEditor({type:"moveManipulation", influences, codeId})
}
function Platform_sendFrame(frame, frames) {
	_sendToEditor({type:"frame", frame, frames})
}
function Platform_sendWatch(frame, text, location, file) {
	_sendToEditor({type:"watch", frame, text, location, file})
}
function Platform_sendClearTimeline() {
	_sendToEditor({type:"clearTimeline"})
}
function Platform_sendMode() {
	if(Platform_isDebug) _sendToEditor({type:"setPlatformMode", mode:Platform_mode, frame:core_frame})
}
function Platform_toggleDebugInfo() {
	Platform_showDebugInfo = !Platform_showDebugInfo;
	localStorage.setItem("showDebugInfo", JSON.stringify((Platform_showDebugInfo ? "true" : "false")));
	graphics_updateBaseMatrix();
}
function Platform_toggleSmallScreen() {
	Platform_isSmallScreen = !Platform_isSmallScreen;
	System_print("isSmallScreen: "+Platform_isSmallScreen, null);
	localStorage.setItem("smallScreen", JSON.stringify((Platform_isSmallScreen ? "true" : "false")));
}
function Platform_generateObjectId() {
	var result = (Date.now() / 1000 | 0).toString(16)
	for(let i=0; i<16; i++)
		result += (Math.random() * 16 | 0).toString(16)
	return result.toLowerCase()
}
function Platform_stack() {
	try { _ }
	catch(e) { return e.stack }
}
function Lambda0() {
	this._id = 0;
}
Lambda0.prototype.invoke = function(value) {
	return value;
}
Lambda0.prototype.serialize_internal = function(buffer) {
}
Lambda0.prototype.deserialize_internal = function(buffer) {
}
Lambda0.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda0.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda0() {
	this._id = 0;
};
_Lambda0.prototype = Lambda0.prototype;
function Lambda1() {
	this._id = 1;
}
Lambda1.prototype.invoke = function(value) {
	return value * value;
}
Lambda1.prototype.serialize_internal = function(buffer) {
}
Lambda1.prototype.deserialize_internal = function(buffer) {
}
Lambda1.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda1.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda1() {
	this._id = 1;
};
_Lambda1.prototype = Lambda1.prototype;
function Lambda2() {
	this._id = 2;
}
Lambda2.prototype.invoke = function(value) {
	return 1 + 2.70158 * Math.pow(value - 1, 3) + 1.70158 * Math.pow(value - 1, 2);
}
Lambda2.prototype.serialize_internal = function(buffer) {
}
Lambda2.prototype.deserialize_internal = function(buffer) {
}
Lambda2.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda2.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda2() {
	this._id = 2;
};
_Lambda2.prototype = Lambda2.prototype;
var EaseFunction_None;
var EaseFunction_InQuad;
var EaseFunction_OutBack;
function EaseFunction_init() {
	EaseFunction_None = new EaseFunction(new Lambda0());
	EaseFunction_InQuad = new EaseFunction(new Lambda1());
	EaseFunction_OutBack = new EaseFunction(new Lambda2());
}
function EaseFunction($function) {
	this.function = $function;
}
EaseFunction.prototype.clone = function() {
	let clone = new _EaseFunction();
	clone.function = this.function;
	return clone;
}
function _EaseFunction() {};
_EaseFunction.prototype = EaseFunction.prototype;
function EaseFunction_serialize_internal(buffer) {
	if(EaseFunction_None) {
		var index = _objectCacheIndex.get(EaseFunction_None);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_None, index = _objectCache.length);
			_objectCache.push(EaseFunction_None);
			buffer.writeInt32(-index);
			EaseFunction_None._objectIndex = index;
			EaseFunction_None.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(EaseFunction_InQuad) {
		var index = _objectCacheIndex.get(EaseFunction_InQuad);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_InQuad, index = _objectCache.length);
			_objectCache.push(EaseFunction_InQuad);
			buffer.writeInt32(-index);
			EaseFunction_InQuad._objectIndex = index;
			EaseFunction_InQuad.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(EaseFunction_OutBack) {
		var index = _objectCacheIndex.get(EaseFunction_OutBack);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_OutBack, index = _objectCache.length);
			_objectCache.push(EaseFunction_OutBack);
			buffer.writeInt32(-index);
			EaseFunction_OutBack._objectIndex = index;
			EaseFunction_OutBack.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
function EaseFunction_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		EaseFunction_None = _objectCache[index];
	} else {
		if(!EaseFunction_None || EaseFunction_None._objectIndex != -index)
			EaseFunction_None = new _EaseFunction();
		(_objectCache[-index] = EaseFunction_None).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		EaseFunction_InQuad = _objectCache[index];
	} else {
		if(!EaseFunction_InQuad || EaseFunction_InQuad._objectIndex != -index)
			EaseFunction_InQuad = new _EaseFunction();
		(_objectCache[-index] = EaseFunction_InQuad).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		EaseFunction_OutBack = _objectCache[index];
	} else {
		if(!EaseFunction_OutBack || EaseFunction_OutBack._objectIndex != -index)
			EaseFunction_OutBack = new _EaseFunction();
		(_objectCache[-index] = EaseFunction_OutBack).deserialize_internal(buffer);
	}
}
EaseFunction.prototype.serialize_internal = function(buffer) {
	let $function = this.function
	if($function) {
		var index = _objectCacheIndex.get($function);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($function, index = _objectCache.length);
			_objectCache.push($function);
			buffer.writeInt32(-index);
			buffer.writeInt32($function._id);
			$function._objectIndex = index;
			$function.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
EaseFunction.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.function = _objectCache[index];
	} else {
		let $function = this.function
		let _id = buffer.readInt32();
		if(!$function || $function._id != _id || $function._objectIndex != -index)
			this.function = $function = new _lambdaContructors[_id]();
		$function._id = _id;
		(_objectCache[-index] = $function).deserialize_internal(buffer);
	}
}
function EaseFunction_serialize_external(buffer) {
	buffer.writeString("None");
	let EaseFunction_None_startPos = buffer.reserveSize();
	if(EaseFunction_None) {
		var index = _objectCacheIndex.get(EaseFunction_None);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_None, index = _objectCache.length);
			_objectCache.push(EaseFunction_None);
			buffer.writeInt32(-index);
			EaseFunction_None._objectIndex = index;
			EaseFunction_None.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(EaseFunction_None_startPos);
	buffer.writeString("InQuad");
	let EaseFunction_InQuad_startPos = buffer.reserveSize();
	if(EaseFunction_InQuad) {
		var index = _objectCacheIndex.get(EaseFunction_InQuad);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_InQuad, index = _objectCache.length);
			_objectCache.push(EaseFunction_InQuad);
			buffer.writeInt32(-index);
			EaseFunction_InQuad._objectIndex = index;
			EaseFunction_InQuad.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(EaseFunction_InQuad_startPos);
	buffer.writeString("OutBack");
	let EaseFunction_OutBack_startPos = buffer.reserveSize();
	if(EaseFunction_OutBack) {
		var index = _objectCacheIndex.get(EaseFunction_OutBack);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(EaseFunction_OutBack, index = _objectCache.length);
			_objectCache.push(EaseFunction_OutBack);
			buffer.writeInt32(-index);
			EaseFunction_OutBack._objectIndex = index;
			EaseFunction_OutBack.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(EaseFunction_OutBack_startPos);
	buffer.writeString("");
}
function EaseFunction_deserialize_external(buffer) {
	let None_is_set = false, InQuad_is_set = false, OutBack_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "None":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					EaseFunction_None = _objectCache[index];
				} else {
					if(!EaseFunction_None || EaseFunction_None._objectIndex != -index)
						EaseFunction_None = new _EaseFunction();
					(_objectCache[-index] = EaseFunction_None).deserialize_external(buffer);
				}
				None_is_set = true;
				break;
			case "InQuad":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					EaseFunction_InQuad = _objectCache[index];
				} else {
					if(!EaseFunction_InQuad || EaseFunction_InQuad._objectIndex != -index)
						EaseFunction_InQuad = new _EaseFunction();
					(_objectCache[-index] = EaseFunction_InQuad).deserialize_external(buffer);
				}
				InQuad_is_set = true;
				break;
			case "OutBack":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					EaseFunction_OutBack = _objectCache[index];
				} else {
					if(!EaseFunction_OutBack || EaseFunction_OutBack._objectIndex != -index)
						EaseFunction_OutBack = new _EaseFunction();
					(_objectCache[-index] = EaseFunction_OutBack).deserialize_external(buffer);
				}
				OutBack_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!None_is_set) EaseFunction_None = new EaseFunction(new Lambda0());
				if(!InQuad_is_set) EaseFunction_InQuad = new EaseFunction(new Lambda1());
				if(!OutBack_is_set) EaseFunction_OutBack = new EaseFunction(new Lambda2());
				return;
		}
	}
}
EaseFunction.prototype.serialize_external = function(buffer) {
	buffer.writeString("function");
	let $function_startPos = buffer.reserveSize();
	let $function = this.function
	if($function) {
		var index = _objectCacheIndex.get($function);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($function, index = _objectCache.length);
			_objectCache.push($function);
			buffer.writeInt32(-index);
			buffer.writeInt32($function._id);
			$function._objectIndex = index;
			$function.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($function_startPos);
	buffer.writeString("");
}
EaseFunction.prototype.deserialize_external = function(buffer) {
	let function_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "function":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.function = _objectCache[index];
				} else {
					let $function = this.function
					let _id = buffer.readInt32();
					if(!$function || $function._id != _id || $function._objectIndex != -index)
						this.function = $function = new _lambdaContructors[_id]();
					$function._id = _id;
					(_objectCache[-index] = $function).deserialize_external(buffer);
				}
				function_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!function_is_set) this.function = null;
				return;
		}
	}
}
function System_print(text, location) {
	(location ? log(text, location.start, location.file) : log(text))
}
function System_log(value) {
	console.log(value)
}
function System_watch(text, location) {
	if(Platform_isDebug && core_frame >= core_frameWithNewWatches && location) {
		Platform_sendWatch(core_frame, text, location.start, location.file)
	}
}
var math_PI;
var math_TwoPI;
var math_randomSeed;
var math_randomValueIndex;
var math_randomValues;
function math_sin(angle) {
	let result = angle-.5-Math.floor(angle);
	result *= 16 * (Math.abs(result) - .5);
	result += .225 * result * (Math.abs(result) - 1);
	return result;
}
function math_cos(angle) {
	let result = angle-.25-Math.floor(angle+.25);
	result *= 16 * (Math.abs(result) - .5);
	result += .225 * result * (Math.abs(result) - 1);
	return result;
}
function math_tan(angle) {
	return math_sin(angle) / math_cos(angle);
}
function math_atan2(y, x) {
	let r = 0.0, angle = 0.0;
	let abs_y = Math.abs(y) + .00000000001;
	if(x < 0.0) {
		r = (x + abs_y) / (abs_y - x);
		angle = .375;
	} else {
		r = (x - abs_y) / (x + abs_y);
		angle = .125;
	}
	angle += (.03124211533 * r * r - .1562424076) * r;
	if(y < 0.0) {
		return (-angle);
	} else {
		return angle;
	}
}
function math_moveTowards(value, targetValue, speed) {
	if(targetValue > value) {
		return Math.min(value + speed, targetValue);
	} else {
		if(targetValue < value) {
			return Math.max(value - speed, targetValue);
		}
	}
}
function math_moveTowards2(value, targetValue, speed) {
	if(targetValue>value) {
		return Math.min(value+speed, targetValue);
	} else {
		if(targetValue<value) {
			return Math.max(value-speed, targetValue);
		}
	}
}
function math_limit(value, min, max) {
	if(value < min) {
		return min;
	}
	if(value > max) {
		return max;
	}
	return value;
}
function math_limit2(value, max) {
	if(value > max) {
		return max;
	}
	return value;
}
function math_limit3(value, min) {
	if(value < min) {
		return min;
	}
	return value;
}
function math_limit4(value, min, max) {
	if(value < min) {
		return min;
	}
	if(value > max) {
		return max;
	}
	return value;
}
function math_limit5(value, max) {
	if(value > max) {
		return max;
	}
	return value;
}
function math_limit6(value, min) {
	if(value < min) {
		return min;
	}
	return value;
}
function math_map(value, from, to, start, target) {
	if(value <= from) {
		return start;
	}
	if(value >= to) {
		return target;
	}
	let factor = (value - from) / (to - from);
	return Vector2_plus_Vector2(start, Vector2_multiply_float((Vector2_minus_Vector2(target, start)), factor));
}
function math_map2(value, from, to, start, target, ease) {
	if(value <= from) {
		return start;
	}
	if(value >= to) {
		return target;
	}
	let factor = (value - from) / (to - from);
	return Vector2_plus_Vector2(start, Vector2_multiply_float((Vector2_minus_Vector2(target, start)), ease.function.invoke(factor)));
}
function math_map3(value, from, to, start, target) {
	if(value<=from) {
		return start;
	}
	if(value>=to) {
		return target;
	}
	let factor = (value-from)/(to-from);
	return start + (target - start) * factor;
}
function math_map4(value, from, to, start, target) {
	if(value <= from) {
		return start;
	}
	if(value >= to) {
		return target;
	}
	let factor = (value - from) / (to - from);
	return start + (target - start) * factor;
}
function math_map5(value, from, to, start, target, ease) {
	if(value <= from) {
		return start;
	}
	if(value >= to) {
		return target;
	}
	let factor = ease.function.invoke((value - from) / (to - from));
	return start + (target - start) * factor;
}
function math_getAngleForVector(vector) {
	return math_atan2(vector.y, vector.x);
}
function math_getVectorForAngle(angle, radius) {
	return new Vector2(math_cos(angle) * radius, math_sin(angle) * radius, null);
}
function math_intersectLines(startA, endA, startB, endB, typeA, typeB) {
	let x1 = startA.x, y1 = startA.y;
	let x2 = endA.x, y2 = endA.y;
	let x3 = startB.x, y3 = startB.y;
	let x4 = endB.x, y4 = endB.y;
	if((x1 == x2 && y1 == y2) || (x3 == x4 && y3 == y4)) {
		return Vector2_none;
	}
	let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if((denominator == 0)) {
		return Vector2_none;
	}
	let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
	if((typeA >= 1/*Ray*/ && ua < 0) || (typeA == 2/*Segment*/ && ua > 1) || (typeB >= 1/*Ray*/ && ub < 0) || (typeB == 2/*Segment*/ && ub > 1)) {
		return Vector2_none;
	}
	return new Vector2(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1), null);
}
function math_init() {
	math_PI = 3.141592653589793;
	math_TwoPI = 6.283185307179586;
	math_randomSeed = "";
	math_randomValueIndex = 0;
	math_randomValues = [];
	math_initDefaultRandomGenerator();
}
function math_initDefaultRandomGenerator() {
	math_randomGenerator = Math.random
}
function math_generateRandomSeed() {
	let crypto = !window.crypto && typeof(require) != "undefined" ? require("crypto") : window.crypto
	if(crypto) {
		let out = new Uint8Array(256);
		crypto.getRandomValues(out);
		return out.toString();
	}
}
function math_recreateRandomValues() {
	let targetRandomValueIndex = math_randomValueIndex;
	math_setRandomSeed(math_randomSeed);
	for(let i=0; i<targetRandomValueIndex; ++i) {
		math_randomFloat2(1.0);
	}
}
function math_setRandomSeed(seed) {
	math_randomSeed = seed
	math_randomValues.length = 0
	math_randomValueIndex = 0
	
	
	
	function xmur3(str) {
		for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {
			h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
			h = h << 13 | h >>> 19;
		} return function() {
			h = Math.imul(h ^ (h >>> 16), 2246822507);
			h = Math.imul(h ^ (h >>> 13), 3266489909);
			return (h ^= h >>> 16) >>> 0;
		}
	}
	
	function sfc32(a, b, c, d) {
		return function() {
			a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
			var t = (a + b) | 0;
			a = b ^ b >>> 9;
			b = c + (c << 3) | 0;
			c = (c << 21 | c >>> 11);
			d = d + 1 | 0;
			t = t + d | 0;
			c = c + t | 0;
			return (t >>> 0) / 4294967296;
		}
	}
	
	function mulberry32(a) {
		return function() {
			var t = a += 0x6D2B79F5;
			t = Math.imul(t ^ t >>> 15, t | 1);
			t ^= t + Math.imul(t ^ t >>> 7, t | 61);
			return ((t ^ t >>> 14) >>> 0) / 4294967296;
		}
	}
	
	var seed = xmur3(seed);
	var rand = sfc32(seed(), seed(), seed(), seed());
	var rand = mulberry32(seed());
	
	math_randomGenerator = function() {
		let value
		if(math_randomValueIndex < math_randomValues.length) {
			value = math_randomValues[math_randomValueIndex]
			math_randomValueIndex++
		} else {
			value = rand()
			math_randomValues[math_randomValueIndex++] = value;
		}
		return value
	}
}
function math_randomInteger(from, to) {
	return from + Math.floor(math_randomGenerator() * (to-from))
}
function math_randomInteger2(to) {
	return Math.floor(math_randomGenerator() * to)
}
function math_randomFloat(from, to) {
	return from + math_randomGenerator() * (to-from)
}
function math_randomFloat2(to) {
	return math_randomGenerator() * to
}
function math_serialize_internal(buffer) {
	buffer.writeFloat64(math_PI);
	buffer.writeFloat64(math_TwoPI);
	buffer.writeInt32(math_randomValueIndex);
}
function math_deserialize_internal(buffer) {
	math_PI = buffer.readFloat64();
	math_TwoPI = buffer.readFloat64();
	math_randomValueIndex = buffer.readInt32();
}
function math_serialize_external(buffer) {
	buffer.writeString("PI");
	buffer.writeInt32(8);
	buffer.writeFloat64(math_PI);
	buffer.writeString("TwoPI");
	buffer.writeInt32(8);
	buffer.writeFloat64(math_TwoPI);
	buffer.writeString("randomValueIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(math_randomValueIndex);
	buffer.writeString("");
}
function math_deserialize_external(buffer) {
	let PI_is_set = false, TwoPI_is_set = false, randomValueIndex_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "PI":
				buffer.readInt32();
				math_PI = buffer.readFloat64();
				PI_is_set = true;
				break;
			case "TwoPI":
				buffer.readInt32();
				math_TwoPI = buffer.readFloat64();
				TwoPI_is_set = true;
				break;
			case "randomValueIndex":
				buffer.readInt32();
				math_randomValueIndex = buffer.readInt32();
				randomValueIndex_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!PI_is_set) math_PI = 3.141592653589793;
				if(!TwoPI_is_set) math_TwoPI = 6.283185307179586;
				if(!randomValueIndex_is_set) math_randomValueIndex = 0;
				return;
		}
	}
}
function Average(total, count) {
	this.total = total;
	this.count = count;
}
Average.prototype.add = function(value) {
	this.total += value;
	this.count++;
}
Average.prototype.average = function() {
	return this.total / this.count;
}
Average.prototype.clone = function() {
	let clone = new _Average();
	clone.total = this.total;
	clone.count = this.count;
	return clone;
}
function _Average() {};
_Average.prototype = Average.prototype;
Average.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.total);
	buffer.writeInt32(this.count);
}
Average.prototype.deserialize_internal = function(buffer) {
	this.total = buffer.readFloat64();
	this.count = buffer.readInt32();
}
Average.prototype.serialize_external = function(buffer) {
	buffer.writeString("total");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.total);
	buffer.writeString("count");
	buffer.writeInt32(4);
	buffer.writeInt32(this.count);
	buffer.writeString("");
}
Average.prototype.deserialize_external = function(buffer) {
	let total_is_set = false, count_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "total":
				buffer.readInt32();
				this.total = buffer.readFloat64();
				total_is_set = true;
				break;
			case "count":
				buffer.readInt32();
				this.count = buffer.readInt32();
				count_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!total_is_set) this.total = 0.0;
				if(!count_is_set) this.count = 0;
				return;
		}
	}
}
function Range(from, to) {
	this.from = from;
	this.to = to;
}
Range.prototype.clone = function() {
	let clone = new _Range();
	clone.from = this.from;
	clone.to = this.to;
	return clone;
}
function _Range() {};
_Range.prototype = Range.prototype;
Range.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.from);
	buffer.writeInt32(this.to);
}
Range.prototype.deserialize_internal = function(buffer) {
	this.from = buffer.readInt32();
	this.to = buffer.readInt32();
}
Range.prototype.serialize_external = function(buffer) {
	buffer.writeString("from");
	buffer.writeInt32(4);
	buffer.writeInt32(this.from);
	buffer.writeString("to");
	buffer.writeInt32(4);
	buffer.writeInt32(this.to);
	buffer.writeString("");
}
Range.prototype.deserialize_external = function(buffer) {
	let from_is_set = false, to_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "from":
				buffer.readInt32();
				this.from = buffer.readInt32();
				from_is_set = true;
				break;
			case "to":
				buffer.readInt32();
				this.to = buffer.readInt32();
				to_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!from_is_set) this.from = 0;
				if(!to_is_set) this.to = 0;
				return;
		}
	}
}
var Loca_supportedLanguages;
var Loca_defaultLocaleForLanguage;
var Loca_language;
var Loca_locale;
function Loca_init() {
	Loca_supportedLanguages = [0/*English*/, 1/*German*/];
	Loca_defaultLocaleForLanguage = ["en-001", "de-DE", "es-ES", "fr-FR", "it-IT", "pt-PT", "ja-JP", "zh-Hans-CN", "ko-KR", "nl-NL", "tr-TR", "pl-PL", "ru-RU", "hi-IN", "ar-001", "bn-BD", "ur-IN", "id-ID"];
	Loca_language = 0/*English*/;
	Loca_locale = Loca_defaultLocaleForLanguage.get(Loca_language);
	Loca_setLanguage(0/*English*/, null);
}
function Loca_setLanguage(language, locale) {
	Loca_language = language
	Loca_locale = locale || Loca_defaultLocaleForLanguage[language]
}
function Loca_format(id) {
	let entry = _strings[Loca_language][id]
	if(!entry || entry.s.length == 0) return "##########"
	let strings = entry.s
	let result = strings[0]
	let stringIndex = 1
	for(let placeholderNumber of entry.p) {
		if(placeholderNumber >= 0) {
			
			
			
			let placeholderValue = arguments[placeholderNumber+1]
			result += placeholderValue
			if(stringIndex < strings.length) {
				let str = strings[stringIndex++]
				if(str) result += str
			}
		} else {
			
			
			
			
			let placeholderValue = arguments[-placeholderNumber]
			result += placeholderValue
			let str = strings[placeholderValue == 1 ? stringIndex : stringIndex+1]
			if(str) result += str
			stringIndex += 2
		}
	}
	return result
}
function Loca_serialize_internal(buffer) {
	if(Loca_supportedLanguages) {
		var index = _objectCacheIndex.get(Loca_supportedLanguages);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Loca_supportedLanguages, index = _objectCache.length);
			_objectCache.push(Loca_supportedLanguages);
			buffer.writeInt32(-index);
			Loca_supportedLanguages._objectIndex = index;
			buffer.writeInt32(Loca_supportedLanguages.length);
			for(let i=0, len=Loca_supportedLanguages.length; i<len; ++i) {
				buffer.writeInt32(Loca_supportedLanguages[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Loca_defaultLocaleForLanguage) {
		var index = _objectCacheIndex.get(Loca_defaultLocaleForLanguage);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Loca_defaultLocaleForLanguage, index = _objectCache.length);
			_objectCache.push(Loca_defaultLocaleForLanguage);
			buffer.writeInt32(-index);
			Loca_defaultLocaleForLanguage._objectIndex = index;
			buffer.writeInt32(Loca_defaultLocaleForLanguage.length);
			for(let i=0, len=Loca_defaultLocaleForLanguage.length; i<len; ++i) {
				buffer.writeString(Loca_defaultLocaleForLanguage[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(Loca_language);
	buffer.writeString(Loca_locale);
}
function Loca_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Loca_supportedLanguages = _objectCache[index];
	} else {
		if(!Loca_supportedLanguages || Loca_supportedLanguages._objectIndex != -index) Loca_supportedLanguages = [];
		_objectCache[-index] = Loca_supportedLanguages;
		for(let i=0, len = Loca_supportedLanguages.length = buffer.readInt32(); i<len; ++i) {
				Loca_supportedLanguages[i] = buffer.readInt32();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Loca_defaultLocaleForLanguage = _objectCache[index];
	} else {
		if(!Loca_defaultLocaleForLanguage || Loca_defaultLocaleForLanguage._objectIndex != -index) Loca_defaultLocaleForLanguage = [];
		_objectCache[-index] = Loca_defaultLocaleForLanguage;
		for(let i=0, len = Loca_defaultLocaleForLanguage.length = buffer.readInt32(); i<len; ++i) {
				Loca_defaultLocaleForLanguage[i] = buffer.readString();
		}
	}
	Loca_language = buffer.readInt32();
	Loca_locale = buffer.readString();
}
function Loca_serialize_external(buffer) {
	buffer.writeString("supportedLanguages");
	let Loca_supportedLanguages_startPos = buffer.reserveSize();
	if(Loca_supportedLanguages) {
		var index = _objectCacheIndex.get(Loca_supportedLanguages);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Loca_supportedLanguages, index = _objectCache.length);
			_objectCache.push(Loca_supportedLanguages);
			buffer.writeInt32(-index);
			Loca_supportedLanguages._objectIndex = index;
			buffer.writeInt32(Loca_supportedLanguages.length);
			for(let i=0, len=Loca_supportedLanguages.length; i<len; ++i) {
				buffer.writeInt32(Loca_supportedLanguages[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Loca_supportedLanguages_startPos);
	buffer.writeString("defaultLocaleForLanguage");
	let Loca_defaultLocaleForLanguage_startPos = buffer.reserveSize();
	if(Loca_defaultLocaleForLanguage) {
		var index = _objectCacheIndex.get(Loca_defaultLocaleForLanguage);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Loca_defaultLocaleForLanguage, index = _objectCache.length);
			_objectCache.push(Loca_defaultLocaleForLanguage);
			buffer.writeInt32(-index);
			Loca_defaultLocaleForLanguage._objectIndex = index;
			buffer.writeInt32(Loca_defaultLocaleForLanguage.length);
			for(let i=0, len=Loca_defaultLocaleForLanguage.length; i<len; ++i) {
				buffer.writeString(Loca_defaultLocaleForLanguage[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Loca_defaultLocaleForLanguage_startPos);
	buffer.writeString("language");
	buffer.writeInt32(4);
	buffer.writeInt32(Loca_language);
	buffer.writeString("locale");
	buffer.writeString(Loca_locale);
	buffer.writeString("");
}
function Loca_deserialize_external(buffer) {
	let supportedLanguages_is_set = false, defaultLocaleForLanguage_is_set = false, language_is_set = false, locale_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "supportedLanguages":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Loca_supportedLanguages = _objectCache[index];
				} else {
					if(!Loca_supportedLanguages || Loca_supportedLanguages._objectIndex != -index) Loca_supportedLanguages = [];
					_objectCache[-index] = Loca_supportedLanguages;
					for(let i=0, len = Loca_supportedLanguages.length = buffer.readInt32(); i<len; ++i) {
							Loca_supportedLanguages[i] = buffer.readInt32();
					}
				}
				supportedLanguages_is_set = true;
				break;
			case "defaultLocaleForLanguage":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Loca_defaultLocaleForLanguage = _objectCache[index];
				} else {
					if(!Loca_defaultLocaleForLanguage || Loca_defaultLocaleForLanguage._objectIndex != -index) Loca_defaultLocaleForLanguage = [];
					_objectCache[-index] = Loca_defaultLocaleForLanguage;
					for(let i=0, len = Loca_defaultLocaleForLanguage.length = buffer.readInt32(); i<len; ++i) {
							Loca_defaultLocaleForLanguage[i] = buffer.readString();
					}
				}
				defaultLocaleForLanguage_is_set = true;
				break;
			case "language":
				buffer.readInt32();
				Loca_language = buffer.readInt32();
				language_is_set = true;
				break;
			case "locale":
				Loca_locale = buffer.readString();
				locale_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!supportedLanguages_is_set) Loca_supportedLanguages = [0/*English*/, 1/*German*/];
				if(!defaultLocaleForLanguage_is_set) Loca_defaultLocaleForLanguage = ["en-001", "de-DE", "es-ES", "fr-FR", "it-IT", "pt-PT", "ja-JP", "zh-Hans-CN", "ko-KR", "nl-NL", "tr-TR", "pl-PL", "ru-RU", "hi-IN", "ar-001", "bn-BD", "ur-IN", "id-ID"];
				if(!language_is_set) Loca_language = 0/*English*/;
				if(!locale_is_set) Loca_locale = Loca_defaultLocaleForLanguage.get(Loca_language);
				return;
		}
	}
}
var Buffer_textEncoder;
var Buffer_textDecoder;
function Buffer(buffer, size, readPos, writePos) {
	this.readPos = readPos;
	this.writePos = writePos;
	this.buffer = buffer;
	this.dataView = null;
	this.setup(size);
}
Buffer.prototype.writeInt = function(value) {
	if(value <= -2147483647 || value >= 2147483647)
		throw new Error("Value out of integer range: "+value)
	let n, lastByte
	if(value > 0) {
		n = value
		lastByte = n & 0x3f
	} else {
		n = -value
		lastByte = (n & 0x3f) | 0x40
	}
	if (n < (1 << 13)) {
		if (n < (1 << 6)) {
			if(this.writePos+1 > this.buffer.byteLength) this.expandBuffer(this.writePos+1)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, lastByte);
			return 1;
		} else {
			if(this.writePos+2 > this.buffer.byteLength) this.expandBuffer(this.writePos+2)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 6) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 2;
		}
	} else if (n < (1 << 27)) {
		if (n < (1 << 20)) {
			if(this.writePos+3 > this.buffer.byteLength) this.expandBuffer(this.writePos+3)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 13) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 3;
		} else {
			if(this.writePos+4 > this.buffer.byteLength) this.expandBuffer(this.writePos+4)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 20) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 13) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, lastByte);
			return 4;
		}
	} else {
		if(this.writePos+5 > this.buffer.byteLength) this.expandBuffer(this.writePos+5)
		let dataView = this.dataView
		dataView.setUint8(this.writePos++, (n >> 27) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 20) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 13) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 6) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, lastByte);
		return 5;
	}
}
Buffer.prototype.readInt = function() {
	let dataView = this.dataView
	let a = dataView.getUint8(this.readPos++);
	if((a & 0x80) == 0) {
		return a & 0x40 ? -(a & 0x3f) 
						: a;
	} else {
		a &= 0x7f;
		let b = dataView.getUint8(this.readPos++);
		if((b & 0x80) == 0) {
			return b & 0x40 ? -((b & 0x3f) | (a << 6)) 
							: (b | (a << 6));
		} else {
			b &= 0x7f;
			let c = dataView.getUint8(this.readPos++);
			if((c & 0x80) == 0) {
				return c & 0x40 ? -((c & 0x3f) | (b << 6) | (a << 13))
								: (c | (b << 6) | (a << 13));
			} else {
				c &= 0x7f;
				let d = dataView.getUint8(this.readPos++);
				if((d & 0x80) == 0) {
					return d & 0x40 ? -((d & 0x3f) | (c << 6) | (b << 13) | (a << 20))
									: (d | (c << 6) | (b << 13) | (a << 20));
				} else {
					d &= 0x7f;
					let e = dataView.getUint8(this.readPos++);
					return e & 0x40 ? -((e & 0x3f) | (d << 6) | (c << 13) | (b << 20) | (a << 27))
									: (e | (d << 6) | (c << 13) | (b << 20) | (a << 27));
				}
			}
		}
	}
}
Buffer.prototype.writeUnsignedInt = function(value) {
	if(value < 0 || value >= 2147483648)
		throw new Error("Value out of integer range: "+value)
		
	var n = value
	if (n < (1 << 14)) {
		if (n < (1 << 7)) {
			if(this.writePos+1 > this.buffer.byteLength) this.expandBuffer(this.writePos+1)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, n);
			return 1;
		} else {
			if(this.writePos+2 > this.buffer.byteLength) this.expandBuffer(this.writePos+2)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 7) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 2;
		}
	} else if (n < (1 << 28)) {
		if (n < (1 << 21)) {
			if(this.writePos+3 > this.buffer.byteLength) this.expandBuffer(this.writePos+3)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 14) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 3;
		} else {
			if(this.writePos+4 > this.buffer.byteLength) this.expandBuffer(this.writePos+4)
			let dataView = this.dataView
			dataView.setUint8(this.writePos++, (n >> 21) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 14) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
			dataView.setUint8(this.writePos++, n & 0x7f);
			return 4;
		}
	} else {
		if(this.writePos+5 > this.buffer.byteLength) this.expandBuffer(this.writePos+5)
		let dataView = this.dataView
		dataView.setUint8(this.writePos++, (n >> 28) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 21) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 14) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, ((n >> 7) & 0x7f) | 0x80);
		dataView.setUint8(this.writePos++, n & 0x7f);
		return 5;
	}
}
Buffer.prototype.readUnsignedInt = function() {
	let dataView = this.dataView
	let a = dataView.getUint8(this.readPos++);
	if((a & 0x80) == 0) {
		return a;
	} else {
		a &= 0x7f;
		let b = dataView.getUint8(this.readPos++);
		if((b & 0x80) == 0) {
			return b | (a << 7);
		} else {
			b &= 0x7f;
			let c = dataView.getUint8(this.readPos++);
			if((c & 0x80) == 0) {
				return c | (b << 7) | (a << 14);
			} else {
				c &= 0x7f;
				let d = dataView.getUint8(this.readPos++);
				if((d & 0x80) == 0) {
					return d | (c << 7) | (b << 14) | (a << 21);
				} else {
					d &= 0x7f;
					let e = dataView.getUint8(this.readPos++);
					return e | (d << 7) | (c << 14) | (b << 21) | (a << 28);
				}
			}
		}
	}
}
Buffer.prototype.writeString = function(value) {
	if(!value) {
		if(this.writePos+4 > this.buffer.byteLength)
			this.expandBuffer(this.writePos+4)
		this.dataView.setInt32(this.writePos, 0)
		this.writePos += 4
		return
	}
	let maxSize = value.length*3
	if(this.writePos+maxSize+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+maxSize+4)
		
	var array = new Uint8Array(this.buffer, this.writePos+4, maxSize)
	var result = Buffer_textEncoder.encodeInto(value, array)
	var size = result.written
	this.dataView.setInt32(this.writePos, size)
	this.writePos += size + 4
}
Buffer.prototype.readString = function() {
	let size = this.dataView.getInt32(this.readPos)
	this.readPos += 4
	var array = new Uint8Array(this.buffer, this.readPos, size)
	this.readPos += size
	return Buffer_textDecoder.decode(array)
}
Buffer.prototype.skip = function(count) {
	this.readPos += count;
}
Buffer.prototype.reserveSize = function() {
	this.writePos += 4
	return this.writePos
}
Buffer.prototype.writeSize = function(pos) {
	this.dataView.setInt32(pos-4, this.writePos-pos)
}
Buffer.prototype.writeInt8 = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setInt8(this.writePos, value)
	this.writePos += 1
}
Buffer.prototype.writeUnsignedInt8 = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setUint8(this.writePos, value)
	this.writePos += 1
}
Buffer.prototype.writeInt16 = function(value) {
	if(this.writePos+2 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+2)
	this.dataView.setInt16(this.writePos, value)
	this.writePos += 2
}
Buffer.prototype.writeUnsignedInt16 = function(value) {
	if(this.writePos+2 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+2)
	this.dataView.setUint16(this.writePos, value)
	this.writePos += 2
}
Buffer.prototype.writeInt32 = function(value) {
	if(this.writePos+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+4)
	this.dataView.setInt32(this.writePos, value)
	this.writePos += 4
}
Buffer.prototype.writeFloat32 = function(value) {
	if(this.writePos+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+4)
	this.dataView.setFloat32(this.writePos, value)
	this.writePos += 4
}
Buffer.prototype.writeFloat64 = function(value) {
	if(this.writePos+8 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+8)
	this.dataView.setFloat64(this.writePos, value)
	this.writePos += 8
}
Buffer.prototype.writeBool = function(value) {
	if(this.writePos+1 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+1)
	this.dataView.setInt8(this.writePos, value ? 1 : 0)
	this.writePos += 1
}
Buffer.prototype.writeBuffer = function(source) {
	this.writeBuffer2(source, 0, source.writePos);
}
Buffer.prototype.writeBuffer2 = function(source, start, length) {
	
	if(this.writePos+length+4 > this.buffer.byteLength)
		this.expandBuffer(this.writePos+length+4)
		
	
	this.writeInt(length)
	
	
	let readPos = start
	let writePos = this.writePos
	let readPosEnd = start + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.copyFromBuffer = function(source) {
	let readPos = 0
	let length = source.writePos
	let writePos = this.writePos
	
	
	if(writePos+length > this.buffer.byteLength)
		this.expandBuffer(writePos+length)
		
	
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.set = function(source) {
	let readPos = 0
	let length = source.writePos
	let writePos = 0
	
	
	if(writePos+length > this.buffer.byteLength)
		this.expandBuffer(writePos+length)
		
	
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		this.dataView.setUint8(writePos++, source.dataView.getUint8(readPos++))
		
	this.writePos = writePos
}
Buffer.prototype.readInt8 = function() {
	return this.dataView.getInt8(this.readPos++)
}
Buffer.prototype.readUnsignedInt8 = function() {
	return this.dataView.getUint8(this.readPos++)
}
Buffer.prototype.readInt16 = function() {
	let value = this.dataView.getInt16(this.readPos)
	this.readPos += 2
	return value
}
Buffer.prototype.readUnsignedInt16 = function() {
	let value = this.dataView.getUint16(this.readPos)
	this.readPos += 2
	return value
}
Buffer.prototype.readInt32 = function() {
	let value = this.dataView.getInt32(this.readPos)
	this.readPos += 4
	return value
}
Buffer.prototype.readFloat32 = function() {
	let value = this.dataView.getFloat32(this.readPos)
	this.readPos += 4
	return value
}
Buffer.prototype.readFloat64 = function() {
	let value = this.dataView.getFloat64(this.readPos)
	this.readPos += 8
	return value
}
Buffer.prototype.readBool = function() {
	return this.dataView.getInt8(this.readPos++) != 0
}
Buffer.prototype.readBuffer = function(writeBuffer, writeStart) {
	
	let length = this.readInt()
	
	
	if(writeStart+length > writeBuffer.buffer.byteLength)
		writeBuffer.expandBuffer(writeStart+length)
		
	
	let readPos = this.readPos
	let writePos = writeStart
	let readPosEnd = readPos + length
	while(readPos < readPosEnd)
		writeBuffer.dataView.setUint8(writePos++, this.dataView.getUint8(readPos++))
		
	this.readPos = readPos
	writeBuffer.writePos = writePos
	return length
}
Buffer.prototype.toString = function() {
	let result = "readPos:" + this.readPos + " writePos:" + this.writePos
	for(let i=0; i<this.writePos; i ++)
		result += " " + this.dataView.getUint8(i)
	return result
}
Buffer.prototype.toRangeString = function(start, end) {
	let result = ""
	for(let i=start; i<end; i++)
		result += " " + this.dataView.getUint8(i)
	return result
}
function Buffer_init() {
	Buffer_textEncoder = null;
	Buffer_textDecoder = null;
	Buffer_setupTextEncoder();
}
Buffer.prototype.setup = function(size) {
	if(!this.buffer) this.buffer = new ArrayBuffer(size)
	else this.writePos = this.buffer.byteLength
	this.dataView = new DataView(this.buffer)
}
function Buffer_setupTextEncoder() {
	Buffer_textEncoder = new TextEncoder
	Buffer_textDecoder = new TextDecoder
}
Buffer.prototype.canRead = function() {
	return this.readPos < this.writePos;
}
Buffer.prototype.toByteArray = function() {
	return new Uint8Array(this.buffer, 0, this.writePos)
}
Buffer.prototype.reset = function() {
	this.writePos = 0;
	this.readPos = 0;
}
Buffer.prototype.rewind = function() {
	this.readPos = 0;
}
Buffer.prototype.expandBuffer = function(size) {
	let prevLength = this.buffer.byteLength
	let len = Math.max(prevLength*2, size)
	this.buffer = new ArrayBuffer(len)
	let prevDataView = this.dataView
	let newDataView = new DataView(this.buffer)
	for(let i=0; i<prevLength; i++)
		newDataView.setInt8(i, prevDataView.getInt8(i))
			
	this.dataView = newDataView
}
function Buffer_equal_Buffer(a, b) {
	if(a.writePos != b.writePos) return false
	for(var i=0, len=a.writePos; i<len; i++)
		if(a.dataView.getUint8(i) != b.dataView.getUint8(i))
			return false
	return true
}
function Buffer_notEqual_Buffer(a, b) {
	if(a.writePos != b.writePos) return true
	for(var i=0, len=a.writePos; i<len; i++)
		if(a.dataView.getUint8(i) != b.dataView.getUint8(i))
			return true
	return false
}
Buffer.prototype.checksum = function() {
	let hash = 0;
	for (let i = 0; i < this.writePos; i++) {
		let value = this.dataView.getUint8(i);
		hash = (hash << 5) - hash + value;
		hash |= 0; 
	}
	return hash;
}
function Buffer_listToChecksum(list) {
	let hash = 0;
	for (let i = 0; i < list.length; i++) {
		let value = list[i];
		hash = (hash << 5) - hash + value;
		hash |= 0; 
	}
	return hash;
}
Buffer.prototype.toList = function() {
	let result = []
	for(let i=0; i<this.writePos; i++)
		result.push(this.dataView.getUint8(i))
	return result
}
Buffer.prototype.clone = function() {
	let clone = new _Buffer();
	clone.readPos = this.readPos;
	clone.writePos = this.writePos;
	clone.buffer = this.buffer;
	clone.dataView = this.dataView;
	return clone;
}
function _Buffer() {};
_Buffer.prototype = Buffer.prototype;
var fx_animations;
function fx_init() {
	fx_animations = [];
}
function fx_add(animation) {
	fx_animations.push(animation);
}
function fx_removeForObject(object) {
	fx_animations.removeWhere(a => a.object == object);
}
function fx_endOfPrevAnimation(object) {
	let lastAnimation = fx_animations.get(-1);
	if(lastAnimation?.object == object) {
		return Math.max(Time_now, lastAnimation.startTime+lastAnimation.duration);
	}
	return Time_now;
}
function fx_tick() {
	let now = Time_now;
	for(let _subject=fx_animations, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(now>=it.startTime) {
			let f = (it.duration ? (now-it.startTime)/it.duration : 1);
			if(f >= 1) {
				f = 1;
				fx_animations.splice(i, 1);
			}
			it.tick(f);
		}
	}}
}
function fx_delay(time, $do) {
	fx_add(new DelayAnimation(Time_now+time, 0.0, null, $do));
}
function fx_defer($do) {
	fx_add(new DelayAnimation(Time_now, 0.0, null, $do));
}
function fx_serialize_internal(buffer) {
	if(fx_animations) {
		var index = _objectCacheIndex.get(fx_animations);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(fx_animations, index = _objectCache.length);
			_objectCache.push(fx_animations);
			buffer.writeInt32(-index);
			fx_animations._objectIndex = index;
			buffer.writeInt32(fx_animations.length);
			for(let i=0, len=fx_animations.length; i<len; ++i) {
				let fx_animations_item = fx_animations[i]
				if(fx_animations_item) {
					var index = _objectCacheIndex.get(fx_animations_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(fx_animations_item, index = _objectCache.length);
						_objectCache.push(fx_animations_item);
						buffer.writeInt32(-index);
						buffer.writeString(fx_animations_item.type);
						fx_animations_item._objectIndex = index;
						fx_animations_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function fx_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		fx_animations = _objectCache[index];
	} else {
		if(!fx_animations || fx_animations._objectIndex != -index) fx_animations = [];
		_objectCache[-index] = fx_animations;
		for(let i=0, len = fx_animations.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					fx_animations[i] = _objectCache[index];
				} else {
					let fx_animations_item = fx_animations[i]
					let type = buffer.readString();
					if(!fx_animations_item || fx_animations_item._objectIndex != -index)
						fx_animations[i] = fx_animations_item = new_Animation_of_type(type);
					fx_animations_item.type = type;
					(_objectCache[-index] = fx_animations_item).deserialize_internal(buffer);
				}
		}
	}
}
function fx_serialize_external(buffer) {
	buffer.writeString("animations");
	let fx_animations_startPos = buffer.reserveSize();
	if(fx_animations) {
		var index = _objectCacheIndex.get(fx_animations);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(fx_animations, index = _objectCache.length);
			_objectCache.push(fx_animations);
			buffer.writeInt32(-index);
			fx_animations._objectIndex = index;
			buffer.writeInt32(fx_animations.length);
			for(let i=0, len=fx_animations.length; i<len; ++i) {
				let fx_animations_item = fx_animations[i]
				if(fx_animations_item) {
					var index = _objectCacheIndex.get(fx_animations_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(fx_animations_item, index = _objectCache.length);
						_objectCache.push(fx_animations_item);
						buffer.writeInt32(-index);
						buffer.writeString(fx_animations_item.type);
						fx_animations_item._objectIndex = index;
						fx_animations_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(fx_animations_startPos);
	buffer.writeString("");
}
function fx_deserialize_external(buffer) {
	let animations_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "animations":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					fx_animations = _objectCache[index];
				} else {
					if(!fx_animations || fx_animations._objectIndex != -index) fx_animations = [];
					_objectCache[-index] = fx_animations;
					for(let i=0, len = fx_animations.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								fx_animations[i] = _objectCache[index];
							} else {
								let fx_animations_item = fx_animations[i]
								let type = buffer.readString();
								if(!fx_animations_item || fx_animations_item._objectIndex != -index)
									fx_animations[i] = fx_animations_item = new_Animation_of_type(type);
								fx_animations_item.type = type;
								(_objectCache[-index] = fx_animations_item).deserialize_external(buffer);
							}
					}
				}
				animations_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!animations_is_set) fx_animations = [];
				return;
		}
	}
}
var audio_volumeLevels;
var audio_volumeLevel;
var audio_volume;
var audio_playingSounds;
var audio_sounds;
function audio_init() {
	audio_volumeLevels = [0, 0.0001, 0.0002, 0.0005, 0.001, 0.002, 0.005, .01, .02, .04, .08, .16, .32, .64, 1];
	audio_volumeLevel = 10;
	audio_volume = audio_volumeLevels.get(audio_volumeLevel);
	audio_playingSounds = [];
	audio_sounds = [];
}
function audio_playSound(sound, delay, needsToBeCertain) {
	if(needsToBeCertain && !input_isCertain) {
		return;
	}
	if(core_frame == 0) {
		fx_add(new PlaySoundAnimation(Math.ceil(Time_now+core_targetFrameTime)+delay, 0.0, null, sound));
	} else {
		if(delay) {
			fx_add(new PlaySoundAnimation(Time_now+delay, 0.0, null, sound));
		} else {
			sound.play(false);
		}
	}
}
function audio_startFrame() {
	for(let i=0, _subject=audio_playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.isConfirmed = false;
	}}
}
function audio_finishFrame() {
	for(let i=0, _subject=audio_playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it.frame == core_frame && !it.isConfirmed) {
			it.sound.stop();
		}
	}}
}
function audio_reload() {
	for(let i=0, _subject=audio_sounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.preloadForNextPlayback();
	}}
}
function audio_stop() {
	for(let i=0, _subject=audio_playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.sound.stop();
	}}
	audio_playingSounds.length = 0;
}
function audio_mute(forPlayer) {
	if(!(forPlayer != null) || forPlayer.id == input_localUser.id) {
		audio_volumeLevel = 0;
		audio_volume = audio_volumeLevels.get(audio_volumeLevel);
		for(let i=0, _subject=audio_playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.sound.updateVolume();
		}}
	}
}
function audio_adjustVolume(delta, forPlayer) {
	if(!(forPlayer != null) || forPlayer.id == input_localUser.id) {
		audio_volumeLevel = math_limit(audio_volumeLevel + delta, 0, audio_volumeLevels.length - 1);
		audio_volume = audio_volumeLevels.get(audio_volumeLevel);
		for(let i=0, _subject=audio_playingSounds, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.sound.updateVolume();
		}}
	}
}
function Animation(startTime, duration, object) {
	this.type = "Animation";
	this.startTime = startTime;
	this.duration = duration;
	this.object = object;
}
function new_Animation_of_type(type) {
	switch(type) {
		case "Animation": return new _Animation();
		case "FadeAnimation": return new _FadeAnimation();
		case "MoveAnimation": return new _MoveAnimation();
		case "ScaleAnimation": return new _ScaleAnimation();
		case "FadeSoundAnimation": return new _FadeSoundAnimation();
		case "PlaySoundAnimation": return new _PlaySoundAnimation();
		case "DelayAnimation": return new _DelayAnimation();
	}
}
Animation.prototype.tick = function(f) {
}
Animation.prototype.clone = function() {
	let clone = new _Animation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	return clone;
}
function _Animation() {};
_Animation.prototype = Animation.prototype;
Animation.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.startTime);
	buffer.writeFloat64(this.duration);
	let object = this.object
	if(object) {
		var index = _objectCacheIndex.get(object);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(object, index = _objectCache.length);
			_objectCache.push(object);
			buffer.writeInt32(-index);
			buffer.writeString(object.type);
			object._objectIndex = index;
			object.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Animation.prototype.deserialize_internal = function(buffer) {
	this.startTime = buffer.readFloat64();
	this.duration = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.object = _objectCache[index];
	} else {
		let object = this.object
		let type = buffer.readString();
		if(!object || object._objectIndex != -index)
			this.object = object = new_Object_of_type(type);
		object.type = type;
		(_objectCache[-index] = object).deserialize_internal(buffer);
	}
}
Animation.prototype.serialize_external = function(buffer) {
	buffer.writeString("startTime");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startTime);
	buffer.writeString("duration");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.duration);
	buffer.writeString("object");
	let object_startPos = buffer.reserveSize();
	let object = this.object
	if(object) {
		var index = _objectCacheIndex.get(object);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(object, index = _objectCache.length);
			_objectCache.push(object);
			buffer.writeInt32(-index);
			buffer.writeString(object.type);
			object._objectIndex = index;
			object.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(object_startPos);
	buffer.writeString("");
}
Animation.prototype.deserialize_external = function(buffer) {
	let startTime_is_set = false, duration_is_set = false, object_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startTime":
				buffer.readInt32();
				this.startTime = buffer.readFloat64();
				startTime_is_set = true;
				break;
			case "duration":
				buffer.readInt32();
				this.duration = buffer.readFloat64();
				duration_is_set = true;
				break;
			case "object":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.object = _objectCache[index];
				} else {
					let object = this.object
					let type = buffer.readString();
					if(!object || object._objectIndex != -index)
						this.object = object = new_Object_of_type(type);
					object.type = type;
					(_objectCache[-index] = object).deserialize_external(buffer);
				}
				object_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startTime_is_set) this.startTime = 0.0;
				if(!duration_is_set) this.duration = 0.0;
				if(!object_is_set) this.object = null;
				return;
		}
	}
}
var Vector2_none;
var Vector2_minValue;
var Vector2_maxValue;
var Vector2_zero;
function Vector2_init() {
	Vector2_none = new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	Vector2_minValue = new Vector2(-Number.MAX_VALUE, -Number.MAX_VALUE, null);
	Vector2_maxValue = new Vector2(Number.MAX_VALUE, Number.MAX_VALUE, null);
	Vector2_zero = new Vector2(0, 0, null);
}
function Vector2(x, y, location) {
	this.x = x;
	this.y = y;
	this.location = location;
}
Vector2.prototype.toString = function() {
	return "("+this.x?.toString()+" "+this.y?.toString()+")";
}
Vector2.prototype.toBool = function() {
	return (this.x != Number.POSITIVE_INFINITY || this.y != Number.POSITIVE_INFINITY);
}
Vector2.prototype.clone = function() {
	return new Vector2(this.x, this.y, this.location);
}
function Vector2_assign_Vector2(a, b) {
	a.x = b.x;
	a.y = b.y;
	a.location = b.location;
	return a;
}
function Vector2_plus_Vector2(a, b) {
	return new Vector2(a.x + b.x, a.y + b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function Vector2_minus_Vector2(a, b) {
	return new Vector2(a.x - b.x, a.y - b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function Vector2_multiply_Vector2(a, b) {
	return new Vector2(a.x * b.x, a.y * b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function Vector2_multiply_float(a, b) {
	return new Vector2(a.x * b, a.y * b, a.location);
}
function Vector2_multiply_Time(a, b) {
	return new Vector2(a.x*b, a.y*b, a.location);
}
function float_multiply_Vector2(a, b) {
	return new Vector2(a * b.x, a * b.y, b.location);
}
function Vector2_multiply_Matrix2D(vector, matrix) {
	return new Vector2(matrix.m0 * vector.x + matrix.m2 * vector.y + matrix.m4, matrix.m1 * vector.x + matrix.m3 * vector.y + matrix.m5, vector.location);
}
function Vector2_divide_Vector2(a, b) {
	return new Vector2(a.x / b.x, a.y / b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function Vector2_divide_float(a, b) {
	return new Vector2(a.x / b, a.y / b, a.location);
}
function Vector2_divide_Matrix2D(vector, matrix) {
	let aa = matrix.m0, ab = matrix.m1, ac = matrix.m2, ad = matrix.m3, atx = matrix.m4, aty = matrix.m5;
	let det = aa * ad - ab * ac;
	if(det == 0) {
		return new Vector2(0, 0, null);
	}
	det = 1.0 / det;
	return new Vector2((ad * det) * vector.x + (-ac * det) * vector.y + ((ac * aty - ad * atx) * det), (-ab * det) * vector.x + (aa * det) * vector.y + ((ab * atx - aa * aty) * det), vector.location);
}
function Vector2_modulo_Vector2(a, b) {
	return new Vector2(float_modulo_float(((float_modulo_float(a.x, b.x)) + b.x), b.x), float_modulo_float(((float_modulo_float(a.y, b.y)) + b.y), b.y), (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function Vector2_modulo_float(a, b) {
	return new Vector2(float_modulo_float(((float_modulo_float(a.x, b)) + b), b), float_modulo_float(((float_modulo_float(a.y, b)) + b), b), a.location);
}
function Vector2_plusAssign_Vector2(a, b) {
	a.x += b.x;
	a.y += b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function Vector2_minusAssign_Vector2(a, b) {
	a.x -= b.x;
	a.y -= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function Vector2_multiplyAssign_Vector2(a, b) {
	a.x *= b.x;
	a.y *= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function Vector2_divideAssign_Vector2(a, b) {
	a.x /= b.x;
	a.y /= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function Vector2_equal_Vector2(a, b) {
	return a.x == b.x && a.y == b.y;
}
function Vector2_notEqual_Vector2(a, b) {
	return a.x != b.x || a.y != b.y;
}
function Vector2_equal_IntVector2(a, b) {
	return a.x == b.x && a.y == b.y;
}
function Vector2_notEqual_IntVector2(a, b) {
	return a.x != b.x || a.y != b.y;
}
function IntVector2_equal_Vector2(a, b) {
	return b.x == a.x && b.y == a.y;
}
function IntVector2_notEqual_Vector2(a, b) {
	return b.x != a.x || b.y != a.y;
}
function Vector2_greater_Vector2(a, b) {
	return a.x > b.x && a.y > b.y;
}
function Vector2_greaterOrEqual_Vector2(a, b) {
	return a.x >= b.x && a.y >= b.y;
}
function Vector2_less_Vector2(a, b) {
	return a.x < b.x && a.y < b.y;
}
function Vector2_lessOrEqual_Vector2(a, b) {
	return a.x <= b.x && a.y <= b.y;
}
function Vector2_equal_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) == length;
}
function Vector2_notEqual_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) != length;
}
function Vector2_greater_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) > length;
}
function Vector2_greaterOrEqual_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) >= length;
}
function Vector2_less_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) < length;
}
function Vector2_lessOrEqual_float(a, length) {
	let x = a.x, y = a.y;
	return Math.sqrt(x * x + y * y) <= length;
}
Vector2.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
}
Vector2.prototype.orthogonal = function() {
	return new Vector2(-this.y, this.x, null);
}
Vector2.prototype.inverse = function() {
	return new Vector2(-this.x, -this.y, null);
}
Vector2.prototype.rounded = function() {
	return new IntVector2(Math.round(this.x), Math.round(this.y), null);
}
Vector2.prototype.floor = function() {
	return new IntVector2(Math.floor(this.x), Math.floor(this.y), null);
}
Vector2.prototype.ceil = function() {
	return new IntVector2(Math.ceil(this.x), Math.ceil(this.y), null);
}
Vector2.prototype.abs = function() {
	return new Vector2(Math.abs(this.x), Math.abs(this.y), null);
}
Vector2.prototype.max = function() {
	return (this.x > this.y ? this.x : this.y);
}
Vector2.prototype.min = function() {
	return (this.x < this.y ? this.x : this.y);
}
Vector2.prototype.move = function(delta) {
	this.x += delta.x;
	this.y += delta.y;
	return this;
}
Vector2.prototype.move2 = function(x, y) {
	this.x += x;
	this.y += y;
	return this;
}
Vector2.prototype.rotate = function(angle) {
	let x = this.x, y = this.y;
	let sn = math_sin(angle);
	let cs = math_cos(angle);
	this.x = x * cs - y * sn;
	this.y = x * sn + y * cs;
	return this;
}
Vector2.prototype.distanceTo = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
Vector2.prototype.manhattanDistanceTo = function(value) {
	return Math.abs(this.x - value.x) + Math.abs(this.y - value.y);
}
Vector2.prototype.angleTo = function(value) {
	return math_getAngleForVector(Vector2_minus_Vector2(value, this));
}
Vector2.prototype.interpolateTo = function(target, value) {
	let ivalue = 1 - value;
	return new Vector2(this.x * ivalue + target.x * value, this.y * ivalue + target.y * value, null);
}
Vector2.prototype.interpolateTo2 = function(target, value, ease) {
	value = ease.function.invoke(value);
	let ivalue = 1 - value;
	return new Vector2(this.x * ivalue + target.x * value, this.y * ivalue + target.y * value, null);
}
Vector2.prototype.interpolateTo3 = function(target, value, from, to) {
	if(value <= from) {
		return this;
	}
	if(value >= to) {
		return target;
	}
	let factor = (value - from) / (to - from);
	return new Vector2(this.x + (target.x - this.x) * factor, this.y + (target.y - this.y) * factor, null);
}
Vector2.prototype.interpolateTo4 = function(target, value, from, to, ease) {
	if(value <= from) {
		return this;
	}
	if(value >= to) {
		return target;
	}
	let factor = ease.function.invoke((value - from) / (to - from));
	return new Vector2(this.x + (target.x - this.x) * factor, this.y + (target.y - this.y) * factor, null);
}
Vector2.prototype.normalized = function() {
	let len = Math.sqrt(this.x * this.x + this.y * this.y);
	return (len != 0 ? new Vector2(this.x / len, this.y / len, null) : new Vector2(0, 0, null));
}
Vector2.prototype.moveTowards = function(targetPosition, speed) {
	let delta = Vector2_minus_Vector2(targetPosition, this);
	if(delta.x != 0 || delta.y != 0) {
		Vector2_assign_Vector2(delta, Vector2_multiply_float(delta.normalized(), speed));
		if(delta.x > 0) {
			this.x = Math.min(this.x + delta.x, targetPosition.x);
		} else {
			this.x = Math.max(this.x + delta.x, targetPosition.x);
		}
		if(delta.y > 0) {
			this.y = Math.min(this.y + delta.y, targetPosition.y);
		} else {
			this.y = Math.max(this.y + delta.y, targetPosition.y);
		}
	}
}
Vector2.prototype.transform = function(matrix) {
	let ax = this.x, ay = this.y;
	this.x = matrix.m0 * ax + matrix.m2 * ay + matrix.m4;
	this.y = matrix.m1 * ax + matrix.m3 * ay + matrix.m5;
	return this;
}
Vector2.prototype.getTransformed = function(matrix) {
	return new Vector2(matrix.m0 * this.x + matrix.m2 * this.y + matrix.m4, matrix.m1 * this.x + matrix.m3 * this.y + matrix.m5, null);
}
Vector2.prototype.getRelativeTo = function(matrix) {
	let aa = matrix.m0, ab = matrix.m1, ac = matrix.m2, ad = matrix.m3, atx = matrix.m4, aty = matrix.m5;
	let det = aa * ad - ab * ac;
	if(det == 0) {
		return new Vector2(0.0, 0.0, null);
	}
	det = 1.0 / det;
	return new Vector2((ad * det) * this.x + (-ac * det) * this.y + ((ac * aty - ad * atx) * det), (-ab * det) * this.x + (aa * det) * this.y + ((ab * atx - aa * aty) * det), null);
}
Vector2.prototype.isInsideRectangle = function(center, size) {
	return this.x >= center.x - size.x / 2 && this.x < center.x + size.x / 2 && this.y >= center.y - size.y / 2 && this.y < center.y + size.y / 2;
}
Vector2.prototype.isInsidePoygon = function(poly) {
	let c = false, i = -1, l = poly.length, j = l - 1;
	while(++i < l) {
		((poly.get(i).y <= this.y && this.y < poly.get(j).y) || (poly.get(j).y <= this.y && this.y < poly.get(i).y)) && (this.x < (poly.get(j).x - poly.get(i).x) * (this.y - poly.get(i).y) / (poly.get(j).y - poly.get(i).y) + poly.get(i).x) && (c = !c);
		j = i;
	}
	return c;
}
Vector2.prototype.in = function(rectangle) {
	return this.x >= rectangle.position.x - rectangle.size.x / 2 && this.x < rectangle.position.x + rectangle.size.x / 2 && this.y >= rectangle.position.y - rectangle.size.y / 2 && this.y < rectangle.position.y + rectangle.size.y / 2;
}
Vector2.prototype.dot = function(value) {
	return this.x * value.x + this.y * value.y;
}
Vector2.prototype.cross = function(value) {
	return this.x * value.y - this.y * value.x;
}
Vector2.prototype.serialize = function(buffer) {
	buffer.writeFloat64(this.x);
	buffer.writeFloat64(this.y);
}
Vector2.prototype.deserialize = function(buffer) {
	this.x = buffer.readFloat64();
	this.y = buffer.readFloat64();
}
function _Vector2() {};
_Vector2.prototype = Vector2.prototype;
function Vector2_serialize_internal(buffer) {
	(Vector2_none || new _Vector2()).serialize_internal(buffer);
	(Vector2_minValue || new _Vector2()).serialize_internal(buffer);
	(Vector2_maxValue || new _Vector2()).serialize_internal(buffer);
	(Vector2_zero || new _Vector2()).serialize_internal(buffer);
}
function Vector2_deserialize_internal(buffer) {
	(Vector2_none || (Vector2_none = new _Vector2())).deserialize_internal(buffer);
	(Vector2_minValue || (Vector2_minValue = new _Vector2())).deserialize_internal(buffer);
	(Vector2_maxValue || (Vector2_maxValue = new _Vector2())).deserialize_internal(buffer);
	(Vector2_zero || (Vector2_zero = new _Vector2())).deserialize_internal(buffer);
}
Vector2.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.x);
	buffer.writeFloat64(this.y);
}
Vector2.prototype.deserialize_internal = function(buffer) {
	this.x = buffer.readFloat64();
	this.y = buffer.readFloat64();
}
function Vector2_serialize_external(buffer) {
	buffer.writeString("none");
	let Vector2_none_startPos = buffer.reserveSize();
	(Vector2_none || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(Vector2_none_startPos);
	buffer.writeString("minValue");
	let Vector2_minValue_startPos = buffer.reserveSize();
	(Vector2_minValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(Vector2_minValue_startPos);
	buffer.writeString("maxValue");
	let Vector2_maxValue_startPos = buffer.reserveSize();
	(Vector2_maxValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(Vector2_maxValue_startPos);
	buffer.writeString("zero");
	let Vector2_zero_startPos = buffer.reserveSize();
	(Vector2_zero || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(Vector2_zero_startPos);
	buffer.writeString("");
}
function Vector2_deserialize_external(buffer) {
	let none_is_set = false, minValue_is_set = false, maxValue_is_set = false, zero_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "none":
				buffer.readInt32();
				(Vector2_none || (Vector2_none = new _Vector2())).deserialize_external(buffer);
				none_is_set = true;
				break;
			case "minValue":
				buffer.readInt32();
				(Vector2_minValue || (Vector2_minValue = new _Vector2())).deserialize_external(buffer);
				minValue_is_set = true;
				break;
			case "maxValue":
				buffer.readInt32();
				(Vector2_maxValue || (Vector2_maxValue = new _Vector2())).deserialize_external(buffer);
				maxValue_is_set = true;
				break;
			case "zero":
				buffer.readInt32();
				(Vector2_zero || (Vector2_zero = new _Vector2())).deserialize_external(buffer);
				zero_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!none_is_set) Vector2_none = new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
				if(!minValue_is_set) Vector2_minValue = new Vector2(-Number.MAX_VALUE, -Number.MAX_VALUE, null);
				if(!maxValue_is_set) Vector2_maxValue = new Vector2(Number.MAX_VALUE, Number.MAX_VALUE, null);
				if(!zero_is_set) Vector2_zero = new Vector2(0, 0, null);
				return;
		}
	}
}
Vector2.prototype.serialize_external = function(buffer) {
	buffer.writeString("x");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x);
	buffer.writeString("y");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y);
	buffer.writeString("");
}
Vector2.prototype.deserialize_external = function(buffer) {
	let x_is_set = false, y_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x":
				buffer.readInt32();
				this.x = buffer.readFloat64();
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				this.y = buffer.readFloat64();
				y_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x_is_set) this.x = 0.0;
				if(!y_is_set) this.y = 0.0;
				return;
		}
	}
}
var IntVector2_none;
var IntVector2_zero;
function IntVector2_init() {
	IntVector2_none = new IntVector2(int_minValue, int_minValue, null);
	IntVector2_zero = new IntVector2(0, 0, null);
}
function IntVector2(x, y, location) {
	this.x = x;
	this.y = y;
	this.location = location;
}
IntVector2.prototype.clone = function() {
	return new IntVector2(this.x, this.y, this.location);
}
IntVector2.prototype.toString = function() {
	return "("+this.x?.toString()+" "+this.y?.toString()+")";
}
IntVector2.prototype.toBool = function() {
	return (this.x != int_minValue || this.y != int_minValue);
}
IntVector2.prototype.toVector2 = function() {
	return new Vector2(this.x, this.y, this.location);
}
function IntVector2_assign_IntVector2(a, b) {
	a.x = b.x;
	a.y = b.y;
	a.location = b.location;
	return a;
}
function IntVector2_plus_IntVector2(a, b) {
	return new IntVector2(a.x + b.x, a.y + b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function IntVector2_minus_IntVector2(a, b) {
	return new IntVector2(a.x - b.x, a.y - b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function IntVector2_multiply_IntVector2(a, b) {
	return new IntVector2(a.x * b.x, a.y * b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function IntVector2_multiply_int(a, b) {
	return new IntVector2(a.x * b, a.y * b, a.location);
}
function int_multiply_IntVector2(a, b) {
	return new IntVector2(a * b.x, a * b.y, b.location);
}
function IntVector2_divide_IntVector2(a, b) {
	return new Vector2(a.x / b.x, a.y / b.y, (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function IntVector2_divide_float(a, b) {
	return new Vector2(a.x / b, a.y / b, a.location);
}
function IntVector2_modulo_IntVector2(a, b) {
	return new IntVector2(int_modulo_int(((int_modulo_int(a.x, b.x)) + b.x), b.x), int_modulo_int(((int_modulo_int(a.y, b.y)) + b.y), b.y), (((a.location || b.location) != null) ? new SourceCodeLocation(null, 0, 0, a.location, b.location) : null));
}
function IntVector2_modulo_int(a, b) {
	return new IntVector2(int_modulo_int(((int_modulo_int(a.x, b)) + b), b), int_modulo_int(((int_modulo_int(a.y, b)) + b), b), a.location);
}
function IntVector2_plusAssign_IntVector2(a, b) {
	a.x += b.x;
	a.y += b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function IntVector2_minusAssign_IntVector2(a, b) {
	a.x -= b.x;
	a.y -= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function IntVector2_multiplyAssign_IntVector2(a, b) {
	a.x *= b.x;
	a.y *= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function IntVector2_divideAssign_IntVector2(a, b) {
	a.x /= b.x;
	a.y /= b.y;
	if((a.location != null) || (b.location != null)) {
		a.location = new SourceCodeLocation(null, 0, 0, a.location, b.location);
	}
	return a;
}
function IntVector2_equal_IntVector2(a, b) {
	return a.x == b.x && a.y == b.y;
}
function IntVector2_notEqual_IntVector2(a, b) {
	return a.x != b.x || a.y != b.y;
}
function IntVector2_greater_IntVector2(a, b) {
	return a.x > b.x && a.y > b.y;
}
function IntVector2_greaterOrEqual_IntVector2(a, b) {
	return a.x >= b.x && a.y >= b.y;
}
function IntVector2_less_IntVector2(a, b) {
	return a.x < b.x && a.y < b.y;
}
function IntVector2_lessOrEqual_IntVector2(a, b) {
	return a.x <= b.x && a.y <= b.y;
}
IntVector2.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
}
IntVector2.prototype.orthogonal = function() {
	return new IntVector2(-this.y, this.x, null);
}
IntVector2.prototype.inverse = function() {
	return new IntVector2(-this.x, -this.y, null);
}
IntVector2.prototype.abs = function() {
	return new IntVector2(Math.abs(this.x), Math.abs(this.y), null);
}
IntVector2.prototype.max = function() {
	return (this.x > this.y ? this.x : this.y);
}
IntVector2.prototype.min = function() {
	return (this.x < this.y ? this.x : this.y);
}
IntVector2.prototype.limit = function(min, max) {
	return new IntVector2(math_limit(this.x, min.x, max.x), math_limit(this.y, min.y, max.y), null);
}
IntVector2.prototype.limit2 = function(max) {
	return new IntVector2(math_limit2(this.x, max.x), math_limit2(this.y, max.y), null);
}
IntVector2.prototype.limit3 = function(min) {
	return new IntVector2(math_limit3(this.x, min.x), math_limit3(this.y, min.y), null);
}
IntVector2.prototype.interpolateTo = function(target, value) {
	let ivalue = 1 - value;
	return new Vector2(this.x * ivalue + target.x * value, this.y * ivalue + target.y * value, null);
}
IntVector2.prototype.distanceTo = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
IntVector2.prototype.distanceTo2 = function(value) {
	let x = this.x - value.x;
	let y = this.y - value.y;
	return Math.sqrt(x * x + y * y);
}
IntVector2.prototype.manhattanDistanceTo = function(value) {
	return Math.abs(this.x - value.x) + Math.abs(this.y - value.y);
}
IntVector2.prototype.angleTo = function(value) {
	return math_getAngleForVector(IntVector2_minus_IntVector2(value, this)?.toVector2());
}
IntVector2.prototype.normalized = function() {
	let len = Math.sqrt(this.x * this.x + this.y * this.y);
	return (len != 0 ? new Vector2(this.x / len, this.y / len, null) : new Vector2(0, 0, null));
}
function IntVector2_enumerate(from, to, selector) {
	let result = []
	for(let y=from.y; y < to.y; ++y)
		for(let x=from.x; x < to.x; ++x)
			result.push(selector(new IntVector2(x,y)))
	return result
}
function _IntVector2() {};
_IntVector2.prototype = IntVector2.prototype;
function IntVector2_serialize_internal(buffer) {
	(IntVector2_none || new _IntVector2()).serialize_internal(buffer);
	(IntVector2_zero || new _IntVector2()).serialize_internal(buffer);
}
function IntVector2_deserialize_internal(buffer) {
	(IntVector2_none || (IntVector2_none = new _IntVector2())).deserialize_internal(buffer);
	(IntVector2_zero || (IntVector2_zero = new _IntVector2())).deserialize_internal(buffer);
}
IntVector2.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.x);
	buffer.writeInt32(this.y);
}
IntVector2.prototype.deserialize_internal = function(buffer) {
	this.x = buffer.readInt32();
	this.y = buffer.readInt32();
}
function IntVector2_serialize_external(buffer) {
	buffer.writeString("none");
	let IntVector2_none_startPos = buffer.reserveSize();
	(IntVector2_none || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(IntVector2_none_startPos);
	buffer.writeString("zero");
	let IntVector2_zero_startPos = buffer.reserveSize();
	(IntVector2_zero || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(IntVector2_zero_startPos);
	buffer.writeString("");
}
function IntVector2_deserialize_external(buffer) {
	let none_is_set = false, zero_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "none":
				buffer.readInt32();
				(IntVector2_none || (IntVector2_none = new _IntVector2())).deserialize_external(buffer);
				none_is_set = true;
				break;
			case "zero":
				buffer.readInt32();
				(IntVector2_zero || (IntVector2_zero = new _IntVector2())).deserialize_external(buffer);
				zero_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!none_is_set) IntVector2_none = new IntVector2(int_minValue, int_minValue, null);
				if(!zero_is_set) IntVector2_zero = new IntVector2(0, 0, null);
				return;
		}
	}
}
IntVector2.prototype.serialize_external = function(buffer) {
	buffer.writeString("x");
	buffer.writeInt32(4);
	buffer.writeInt32(this.x);
	buffer.writeString("y");
	buffer.writeInt32(4);
	buffer.writeInt32(this.y);
	buffer.writeString("");
}
IntVector2.prototype.deserialize_external = function(buffer) {
	let x_is_set = false, y_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x":
				buffer.readInt32();
				this.x = buffer.readInt32();
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				this.y = buffer.readInt32();
				y_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x_is_set) this.x = 0;
				if(!y_is_set) this.y = 0;
				return;
		}
	}
}
function Matrix2D(m0, m1, m2, m3, m4, m5) {
	this.m0 = m0;
	this.m1 = m1;
	this.m2 = m2;
	this.m3 = m3;
	this.m4 = m4;
	this.m5 = m5;
}
Matrix2D.prototype.clear = function() {
	this.m0 = 1.0;
	this.m1 = 0.0;
	this.m2 = 0.0;
	this.m3 = 1.0;
	this.m4 = 0.0;
	this.m5 = 0.0;
}
Matrix2D.prototype.set = function(m0, m1, m2, m3, m4, m5) {
	this.m0 = m0;
	this.m1 = m1;
	this.m2 = m2;
	this.m3 = m3;
	this.m4 = m4;
	this.m5 = m5;
}
Matrix2D.prototype.clone = function() {
	return new Matrix2D(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5);
}
function Matrix2D_assign_Matrix2D(a, b) {
	a.m0 = b.m0;
	a.m1 = b.m1;
	a.m2 = b.m2;
	a.m3 = b.m3;
	a.m4 = b.m4;
	a.m5 = b.m5;
	return this;
}
function Matrix2D_multiply_Matrix2D(a, b) {
	let c = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	return Matrix2D_multiply(a, b, c);
}
function Matrix2D_multiplyAssign_Matrix2D(a, b) {
	return Matrix2D_multiply(a, b, a);
}
Matrix2D.prototype.translationVector = function() {
	return new Vector2(this.m4, this.m5, null);
}
Matrix2D.prototype.scaleVector = function() {
	return new Vector2(this.m0, this.m3, null);
}
Matrix2D.prototype.toString = function() {
	return "(" + this.m0.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m1.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m2.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m3.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m4.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + " " + this.m5.toLocaleString("en-US", {maximumFractionDigits:1, minimumFractionDigits:1, minimumIntegerDigits:1, useGrouping:false}) + ")";
}
Matrix2D.prototype.toBool = function() {
	return (this.m0 != 1 || this.m1 != 0 || this.m2 != 0 || this.m3 != 1 || this.m4 != 0 || this.m5 != 0);
}
Matrix2D.prototype.move = function(vector) {
	let x = vector.x, y = vector.y;
	this.m4 += this.m0 * x + this.m2 * y;
	this.m5 += this.m1 * x + this.m3 * y;
	return this;
}
Matrix2D.prototype.rotate = function(angle) {
	let a0 = this.m0, a1 = this.m1, a2 = this.m2, a3 = this.m3;
	let sin = math_sin(angle), cos = math_cos(angle);
	this.m0 = a0 * cos + a2 * sin;
	this.m1 = a1 * cos + a3 * sin;
	this.m2 = a0 * -sin + a2 * cos;
	this.m3 = a1 * -sin + a3 * cos;
	return this;
}
Matrix2D.prototype.scale = function(vector) {
	let x = vector.x, y = vector.y;
	this.m0 *= x;
	this.m1 *= x;
	this.m2 *= y;
	this.m3 *= y;
	return this;
}
Matrix2D.prototype.multiplyRight = function(value) {
	return Matrix2D_multiply(this, value, this);
}
Matrix2D.prototype.multiplyLeft = function(value) {
	return Matrix2D_multiply(value, this, this);
}
function Matrix2D_multiply(left, right, result) {
	let a0 = left.m0, a2 = left.m2, a4 = left.m4;
	let a1 = left.m1, a3 = left.m3, a5 = left.m5;
	let b0 = right.m0, b2 = right.m2, b4 = right.m4;
	let b1 = right.m1, b3 = right.m3, b5 = right.m5;
	result.m0 = b0 * a0 + b2 * a1;
	result.m2 = b0 * a2 + b2 * a3;
	result.m4 = b0 * a4 + b2 * a5 + b4;
	result.m1 = b1 * a0 + b3 * a1;
	result.m3 = b1 * a2 + b3 * a3;
	result.m5 = b1 * a4 + b3 * a5 + b5;
	return result;
}
function _Matrix2D() {};
_Matrix2D.prototype = Matrix2D.prototype;
Matrix2D.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.m0);
	buffer.writeFloat64(this.m1);
	buffer.writeFloat64(this.m2);
	buffer.writeFloat64(this.m3);
	buffer.writeFloat64(this.m4);
	buffer.writeFloat64(this.m5);
}
Matrix2D.prototype.deserialize_internal = function(buffer) {
	this.m0 = buffer.readFloat64();
	this.m1 = buffer.readFloat64();
	this.m2 = buffer.readFloat64();
	this.m3 = buffer.readFloat64();
	this.m4 = buffer.readFloat64();
	this.m5 = buffer.readFloat64();
}
Matrix2D.prototype.serialize_external = function(buffer) {
	buffer.writeString("m0");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m0);
	buffer.writeString("m1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m1);
	buffer.writeString("m2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m2);
	buffer.writeString("m3");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m3);
	buffer.writeString("m4");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m4);
	buffer.writeString("m5");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.m5);
	buffer.writeString("");
}
Matrix2D.prototype.deserialize_external = function(buffer) {
	let m0_is_set = false, m1_is_set = false, m2_is_set = false, m3_is_set = false, m4_is_set = false, m5_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "m0":
				buffer.readInt32();
				this.m0 = buffer.readFloat64();
				m0_is_set = true;
				break;
			case "m1":
				buffer.readInt32();
				this.m1 = buffer.readFloat64();
				m1_is_set = true;
				break;
			case "m2":
				buffer.readInt32();
				this.m2 = buffer.readFloat64();
				m2_is_set = true;
				break;
			case "m3":
				buffer.readInt32();
				this.m3 = buffer.readFloat64();
				m3_is_set = true;
				break;
			case "m4":
				buffer.readInt32();
				this.m4 = buffer.readFloat64();
				m4_is_set = true;
				break;
			case "m5":
				buffer.readInt32();
				this.m5 = buffer.readFloat64();
				m5_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!m0_is_set) this.m0 = 1.0;
				if(!m1_is_set) this.m1 = 0.0;
				if(!m2_is_set) this.m2 = 0.0;
				if(!m3_is_set) this.m3 = 1.0;
				if(!m4_is_set) this.m4 = 0.0;
				if(!m5_is_set) this.m5 = 0.0;
				return;
		}
	}
}
function Angle() {
}
function _Angle() {};
_Angle.prototype = Angle.prototype;
function IsometicGrid(size, cellSize, topFaceOffset) {
	this.size = size?.clone();
	this.cellSize = cellSize?.clone();
	this.topFaceOffset = topFaceOffset?.clone();
	this.xOffset = Vector2_divide_float(this.cellSize, 2)?.clone();
	this.yOffset = new Vector2(-this.xOffset.x, this.xOffset.y, null);
	this.basePos = new Vector2(0, -this.yOffset.y * (this.size.y - 1), null);
}
IsometicGrid.prototype.getScreenPosition = function(worldPos) {
	return Vector2_plus_Vector2(Vector2_plus_Vector2(this.basePos, Vector2_multiply_float(this.xOffset, worldPos.x)), Vector2_multiply_float(this.yOffset, worldPos.y));
}
IsometicGrid.prototype.getWorldPosition = function(screenPos, allowOutside) {
	let t = Vector2_plus_Vector2(Vector2_minus_Vector2(screenPos, this.basePos), this.topFaceOffset);
	let x = (this.xOffset.x * t.y + this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y);
	let y = (this.xOffset.x * t.y - this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y);
	if(allowOutside || (x >= 0 && x < this.size.x && y >= 0 && y < this.size.y)) {
		return new Vector2(x, y, null);
	} else {
		return Vector2_none;
	}
}
IsometicGrid.prototype.getGridPosition = function(screenPos, allowOutside) {
	let t = Vector2_plus_Vector2(Vector2_minus_Vector2(screenPos, this.basePos), this.topFaceOffset);
	let x = Math.round((this.xOffset.x * t.y + this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y));
	let y = Math.round((this.xOffset.x * t.y - this.xOffset.y * t.x) / (2 * this.xOffset.x * this.xOffset.y));
	if(allowOutside || (x >= 0 && x < this.size.x && y >= 0 && y < this.size.y)) {
		return new IntVector2(x, y, null);
	} else {
		return IntVector2_none;
	}
}
IsometicGrid.prototype.isValid = function(pos) {
	return IntVector2_greaterOrEqual_IntVector2(pos, new IntVector2(0, 0, null)) && IntVector2_less_IntVector2(pos, this.size);
}
IsometicGrid.prototype.limitToInside = function(position) {
	return new IntVector2(math_limit(position.x, 0, this.size.x - 1), math_limit(position.y, 0, this.size.y - 1), null);
}
IsometicGrid.prototype.getScreenVector = function(worldVector) {
	return Vector2_plus_Vector2(Vector2_multiply_float(this.xOffset, worldVector.x), Vector2_multiply_float(this.yOffset, worldVector.y));
}
IsometicGrid.prototype.clone = function() {
	let clone = new _IsometicGrid();
	clone.size = this.size.clone();
	clone.cellSize = this.cellSize.clone();
	clone.topFaceOffset = this.topFaceOffset.clone();
	clone.xOffset = this.xOffset.clone();
	clone.yOffset = this.yOffset.clone();
	clone.basePos = this.basePos.clone();
	return clone;
}
function _IsometicGrid() {};
_IsometicGrid.prototype = IsometicGrid.prototype;
IsometicGrid.prototype.serialize_internal = function(buffer) {
	(this.size || new _IntVector2()).serialize_internal(buffer);
	(this.cellSize || new _Vector2()).serialize_internal(buffer);
	(this.topFaceOffset || new _Vector2()).serialize_internal(buffer);
	(this.xOffset || new _Vector2()).serialize_internal(buffer);
	(this.yOffset || new _Vector2()).serialize_internal(buffer);
	(this.basePos || new _Vector2()).serialize_internal(buffer);
}
IsometicGrid.prototype.deserialize_internal = function(buffer) {
	(this.size || (this.size = new _IntVector2())).deserialize_internal(buffer);
	(this.cellSize || (this.cellSize = new _Vector2())).deserialize_internal(buffer);
	(this.topFaceOffset || (this.topFaceOffset = new _Vector2())).deserialize_internal(buffer);
	(this.xOffset || (this.xOffset = new _Vector2())).deserialize_internal(buffer);
	(this.yOffset || (this.yOffset = new _Vector2())).deserialize_internal(buffer);
	(this.basePos || (this.basePos = new _Vector2())).deserialize_internal(buffer);
}
IsometicGrid.prototype.serialize_external = function(buffer) {
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("cellSize");
	let cellSize_startPos = buffer.reserveSize();
	(this.cellSize || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(cellSize_startPos);
	buffer.writeString("topFaceOffset");
	let topFaceOffset_startPos = buffer.reserveSize();
	(this.topFaceOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(topFaceOffset_startPos);
	buffer.writeString("xOffset");
	let xOffset_startPos = buffer.reserveSize();
	(this.xOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(xOffset_startPos);
	buffer.writeString("yOffset");
	let yOffset_startPos = buffer.reserveSize();
	(this.yOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(yOffset_startPos);
	buffer.writeString("basePos");
	let basePos_startPos = buffer.reserveSize();
	(this.basePos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(basePos_startPos);
	buffer.writeString("");
}
IsometicGrid.prototype.deserialize_external = function(buffer) {
	let size_is_set = false, cellSize_is_set = false, topFaceOffset_is_set = false, xOffset_is_set = false, yOffset_is_set = false, basePos_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _IntVector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "cellSize":
				buffer.readInt32();
				(this.cellSize || (this.cellSize = new _Vector2())).deserialize_external(buffer);
				cellSize_is_set = true;
				break;
			case "topFaceOffset":
				buffer.readInt32();
				(this.topFaceOffset || (this.topFaceOffset = new _Vector2())).deserialize_external(buffer);
				topFaceOffset_is_set = true;
				break;
			case "xOffset":
				buffer.readInt32();
				(this.xOffset || (this.xOffset = new _Vector2())).deserialize_external(buffer);
				xOffset_is_set = true;
				break;
			case "yOffset":
				buffer.readInt32();
				(this.yOffset || (this.yOffset = new _Vector2())).deserialize_external(buffer);
				yOffset_is_set = true;
				break;
			case "basePos":
				buffer.readInt32();
				(this.basePos || (this.basePos = new _Vector2())).deserialize_external(buffer);
				basePos_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!size_is_set) this.size = new IntVector2(0, 0, null);
				if(!cellSize_is_set) this.cellSize = new Vector2(0.0, 0.0, null);
				if(!topFaceOffset_is_set) this.topFaceOffset = new Vector2(0.0, 0.0, null);
				if(!xOffset_is_set) this.xOffset = Vector2_divide_float(this.cellSize, 2);
				if(!yOffset_is_set) this.yOffset = new Vector2(-this.xOffset.x, this.xOffset.y, null);
				if(!basePos_is_set) this.basePos = new Vector2(0, -this.yOffset.y * (this.size.y - 1), null);
				return;
		}
	}
}
var Direction_Right;
var Direction_Down;
var Direction_Left;
var Direction_Up;
var Direction_DownRight;
var Direction_DownLeft;
var Direction_UpLeft;
var Direction_UpRight;
var Direction_primaryDirections;
var Direction_diagonalDirections;
var Direction_horizontalDirections;
var Direction_verticalDirections;
var Direction_allDirections;
function Direction_init() {
	Direction_Right = new Direction("Right", 0, new IntVector2(1, 0, null), (0/360), (330/360));
	Direction_Down = new Direction("Down", 1, new IntVector2(0, 1, null), (90/360), (30/360));
	Direction_Left = new Direction("Left", 2, new IntVector2(-1, 0, null), (180/360), (150/360));
	Direction_Up = new Direction("Up", 3, new IntVector2(0, -1, null), (270/360), (210/360));
	Direction_DownRight = new Direction("DownRight", 0, new IntVector2(1, 1, null), (45/360), 0.0);
	Direction_DownLeft = new Direction("DownLeft", 1, new IntVector2(-1, 1, null), (135/360), 0.0);
	Direction_UpLeft = new Direction("UpLeft", 2, new IntVector2(-1, -1, null), (225/360), 0.0);
	Direction_UpRight = new Direction("UpRight", 3, new IntVector2(1, -1, null), (315/360), 0.0);
	Direction_primaryDirections = [Direction_Right, Direction_Down, Direction_Left, Direction_Up];
	Direction_diagonalDirections = [Direction_DownRight, Direction_DownLeft, Direction_UpLeft, Direction_UpRight];
	Direction_horizontalDirections = [Direction_Left, Direction_Right];
	Direction_verticalDirections = [Direction_Up, Direction_Down];
	Direction_allDirections = [Direction_Right, Direction_DownRight, Direction_Down, Direction_DownLeft, Direction_Left, Direction_UpLeft, Direction_Up, Direction_UpRight];
}
function Direction(name, index, vector, angle, isoAngle) {
	this.name = name;
	this.index = index;
	this.vector = vector?.clone();
	this.angle = angle;
	this.isoAngle = isoAngle;
}
Direction.prototype.toString = function() {
	object_stringify(this, 3);
	return this.name;
}
Direction.prototype.rotated = function(direction) {
	return Direction_primaryDirections.get(int_modulo_int((this.index + ((direction == 0/*Clockwise*/ ? 1 : 3))), 4));
}
Direction.prototype.inverted = function() {
	return Direction_primaryDirections.get(int_modulo_int((this.index + 2), 4));
}
Direction.prototype.isOrthogonalTo = function(value) {
	return int_modulo_int(this.index, 2) != int_modulo_int(value.index, 2);
}
Direction.prototype.isParallelTo = function(value) {
	return int_modulo_int(this.index, 2) == int_modulo_int(value.index, 2);
}
Direction.prototype.clone = function() {
	let clone = new _Direction();
	clone.name = this.name;
	clone.index = this.index;
	clone.vector = this.vector.clone();
	clone.angle = this.angle;
	clone.isoAngle = this.isoAngle;
	return clone;
}
function _Direction() {};
_Direction.prototype = Direction.prototype;
function Direction_serialize_internal(buffer) {
	if(Direction_Right) {
		var index = _objectCacheIndex.get(Direction_Right);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Right, index = _objectCache.length);
			_objectCache.push(Direction_Right);
			buffer.writeInt32(-index);
			Direction_Right._objectIndex = index;
			Direction_Right.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_Down) {
		var index = _objectCacheIndex.get(Direction_Down);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Down, index = _objectCache.length);
			_objectCache.push(Direction_Down);
			buffer.writeInt32(-index);
			Direction_Down._objectIndex = index;
			Direction_Down.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_Left) {
		var index = _objectCacheIndex.get(Direction_Left);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Left, index = _objectCache.length);
			_objectCache.push(Direction_Left);
			buffer.writeInt32(-index);
			Direction_Left._objectIndex = index;
			Direction_Left.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_Up) {
		var index = _objectCacheIndex.get(Direction_Up);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Up, index = _objectCache.length);
			_objectCache.push(Direction_Up);
			buffer.writeInt32(-index);
			Direction_Up._objectIndex = index;
			Direction_Up.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_DownRight) {
		var index = _objectCacheIndex.get(Direction_DownRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_DownRight, index = _objectCache.length);
			_objectCache.push(Direction_DownRight);
			buffer.writeInt32(-index);
			Direction_DownRight._objectIndex = index;
			Direction_DownRight.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_DownLeft) {
		var index = _objectCacheIndex.get(Direction_DownLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_DownLeft, index = _objectCache.length);
			_objectCache.push(Direction_DownLeft);
			buffer.writeInt32(-index);
			Direction_DownLeft._objectIndex = index;
			Direction_DownLeft.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_UpLeft) {
		var index = _objectCacheIndex.get(Direction_UpLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_UpLeft, index = _objectCache.length);
			_objectCache.push(Direction_UpLeft);
			buffer.writeInt32(-index);
			Direction_UpLeft._objectIndex = index;
			Direction_UpLeft.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_UpRight) {
		var index = _objectCacheIndex.get(Direction_UpRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_UpRight, index = _objectCache.length);
			_objectCache.push(Direction_UpRight);
			buffer.writeInt32(-index);
			Direction_UpRight._objectIndex = index;
			Direction_UpRight.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_primaryDirections) {
		var index = _objectCacheIndex.get(Direction_primaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_primaryDirections, index = _objectCache.length);
			_objectCache.push(Direction_primaryDirections);
			buffer.writeInt32(-index);
			Direction_primaryDirections._objectIndex = index;
			buffer.writeInt32(Direction_primaryDirections.length);
			for(let i=0, len=Direction_primaryDirections.length; i<len; ++i) {
				let Direction_primaryDirections_item = Direction_primaryDirections[i]
				if(Direction_primaryDirections_item) {
					var index = _objectCacheIndex.get(Direction_primaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_primaryDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_primaryDirections_item);
						buffer.writeInt32(-index);
						Direction_primaryDirections_item._objectIndex = index;
						Direction_primaryDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_diagonalDirections) {
		var index = _objectCacheIndex.get(Direction_diagonalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_diagonalDirections, index = _objectCache.length);
			_objectCache.push(Direction_diagonalDirections);
			buffer.writeInt32(-index);
			Direction_diagonalDirections._objectIndex = index;
			buffer.writeInt32(Direction_diagonalDirections.length);
			for(let i=0, len=Direction_diagonalDirections.length; i<len; ++i) {
				let Direction_diagonalDirections_item = Direction_diagonalDirections[i]
				if(Direction_diagonalDirections_item) {
					var index = _objectCacheIndex.get(Direction_diagonalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_diagonalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_diagonalDirections_item);
						buffer.writeInt32(-index);
						Direction_diagonalDirections_item._objectIndex = index;
						Direction_diagonalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_horizontalDirections) {
		var index = _objectCacheIndex.get(Direction_horizontalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_horizontalDirections, index = _objectCache.length);
			_objectCache.push(Direction_horizontalDirections);
			buffer.writeInt32(-index);
			Direction_horizontalDirections._objectIndex = index;
			buffer.writeInt32(Direction_horizontalDirections.length);
			for(let i=0, len=Direction_horizontalDirections.length; i<len; ++i) {
				let Direction_horizontalDirections_item = Direction_horizontalDirections[i]
				if(Direction_horizontalDirections_item) {
					var index = _objectCacheIndex.get(Direction_horizontalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_horizontalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_horizontalDirections_item);
						buffer.writeInt32(-index);
						Direction_horizontalDirections_item._objectIndex = index;
						Direction_horizontalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_verticalDirections) {
		var index = _objectCacheIndex.get(Direction_verticalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_verticalDirections, index = _objectCache.length);
			_objectCache.push(Direction_verticalDirections);
			buffer.writeInt32(-index);
			Direction_verticalDirections._objectIndex = index;
			buffer.writeInt32(Direction_verticalDirections.length);
			for(let i=0, len=Direction_verticalDirections.length; i<len; ++i) {
				let Direction_verticalDirections_item = Direction_verticalDirections[i]
				if(Direction_verticalDirections_item) {
					var index = _objectCacheIndex.get(Direction_verticalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_verticalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_verticalDirections_item);
						buffer.writeInt32(-index);
						Direction_verticalDirections_item._objectIndex = index;
						Direction_verticalDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Direction_allDirections) {
		var index = _objectCacheIndex.get(Direction_allDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_allDirections, index = _objectCache.length);
			_objectCache.push(Direction_allDirections);
			buffer.writeInt32(-index);
			Direction_allDirections._objectIndex = index;
			buffer.writeInt32(Direction_allDirections.length);
			for(let i=0, len=Direction_allDirections.length; i<len; ++i) {
				let Direction_allDirections_item = Direction_allDirections[i]
				if(Direction_allDirections_item) {
					var index = _objectCacheIndex.get(Direction_allDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_allDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_allDirections_item);
						buffer.writeInt32(-index);
						Direction_allDirections_item._objectIndex = index;
						Direction_allDirections_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Direction_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_Right = _objectCache[index];
	} else {
		if(!Direction_Right || Direction_Right._objectIndex != -index)
			Direction_Right = new _Direction();
		(_objectCache[-index] = Direction_Right).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_Down = _objectCache[index];
	} else {
		if(!Direction_Down || Direction_Down._objectIndex != -index)
			Direction_Down = new _Direction();
		(_objectCache[-index] = Direction_Down).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_Left = _objectCache[index];
	} else {
		if(!Direction_Left || Direction_Left._objectIndex != -index)
			Direction_Left = new _Direction();
		(_objectCache[-index] = Direction_Left).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_Up = _objectCache[index];
	} else {
		if(!Direction_Up || Direction_Up._objectIndex != -index)
			Direction_Up = new _Direction();
		(_objectCache[-index] = Direction_Up).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_DownRight = _objectCache[index];
	} else {
		if(!Direction_DownRight || Direction_DownRight._objectIndex != -index)
			Direction_DownRight = new _Direction();
		(_objectCache[-index] = Direction_DownRight).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_DownLeft = _objectCache[index];
	} else {
		if(!Direction_DownLeft || Direction_DownLeft._objectIndex != -index)
			Direction_DownLeft = new _Direction();
		(_objectCache[-index] = Direction_DownLeft).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_UpLeft = _objectCache[index];
	} else {
		if(!Direction_UpLeft || Direction_UpLeft._objectIndex != -index)
			Direction_UpLeft = new _Direction();
		(_objectCache[-index] = Direction_UpLeft).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_UpRight = _objectCache[index];
	} else {
		if(!Direction_UpRight || Direction_UpRight._objectIndex != -index)
			Direction_UpRight = new _Direction();
		(_objectCache[-index] = Direction_UpRight).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_primaryDirections = _objectCache[index];
	} else {
		if(!Direction_primaryDirections || Direction_primaryDirections._objectIndex != -index) Direction_primaryDirections = [];
		_objectCache[-index] = Direction_primaryDirections;
		for(let i=0, len = Direction_primaryDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_primaryDirections[i] = _objectCache[index];
				} else {
					let Direction_primaryDirections_item = Direction_primaryDirections[i]
					if(!Direction_primaryDirections_item || Direction_primaryDirections_item._objectIndex != -index)
						Direction_primaryDirections[i] = Direction_primaryDirections_item = new _Direction();
					(_objectCache[-index] = Direction_primaryDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_diagonalDirections = _objectCache[index];
	} else {
		if(!Direction_diagonalDirections || Direction_diagonalDirections._objectIndex != -index) Direction_diagonalDirections = [];
		_objectCache[-index] = Direction_diagonalDirections;
		for(let i=0, len = Direction_diagonalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_diagonalDirections[i] = _objectCache[index];
				} else {
					let Direction_diagonalDirections_item = Direction_diagonalDirections[i]
					if(!Direction_diagonalDirections_item || Direction_diagonalDirections_item._objectIndex != -index)
						Direction_diagonalDirections[i] = Direction_diagonalDirections_item = new _Direction();
					(_objectCache[-index] = Direction_diagonalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_horizontalDirections = _objectCache[index];
	} else {
		if(!Direction_horizontalDirections || Direction_horizontalDirections._objectIndex != -index) Direction_horizontalDirections = [];
		_objectCache[-index] = Direction_horizontalDirections;
		for(let i=0, len = Direction_horizontalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_horizontalDirections[i] = _objectCache[index];
				} else {
					let Direction_horizontalDirections_item = Direction_horizontalDirections[i]
					if(!Direction_horizontalDirections_item || Direction_horizontalDirections_item._objectIndex != -index)
						Direction_horizontalDirections[i] = Direction_horizontalDirections_item = new _Direction();
					(_objectCache[-index] = Direction_horizontalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_verticalDirections = _objectCache[index];
	} else {
		if(!Direction_verticalDirections || Direction_verticalDirections._objectIndex != -index) Direction_verticalDirections = [];
		_objectCache[-index] = Direction_verticalDirections;
		for(let i=0, len = Direction_verticalDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_verticalDirections[i] = _objectCache[index];
				} else {
					let Direction_verticalDirections_item = Direction_verticalDirections[i]
					if(!Direction_verticalDirections_item || Direction_verticalDirections_item._objectIndex != -index)
						Direction_verticalDirections[i] = Direction_verticalDirections_item = new _Direction();
					(_objectCache[-index] = Direction_verticalDirections_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Direction_allDirections = _objectCache[index];
	} else {
		if(!Direction_allDirections || Direction_allDirections._objectIndex != -index) Direction_allDirections = [];
		_objectCache[-index] = Direction_allDirections;
		for(let i=0, len = Direction_allDirections.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_allDirections[i] = _objectCache[index];
				} else {
					let Direction_allDirections_item = Direction_allDirections[i]
					if(!Direction_allDirections_item || Direction_allDirections_item._objectIndex != -index)
						Direction_allDirections[i] = Direction_allDirections_item = new _Direction();
					(_objectCache[-index] = Direction_allDirections_item).deserialize_internal(buffer);
				}
		}
	}
}
Direction.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeInt32(this.index);
	(this.vector || new _IntVector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.angle);
	buffer.writeFloat64(this.isoAngle);
}
Direction.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.index = buffer.readInt32();
	(this.vector || (this.vector = new _IntVector2())).deserialize_internal(buffer);
	this.angle = buffer.readFloat64();
	this.isoAngle = buffer.readFloat64();
}
function Direction_serialize_external(buffer) {
	buffer.writeString("Right");
	let Direction_Right_startPos = buffer.reserveSize();
	if(Direction_Right) {
		var index = _objectCacheIndex.get(Direction_Right);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Right, index = _objectCache.length);
			_objectCache.push(Direction_Right);
			buffer.writeInt32(-index);
			Direction_Right._objectIndex = index;
			Direction_Right.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_Right_startPos);
	buffer.writeString("Down");
	let Direction_Down_startPos = buffer.reserveSize();
	if(Direction_Down) {
		var index = _objectCacheIndex.get(Direction_Down);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Down, index = _objectCache.length);
			_objectCache.push(Direction_Down);
			buffer.writeInt32(-index);
			Direction_Down._objectIndex = index;
			Direction_Down.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_Down_startPos);
	buffer.writeString("Left");
	let Direction_Left_startPos = buffer.reserveSize();
	if(Direction_Left) {
		var index = _objectCacheIndex.get(Direction_Left);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Left, index = _objectCache.length);
			_objectCache.push(Direction_Left);
			buffer.writeInt32(-index);
			Direction_Left._objectIndex = index;
			Direction_Left.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_Left_startPos);
	buffer.writeString("Up");
	let Direction_Up_startPos = buffer.reserveSize();
	if(Direction_Up) {
		var index = _objectCacheIndex.get(Direction_Up);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_Up, index = _objectCache.length);
			_objectCache.push(Direction_Up);
			buffer.writeInt32(-index);
			Direction_Up._objectIndex = index;
			Direction_Up.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_Up_startPos);
	buffer.writeString("DownRight");
	let Direction_DownRight_startPos = buffer.reserveSize();
	if(Direction_DownRight) {
		var index = _objectCacheIndex.get(Direction_DownRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_DownRight, index = _objectCache.length);
			_objectCache.push(Direction_DownRight);
			buffer.writeInt32(-index);
			Direction_DownRight._objectIndex = index;
			Direction_DownRight.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_DownRight_startPos);
	buffer.writeString("DownLeft");
	let Direction_DownLeft_startPos = buffer.reserveSize();
	if(Direction_DownLeft) {
		var index = _objectCacheIndex.get(Direction_DownLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_DownLeft, index = _objectCache.length);
			_objectCache.push(Direction_DownLeft);
			buffer.writeInt32(-index);
			Direction_DownLeft._objectIndex = index;
			Direction_DownLeft.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_DownLeft_startPos);
	buffer.writeString("UpLeft");
	let Direction_UpLeft_startPos = buffer.reserveSize();
	if(Direction_UpLeft) {
		var index = _objectCacheIndex.get(Direction_UpLeft);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_UpLeft, index = _objectCache.length);
			_objectCache.push(Direction_UpLeft);
			buffer.writeInt32(-index);
			Direction_UpLeft._objectIndex = index;
			Direction_UpLeft.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_UpLeft_startPos);
	buffer.writeString("UpRight");
	let Direction_UpRight_startPos = buffer.reserveSize();
	if(Direction_UpRight) {
		var index = _objectCacheIndex.get(Direction_UpRight);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_UpRight, index = _objectCache.length);
			_objectCache.push(Direction_UpRight);
			buffer.writeInt32(-index);
			Direction_UpRight._objectIndex = index;
			Direction_UpRight.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_UpRight_startPos);
	buffer.writeString("primaryDirections");
	let Direction_primaryDirections_startPos = buffer.reserveSize();
	if(Direction_primaryDirections) {
		var index = _objectCacheIndex.get(Direction_primaryDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_primaryDirections, index = _objectCache.length);
			_objectCache.push(Direction_primaryDirections);
			buffer.writeInt32(-index);
			Direction_primaryDirections._objectIndex = index;
			buffer.writeInt32(Direction_primaryDirections.length);
			for(let i=0, len=Direction_primaryDirections.length; i<len; ++i) {
				let Direction_primaryDirections_item = Direction_primaryDirections[i]
				if(Direction_primaryDirections_item) {
					var index = _objectCacheIndex.get(Direction_primaryDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_primaryDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_primaryDirections_item);
						buffer.writeInt32(-index);
						Direction_primaryDirections_item._objectIndex = index;
						Direction_primaryDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_primaryDirections_startPos);
	buffer.writeString("diagonalDirections");
	let Direction_diagonalDirections_startPos = buffer.reserveSize();
	if(Direction_diagonalDirections) {
		var index = _objectCacheIndex.get(Direction_diagonalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_diagonalDirections, index = _objectCache.length);
			_objectCache.push(Direction_diagonalDirections);
			buffer.writeInt32(-index);
			Direction_diagonalDirections._objectIndex = index;
			buffer.writeInt32(Direction_diagonalDirections.length);
			for(let i=0, len=Direction_diagonalDirections.length; i<len; ++i) {
				let Direction_diagonalDirections_item = Direction_diagonalDirections[i]
				if(Direction_diagonalDirections_item) {
					var index = _objectCacheIndex.get(Direction_diagonalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_diagonalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_diagonalDirections_item);
						buffer.writeInt32(-index);
						Direction_diagonalDirections_item._objectIndex = index;
						Direction_diagonalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_diagonalDirections_startPos);
	buffer.writeString("horizontalDirections");
	let Direction_horizontalDirections_startPos = buffer.reserveSize();
	if(Direction_horizontalDirections) {
		var index = _objectCacheIndex.get(Direction_horizontalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_horizontalDirections, index = _objectCache.length);
			_objectCache.push(Direction_horizontalDirections);
			buffer.writeInt32(-index);
			Direction_horizontalDirections._objectIndex = index;
			buffer.writeInt32(Direction_horizontalDirections.length);
			for(let i=0, len=Direction_horizontalDirections.length; i<len; ++i) {
				let Direction_horizontalDirections_item = Direction_horizontalDirections[i]
				if(Direction_horizontalDirections_item) {
					var index = _objectCacheIndex.get(Direction_horizontalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_horizontalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_horizontalDirections_item);
						buffer.writeInt32(-index);
						Direction_horizontalDirections_item._objectIndex = index;
						Direction_horizontalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_horizontalDirections_startPos);
	buffer.writeString("verticalDirections");
	let Direction_verticalDirections_startPos = buffer.reserveSize();
	if(Direction_verticalDirections) {
		var index = _objectCacheIndex.get(Direction_verticalDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_verticalDirections, index = _objectCache.length);
			_objectCache.push(Direction_verticalDirections);
			buffer.writeInt32(-index);
			Direction_verticalDirections._objectIndex = index;
			buffer.writeInt32(Direction_verticalDirections.length);
			for(let i=0, len=Direction_verticalDirections.length; i<len; ++i) {
				let Direction_verticalDirections_item = Direction_verticalDirections[i]
				if(Direction_verticalDirections_item) {
					var index = _objectCacheIndex.get(Direction_verticalDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_verticalDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_verticalDirections_item);
						buffer.writeInt32(-index);
						Direction_verticalDirections_item._objectIndex = index;
						Direction_verticalDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_verticalDirections_startPos);
	buffer.writeString("allDirections");
	let Direction_allDirections_startPos = buffer.reserveSize();
	if(Direction_allDirections) {
		var index = _objectCacheIndex.get(Direction_allDirections);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Direction_allDirections, index = _objectCache.length);
			_objectCache.push(Direction_allDirections);
			buffer.writeInt32(-index);
			Direction_allDirections._objectIndex = index;
			buffer.writeInt32(Direction_allDirections.length);
			for(let i=0, len=Direction_allDirections.length; i<len; ++i) {
				let Direction_allDirections_item = Direction_allDirections[i]
				if(Direction_allDirections_item) {
					var index = _objectCacheIndex.get(Direction_allDirections_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Direction_allDirections_item, index = _objectCache.length);
						_objectCache.push(Direction_allDirections_item);
						buffer.writeInt32(-index);
						Direction_allDirections_item._objectIndex = index;
						Direction_allDirections_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Direction_allDirections_startPos);
	buffer.writeString("");
}
function Direction_deserialize_external(buffer) {
	let Right_is_set = false, Down_is_set = false, Left_is_set = false, Up_is_set = false, DownRight_is_set = false, DownLeft_is_set = false, UpLeft_is_set = false, UpRight_is_set = false, primaryDirections_is_set = false, diagonalDirections_is_set = false, horizontalDirections_is_set = false, verticalDirections_is_set = false, allDirections_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "Right":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_Right = _objectCache[index];
				} else {
					if(!Direction_Right || Direction_Right._objectIndex != -index)
						Direction_Right = new _Direction();
					(_objectCache[-index] = Direction_Right).deserialize_external(buffer);
				}
				Right_is_set = true;
				break;
			case "Down":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_Down = _objectCache[index];
				} else {
					if(!Direction_Down || Direction_Down._objectIndex != -index)
						Direction_Down = new _Direction();
					(_objectCache[-index] = Direction_Down).deserialize_external(buffer);
				}
				Down_is_set = true;
				break;
			case "Left":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_Left = _objectCache[index];
				} else {
					if(!Direction_Left || Direction_Left._objectIndex != -index)
						Direction_Left = new _Direction();
					(_objectCache[-index] = Direction_Left).deserialize_external(buffer);
				}
				Left_is_set = true;
				break;
			case "Up":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_Up = _objectCache[index];
				} else {
					if(!Direction_Up || Direction_Up._objectIndex != -index)
						Direction_Up = new _Direction();
					(_objectCache[-index] = Direction_Up).deserialize_external(buffer);
				}
				Up_is_set = true;
				break;
			case "DownRight":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_DownRight = _objectCache[index];
				} else {
					if(!Direction_DownRight || Direction_DownRight._objectIndex != -index)
						Direction_DownRight = new _Direction();
					(_objectCache[-index] = Direction_DownRight).deserialize_external(buffer);
				}
				DownRight_is_set = true;
				break;
			case "DownLeft":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_DownLeft = _objectCache[index];
				} else {
					if(!Direction_DownLeft || Direction_DownLeft._objectIndex != -index)
						Direction_DownLeft = new _Direction();
					(_objectCache[-index] = Direction_DownLeft).deserialize_external(buffer);
				}
				DownLeft_is_set = true;
				break;
			case "UpLeft":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_UpLeft = _objectCache[index];
				} else {
					if(!Direction_UpLeft || Direction_UpLeft._objectIndex != -index)
						Direction_UpLeft = new _Direction();
					(_objectCache[-index] = Direction_UpLeft).deserialize_external(buffer);
				}
				UpLeft_is_set = true;
				break;
			case "UpRight":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_UpRight = _objectCache[index];
				} else {
					if(!Direction_UpRight || Direction_UpRight._objectIndex != -index)
						Direction_UpRight = new _Direction();
					(_objectCache[-index] = Direction_UpRight).deserialize_external(buffer);
				}
				UpRight_is_set = true;
				break;
			case "primaryDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_primaryDirections = _objectCache[index];
				} else {
					if(!Direction_primaryDirections || Direction_primaryDirections._objectIndex != -index) Direction_primaryDirections = [];
					_objectCache[-index] = Direction_primaryDirections;
					for(let i=0, len = Direction_primaryDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Direction_primaryDirections[i] = _objectCache[index];
							} else {
								let Direction_primaryDirections_item = Direction_primaryDirections[i]
								if(!Direction_primaryDirections_item || Direction_primaryDirections_item._objectIndex != -index)
									Direction_primaryDirections[i] = Direction_primaryDirections_item = new _Direction();
								(_objectCache[-index] = Direction_primaryDirections_item).deserialize_external(buffer);
							}
					}
				}
				primaryDirections_is_set = true;
				break;
			case "diagonalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_diagonalDirections = _objectCache[index];
				} else {
					if(!Direction_diagonalDirections || Direction_diagonalDirections._objectIndex != -index) Direction_diagonalDirections = [];
					_objectCache[-index] = Direction_diagonalDirections;
					for(let i=0, len = Direction_diagonalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Direction_diagonalDirections[i] = _objectCache[index];
							} else {
								let Direction_diagonalDirections_item = Direction_diagonalDirections[i]
								if(!Direction_diagonalDirections_item || Direction_diagonalDirections_item._objectIndex != -index)
									Direction_diagonalDirections[i] = Direction_diagonalDirections_item = new _Direction();
								(_objectCache[-index] = Direction_diagonalDirections_item).deserialize_external(buffer);
							}
					}
				}
				diagonalDirections_is_set = true;
				break;
			case "horizontalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_horizontalDirections = _objectCache[index];
				} else {
					if(!Direction_horizontalDirections || Direction_horizontalDirections._objectIndex != -index) Direction_horizontalDirections = [];
					_objectCache[-index] = Direction_horizontalDirections;
					for(let i=0, len = Direction_horizontalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Direction_horizontalDirections[i] = _objectCache[index];
							} else {
								let Direction_horizontalDirections_item = Direction_horizontalDirections[i]
								if(!Direction_horizontalDirections_item || Direction_horizontalDirections_item._objectIndex != -index)
									Direction_horizontalDirections[i] = Direction_horizontalDirections_item = new _Direction();
								(_objectCache[-index] = Direction_horizontalDirections_item).deserialize_external(buffer);
							}
					}
				}
				horizontalDirections_is_set = true;
				break;
			case "verticalDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_verticalDirections = _objectCache[index];
				} else {
					if(!Direction_verticalDirections || Direction_verticalDirections._objectIndex != -index) Direction_verticalDirections = [];
					_objectCache[-index] = Direction_verticalDirections;
					for(let i=0, len = Direction_verticalDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Direction_verticalDirections[i] = _objectCache[index];
							} else {
								let Direction_verticalDirections_item = Direction_verticalDirections[i]
								if(!Direction_verticalDirections_item || Direction_verticalDirections_item._objectIndex != -index)
									Direction_verticalDirections[i] = Direction_verticalDirections_item = new _Direction();
								(_objectCache[-index] = Direction_verticalDirections_item).deserialize_external(buffer);
							}
					}
				}
				verticalDirections_is_set = true;
				break;
			case "allDirections":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Direction_allDirections = _objectCache[index];
				} else {
					if(!Direction_allDirections || Direction_allDirections._objectIndex != -index) Direction_allDirections = [];
					_objectCache[-index] = Direction_allDirections;
					for(let i=0, len = Direction_allDirections.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Direction_allDirections[i] = _objectCache[index];
							} else {
								let Direction_allDirections_item = Direction_allDirections[i]
								if(!Direction_allDirections_item || Direction_allDirections_item._objectIndex != -index)
									Direction_allDirections[i] = Direction_allDirections_item = new _Direction();
								(_objectCache[-index] = Direction_allDirections_item).deserialize_external(buffer);
							}
					}
				}
				allDirections_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!Right_is_set) Direction_Right = new Direction("Right", 0, new IntVector2(1, 0, null), (0/360), (330/360));
				if(!Down_is_set) Direction_Down = new Direction("Down", 1, new IntVector2(0, 1, null), (90/360), (30/360));
				if(!Left_is_set) Direction_Left = new Direction("Left", 2, new IntVector2(-1, 0, null), (180/360), (150/360));
				if(!Up_is_set) Direction_Up = new Direction("Up", 3, new IntVector2(0, -1, null), (270/360), (210/360));
				if(!DownRight_is_set) Direction_DownRight = new Direction("DownRight", 0, new IntVector2(1, 1, null), (45/360), 0.0);
				if(!DownLeft_is_set) Direction_DownLeft = new Direction("DownLeft", 1, new IntVector2(-1, 1, null), (135/360), 0.0);
				if(!UpLeft_is_set) Direction_UpLeft = new Direction("UpLeft", 2, new IntVector2(-1, -1, null), (225/360), 0.0);
				if(!UpRight_is_set) Direction_UpRight = new Direction("UpRight", 3, new IntVector2(1, -1, null), (315/360), 0.0);
				if(!primaryDirections_is_set) Direction_primaryDirections = [Direction_Right, Direction_Down, Direction_Left, Direction_Up];
				if(!diagonalDirections_is_set) Direction_diagonalDirections = [Direction_DownRight, Direction_DownLeft, Direction_UpLeft, Direction_UpRight];
				if(!horizontalDirections_is_set) Direction_horizontalDirections = [Direction_Left, Direction_Right];
				if(!verticalDirections_is_set) Direction_verticalDirections = [Direction_Up, Direction_Down];
				if(!allDirections_is_set) Direction_allDirections = [Direction_Right, Direction_DownRight, Direction_Down, Direction_DownLeft, Direction_Left, Direction_UpLeft, Direction_Up, Direction_UpRight];
				return;
		}
	}
}
Direction.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("vector");
	let vector_startPos = buffer.reserveSize();
	(this.vector || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(vector_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("isoAngle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.isoAngle);
	buffer.writeString("");
}
Direction.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, index_is_set = false, vector_is_set = false, angle_is_set = false, isoAngle_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "vector":
				buffer.readInt32();
				(this.vector || (this.vector = new _IntVector2())).deserialize_external(buffer);
				vector_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			case "isoAngle":
				buffer.readInt32();
				this.isoAngle = buffer.readFloat64();
				isoAngle_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!index_is_set) this.index = 0;
				if(!vector_is_set) this.vector = new IntVector2(0, 0, null);
				if(!angle_is_set) this.angle = 0.0;
				if(!isoAngle_is_set) this.isoAngle = 0.0;
				return;
		}
	}
}
function Line(start, end, type) {
	this.start = start?.clone();
	this.end = end?.clone();
	this.type = type;
}
Line.prototype.length = function() {
	return (this.type == 2/*Segment*/ ? (this.start.distanceTo(this.end)) : Number.POSITIVE_INFINITY);
}
Line.prototype.intersectionWith = function(other) {
	let x1 = this.start.x, y1 = this.start.y;
	let x2 = this.end.x, y2 = this.end.y;
	let typeA = this.type;
	let x3 = other.start.x, y3 = other.start.y;
	let x4 = other.end.x, y4 = other.end.y;
	let typeB = other.type;
	if((x1 == x2 && y1 == y2) || (x3 == x4 && y3 == y4)) {
		return Vector2_none;
	}
	let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if((denominator == 0)) {
		return Vector2_none;
	}
	let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
	if((typeA >= 1/*Ray*/ && ua < 0) || (typeA == 2/*Segment*/ && ua > 1) || (typeB >= 1/*Ray*/ && ub < 0) || (typeB == 2/*Segment*/ && ub > 1)) {
		return Vector2_none;
	}
	return new Vector2(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1), null);
}
Line.prototype.toString = function() {
	object_stringify(this, 3);
	return ""+this.start.x.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" "+this.start.y.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" -> "+this.end.x.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+" "+this.end.y.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false});
}
Line.prototype.clone = function() {
	let clone = new _Line();
	clone.start = this.start.clone();
	clone.end = this.end.clone();
	clone.type = this.type;
	return clone;
}
function _Line() {};
_Line.prototype = Line.prototype;
Line.prototype.serialize_internal = function(buffer) {
	(this.start || new _Vector2()).serialize_internal(buffer);
	(this.end || new _Vector2()).serialize_internal(buffer);
	buffer.writeInt32(this.type);
}
Line.prototype.deserialize_internal = function(buffer) {
	(this.start || (this.start = new _Vector2())).deserialize_internal(buffer);
	(this.end || (this.end = new _Vector2())).deserialize_internal(buffer);
	this.type = buffer.readInt32();
}
Line.prototype.serialize_external = function(buffer) {
	buffer.writeString("start");
	let start_startPos = buffer.reserveSize();
	(this.start || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(start_startPos);
	buffer.writeString("end");
	let end_startPos = buffer.reserveSize();
	(this.end || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(end_startPos);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("");
}
Line.prototype.deserialize_external = function(buffer) {
	let start_is_set = false, end_is_set = false, type_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "start":
				buffer.readInt32();
				(this.start || (this.start = new _Vector2())).deserialize_external(buffer);
				start_is_set = true;
				break;
			case "end":
				buffer.readInt32();
				(this.end || (this.end = new _Vector2())).deserialize_external(buffer);
				end_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!start_is_set) this.start = new Vector2(0.0, 0.0, null);
				if(!end_is_set) this.end = new Vector2(0.0, 0.0, null);
				if(!type_is_set) this.type = 0/*Line*/;
				return;
		}
	}
}
function Rect(position, size) {
	this.position = position?.clone();
	this.size = size?.clone();
}
Rect.prototype.left = function() {
	return this.position.x - this.size.x / 2;
}
Rect.prototype.right = function() {
	return this.position.x + this.size.x / 2;
}
Rect.prototype.top = function() {
	return this.position.y - this.size.y / 2;
}
Rect.prototype.bottom = function() {
	return this.position.y + this.size.y / 2;
}
Rect.prototype.contains = function(position) {
	return Vector2_lessOrEqual_Vector2(Vector2_minus_Vector2(this.position, Vector2_divide_float(this.size, 2)), position) && Vector2_less_Vector2(position, Vector2_plus_Vector2(this.position, Vector2_divide_float(this.size, 2)));
}
Rect.prototype.intersectsWith = function(position, size) {
	return Vector2_lessOrEqual_Vector2(Vector2_minus_Vector2(Vector2_minus_Vector2(this.position, Vector2_divide_float(this.size, 2)), Vector2_divide_float(size, 2)), position) && Vector2_less_Vector2(position, Vector2_plus_Vector2(Vector2_plus_Vector2(this.position, Vector2_divide_float(this.size, 2)), Vector2_divide_float(size, 2)));
}
Rect.prototype.clone = function() {
	let clone = new _Rect();
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	return clone;
}
function _Rect() {};
_Rect.prototype = Rect.prototype;
Rect.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
}
Rect.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
}
Rect.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("");
}
Rect.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function Grid(size, items) {
	this.size = size?.clone();
	this.items = items;
	for(let i=0; i<this.size.x * this.size.y; ++i) {
		this.items.push(null);
	}
}
Grid.prototype.get = function(x, y) {
	return this.items.get(y * this.size.x + x);
}
Grid.prototype.get2 = function(position) {
	if(Vector2_lessOrEqual_Vector2(new Vector2(0, 0), position?.toVector2()) && IntVector2_less_IntVector2(position, this.size)) {
		return this.items.get(position.y * this.size.x + position.x);
	} else {
		return null;
	}
}
Grid.prototype.set = function(x, y, value) {
	this.items.set(y * this.size.x + x, value);
}
Grid.prototype.set2 = function(position, value) {
	this.items.set(position.y * this.size.x + position.x, value);
}
Grid.prototype.count = function(predicate) {
	let count = 0;
	for(let i=0, _subject=this.items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(predicate(it)) {
			count++;
		}
	}}
	return count;
}
Grid.prototype.isValid = function(pos) {
	return Vector2_lessOrEqual_Vector2(new Vector2(0, 0), pos?.toVector2()) && IntVector2_less_IntVector2(pos, this.size);
}
function _Grid() {};
_Grid.prototype = Grid.prototype;
var Color_White;
var Color_Black;
var Color_Red;
var Color_Yellow;
var Color_Green;
var Color_Blue;
var Color_Gray;
var Color_Transparent;
var Color_TransparentRed;
function Color_init() {
	Color_White = new Color("#ffffff", "White");
	Color_Black = new Color("#000000", "Black");
	Color_Red = new Color("#ef476f", "Red");
	Color_Yellow = new Color("#ffd166", "Yellow");
	Color_Green = new Color("#06d6a0", "Green");
	Color_Blue = new Color("#118ab2", "Blue");
	Color_Gray = new Color("#3d3d3d", "Gray");
	Color_Transparent = new Color("#00000000", "Transparent");
	Color_TransparentRed = new Color("#ff000080", "Transparent Red");
}
function Color(hex, name) {
	this.hex = hex;
	this.name = name;
	this.hex = hex;
}
function Color2(red, green, blue, alpha, hex, name) {
	this.hex = hex;
	this.name = name;
	this.hex = "#" + Color_componentToHex(red) + Color_componentToHex(green) + Color_componentToHex(blue) + Color_componentToHex(alpha);
}
Color2.prototype = Color.prototype;
Color.prototype.toString = function() {
	object_stringify(this, 3);
	return this.name || this.hex;
}
function Color_componentToHex(c) {
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}
Color.prototype.withAlpha = function(alpha) {
	return new Color(this.hex.get2(1, 7) + Color_componentToHex(Math.floor(alpha * 255)), "");
}
Color.prototype.clone = function() {
	let clone = new _Color();
	clone.hex = this.hex;
	clone.name = this.name;
	return clone;
}
function _Color() {};
_Color.prototype = Color.prototype;
function Color_serialize_internal(buffer) {
	if(Color_White) {
		var index = _objectCacheIndex.get(Color_White);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_White, index = _objectCache.length);
			_objectCache.push(Color_White);
			buffer.writeInt32(-index);
			Color_White._objectIndex = index;
			Color_White.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Black) {
		var index = _objectCacheIndex.get(Color_Black);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Black, index = _objectCache.length);
			_objectCache.push(Color_Black);
			buffer.writeInt32(-index);
			Color_Black._objectIndex = index;
			Color_Black.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Red) {
		var index = _objectCacheIndex.get(Color_Red);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Red, index = _objectCache.length);
			_objectCache.push(Color_Red);
			buffer.writeInt32(-index);
			Color_Red._objectIndex = index;
			Color_Red.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Yellow) {
		var index = _objectCacheIndex.get(Color_Yellow);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Yellow, index = _objectCache.length);
			_objectCache.push(Color_Yellow);
			buffer.writeInt32(-index);
			Color_Yellow._objectIndex = index;
			Color_Yellow.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Green) {
		var index = _objectCacheIndex.get(Color_Green);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Green, index = _objectCache.length);
			_objectCache.push(Color_Green);
			buffer.writeInt32(-index);
			Color_Green._objectIndex = index;
			Color_Green.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Blue) {
		var index = _objectCacheIndex.get(Color_Blue);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Blue, index = _objectCache.length);
			_objectCache.push(Color_Blue);
			buffer.writeInt32(-index);
			Color_Blue._objectIndex = index;
			Color_Blue.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Gray) {
		var index = _objectCacheIndex.get(Color_Gray);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Gray, index = _objectCache.length);
			_objectCache.push(Color_Gray);
			buffer.writeInt32(-index);
			Color_Gray._objectIndex = index;
			Color_Gray.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_Transparent) {
		var index = _objectCacheIndex.get(Color_Transparent);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Transparent, index = _objectCache.length);
			_objectCache.push(Color_Transparent);
			buffer.writeInt32(-index);
			Color_Transparent._objectIndex = index;
			Color_Transparent.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Color_TransparentRed) {
		var index = _objectCacheIndex.get(Color_TransparentRed);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_TransparentRed, index = _objectCache.length);
			_objectCache.push(Color_TransparentRed);
			buffer.writeInt32(-index);
			Color_TransparentRed._objectIndex = index;
			Color_TransparentRed.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Color_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_White = _objectCache[index];
	} else {
		if(!Color_White || Color_White._objectIndex != -index)
			Color_White = new _Color();
		(_objectCache[-index] = Color_White).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Black = _objectCache[index];
	} else {
		if(!Color_Black || Color_Black._objectIndex != -index)
			Color_Black = new _Color();
		(_objectCache[-index] = Color_Black).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Red = _objectCache[index];
	} else {
		if(!Color_Red || Color_Red._objectIndex != -index)
			Color_Red = new _Color();
		(_objectCache[-index] = Color_Red).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Yellow = _objectCache[index];
	} else {
		if(!Color_Yellow || Color_Yellow._objectIndex != -index)
			Color_Yellow = new _Color();
		(_objectCache[-index] = Color_Yellow).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Green = _objectCache[index];
	} else {
		if(!Color_Green || Color_Green._objectIndex != -index)
			Color_Green = new _Color();
		(_objectCache[-index] = Color_Green).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Blue = _objectCache[index];
	} else {
		if(!Color_Blue || Color_Blue._objectIndex != -index)
			Color_Blue = new _Color();
		(_objectCache[-index] = Color_Blue).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Gray = _objectCache[index];
	} else {
		if(!Color_Gray || Color_Gray._objectIndex != -index)
			Color_Gray = new _Color();
		(_objectCache[-index] = Color_Gray).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_Transparent = _objectCache[index];
	} else {
		if(!Color_Transparent || Color_Transparent._objectIndex != -index)
			Color_Transparent = new _Color();
		(_objectCache[-index] = Color_Transparent).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Color_TransparentRed = _objectCache[index];
	} else {
		if(!Color_TransparentRed || Color_TransparentRed._objectIndex != -index)
			Color_TransparentRed = new _Color();
		(_objectCache[-index] = Color_TransparentRed).deserialize_internal(buffer);
	}
}
Color.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.hex);
	buffer.writeString(this.name);
}
Color.prototype.deserialize_internal = function(buffer) {
	this.hex = buffer.readString();
	this.name = buffer.readString();
}
function Color_serialize_external(buffer) {
	buffer.writeString("White");
	let Color_White_startPos = buffer.reserveSize();
	if(Color_White) {
		var index = _objectCacheIndex.get(Color_White);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_White, index = _objectCache.length);
			_objectCache.push(Color_White);
			buffer.writeInt32(-index);
			Color_White._objectIndex = index;
			Color_White.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_White_startPos);
	buffer.writeString("Black");
	let Color_Black_startPos = buffer.reserveSize();
	if(Color_Black) {
		var index = _objectCacheIndex.get(Color_Black);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Black, index = _objectCache.length);
			_objectCache.push(Color_Black);
			buffer.writeInt32(-index);
			Color_Black._objectIndex = index;
			Color_Black.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Black_startPos);
	buffer.writeString("Red");
	let Color_Red_startPos = buffer.reserveSize();
	if(Color_Red) {
		var index = _objectCacheIndex.get(Color_Red);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Red, index = _objectCache.length);
			_objectCache.push(Color_Red);
			buffer.writeInt32(-index);
			Color_Red._objectIndex = index;
			Color_Red.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Red_startPos);
	buffer.writeString("Yellow");
	let Color_Yellow_startPos = buffer.reserveSize();
	if(Color_Yellow) {
		var index = _objectCacheIndex.get(Color_Yellow);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Yellow, index = _objectCache.length);
			_objectCache.push(Color_Yellow);
			buffer.writeInt32(-index);
			Color_Yellow._objectIndex = index;
			Color_Yellow.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Yellow_startPos);
	buffer.writeString("Green");
	let Color_Green_startPos = buffer.reserveSize();
	if(Color_Green) {
		var index = _objectCacheIndex.get(Color_Green);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Green, index = _objectCache.length);
			_objectCache.push(Color_Green);
			buffer.writeInt32(-index);
			Color_Green._objectIndex = index;
			Color_Green.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Green_startPos);
	buffer.writeString("Blue");
	let Color_Blue_startPos = buffer.reserveSize();
	if(Color_Blue) {
		var index = _objectCacheIndex.get(Color_Blue);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Blue, index = _objectCache.length);
			_objectCache.push(Color_Blue);
			buffer.writeInt32(-index);
			Color_Blue._objectIndex = index;
			Color_Blue.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Blue_startPos);
	buffer.writeString("Gray");
	let Color_Gray_startPos = buffer.reserveSize();
	if(Color_Gray) {
		var index = _objectCacheIndex.get(Color_Gray);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Gray, index = _objectCache.length);
			_objectCache.push(Color_Gray);
			buffer.writeInt32(-index);
			Color_Gray._objectIndex = index;
			Color_Gray.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Gray_startPos);
	buffer.writeString("Transparent");
	let Color_Transparent_startPos = buffer.reserveSize();
	if(Color_Transparent) {
		var index = _objectCacheIndex.get(Color_Transparent);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_Transparent, index = _objectCache.length);
			_objectCache.push(Color_Transparent);
			buffer.writeInt32(-index);
			Color_Transparent._objectIndex = index;
			Color_Transparent.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_Transparent_startPos);
	buffer.writeString("TransparentRed");
	let Color_TransparentRed_startPos = buffer.reserveSize();
	if(Color_TransparentRed) {
		var index = _objectCacheIndex.get(Color_TransparentRed);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Color_TransparentRed, index = _objectCache.length);
			_objectCache.push(Color_TransparentRed);
			buffer.writeInt32(-index);
			Color_TransparentRed._objectIndex = index;
			Color_TransparentRed.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Color_TransparentRed_startPos);
	buffer.writeString("");
}
function Color_deserialize_external(buffer) {
	let White_is_set = false, Black_is_set = false, Red_is_set = false, Yellow_is_set = false, Green_is_set = false, Blue_is_set = false, Gray_is_set = false, Transparent_is_set = false, TransparentRed_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "White":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_White = _objectCache[index];
				} else {
					if(!Color_White || Color_White._objectIndex != -index)
						Color_White = new _Color();
					(_objectCache[-index] = Color_White).deserialize_external(buffer);
				}
				White_is_set = true;
				break;
			case "Black":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Black = _objectCache[index];
				} else {
					if(!Color_Black || Color_Black._objectIndex != -index)
						Color_Black = new _Color();
					(_objectCache[-index] = Color_Black).deserialize_external(buffer);
				}
				Black_is_set = true;
				break;
			case "Red":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Red = _objectCache[index];
				} else {
					if(!Color_Red || Color_Red._objectIndex != -index)
						Color_Red = new _Color();
					(_objectCache[-index] = Color_Red).deserialize_external(buffer);
				}
				Red_is_set = true;
				break;
			case "Yellow":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Yellow = _objectCache[index];
				} else {
					if(!Color_Yellow || Color_Yellow._objectIndex != -index)
						Color_Yellow = new _Color();
					(_objectCache[-index] = Color_Yellow).deserialize_external(buffer);
				}
				Yellow_is_set = true;
				break;
			case "Green":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Green = _objectCache[index];
				} else {
					if(!Color_Green || Color_Green._objectIndex != -index)
						Color_Green = new _Color();
					(_objectCache[-index] = Color_Green).deserialize_external(buffer);
				}
				Green_is_set = true;
				break;
			case "Blue":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Blue = _objectCache[index];
				} else {
					if(!Color_Blue || Color_Blue._objectIndex != -index)
						Color_Blue = new _Color();
					(_objectCache[-index] = Color_Blue).deserialize_external(buffer);
				}
				Blue_is_set = true;
				break;
			case "Gray":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Gray = _objectCache[index];
				} else {
					if(!Color_Gray || Color_Gray._objectIndex != -index)
						Color_Gray = new _Color();
					(_objectCache[-index] = Color_Gray).deserialize_external(buffer);
				}
				Gray_is_set = true;
				break;
			case "Transparent":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_Transparent = _objectCache[index];
				} else {
					if(!Color_Transparent || Color_Transparent._objectIndex != -index)
						Color_Transparent = new _Color();
					(_objectCache[-index] = Color_Transparent).deserialize_external(buffer);
				}
				Transparent_is_set = true;
				break;
			case "TransparentRed":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Color_TransparentRed = _objectCache[index];
				} else {
					if(!Color_TransparentRed || Color_TransparentRed._objectIndex != -index)
						Color_TransparentRed = new _Color();
					(_objectCache[-index] = Color_TransparentRed).deserialize_external(buffer);
				}
				TransparentRed_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!White_is_set) Color_White = new Color("#ffffff", "White");
				if(!Black_is_set) Color_Black = new Color("#000000", "Black");
				if(!Red_is_set) Color_Red = new Color("#ef476f", "Red");
				if(!Yellow_is_set) Color_Yellow = new Color("#ffd166", "Yellow");
				if(!Green_is_set) Color_Green = new Color("#06d6a0", "Green");
				if(!Blue_is_set) Color_Blue = new Color("#118ab2", "Blue");
				if(!Gray_is_set) Color_Gray = new Color("#3d3d3d", "Gray");
				if(!Transparent_is_set) Color_Transparent = new Color("#00000000", "Transparent");
				if(!TransparentRed_is_set) Color_TransparentRed = new Color("#ff000080", "Transparent Red");
				return;
		}
	}
}
Color.prototype.serialize_external = function(buffer) {
	buffer.writeString("hex");
	buffer.writeString(this.hex);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("");
}
Color.prototype.deserialize_external = function(buffer) {
	let hex_is_set = false, name_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "hex":
				this.hex = buffer.readString();
				hex_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!hex_is_set) this.hex = "";
				if(!name_is_set) this.name = "";
				return;
		}
	}
}
function Texture(file, size) {
	this.file = file;
	this.size = size?.clone();
	if(Platform_engineStarted) {
		this.open();
	}
}
Texture.prototype.ensureIsAvailable = function() {
	if(!this._htmlImage) {
		this._htmlImage = _htmlImageCache[this.file]
	}
	return this._htmlImage != null
}
Texture.prototype.open = function() {
	if(!window._htmlImageCache) _htmlImageCache = {}
	let image = _htmlImageCache[this.file]
	if(!image) {
		return new Promise((resolve, reject) => {
			image = new Image()
			image.onload = e => {
				this._htmlImage = image
				window._htmlImageCache[this.file] = image
				this.size = new Vector2(image.width, image.height, null)
				resolve(this);
			}
			image.src = this.file.startsWith("http") ? this.file : _basePath+this.file
		})
	} else {
		this._htmlImage = image
		this.size = new Vector2(image.width, image.height, null)
		return this
	}
}
Texture.prototype.clone = function() {
	let clone = new _Texture();
	clone.file = this.file;
	clone.size = this.size.clone();
	return clone;
}
function _Texture() {};
_Texture.prototype = Texture.prototype;
Texture.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	(this.size || new _Vector2()).serialize_internal(buffer);
}
Texture.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
}
Texture.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("");
}
Texture.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, size_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function ImageFrame(x1, y1, x2, y2, w, h) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
	this.w = w;
	this.h = h;
}
ImageFrame.prototype.clone = function() {
	let clone = new _ImageFrame();
	clone.x1 = this.x1;
	clone.y1 = this.y1;
	clone.x2 = this.x2;
	clone.y2 = this.y2;
	clone.w = this.w;
	clone.h = this.h;
	return clone;
}
function _ImageFrame() {};
_ImageFrame.prototype = ImageFrame.prototype;
ImageFrame.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.x1);
	buffer.writeFloat64(this.y1);
	buffer.writeFloat64(this.x2);
	buffer.writeFloat64(this.y2);
	buffer.writeFloat64(this.w);
	buffer.writeFloat64(this.h);
}
ImageFrame.prototype.deserialize_internal = function(buffer) {
	this.x1 = buffer.readFloat64();
	this.y1 = buffer.readFloat64();
	this.x2 = buffer.readFloat64();
	this.y2 = buffer.readFloat64();
	this.w = buffer.readFloat64();
	this.h = buffer.readFloat64();
}
ImageFrame.prototype.serialize_external = function(buffer) {
	buffer.writeString("x1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x1);
	buffer.writeString("y1");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y1);
	buffer.writeString("x2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.x2);
	buffer.writeString("y2");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.y2);
	buffer.writeString("w");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.w);
	buffer.writeString("h");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.h);
	buffer.writeString("");
}
ImageFrame.prototype.deserialize_external = function(buffer) {
	let x1_is_set = false, y1_is_set = false, x2_is_set = false, y2_is_set = false, w_is_set = false, h_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "x1":
				buffer.readInt32();
				this.x1 = buffer.readFloat64();
				x1_is_set = true;
				break;
			case "y1":
				buffer.readInt32();
				this.y1 = buffer.readFloat64();
				y1_is_set = true;
				break;
			case "x2":
				buffer.readInt32();
				this.x2 = buffer.readFloat64();
				x2_is_set = true;
				break;
			case "y2":
				buffer.readInt32();
				this.y2 = buffer.readFloat64();
				y2_is_set = true;
				break;
			case "w":
				buffer.readInt32();
				this.w = buffer.readFloat64();
				w_is_set = true;
				break;
			case "h":
				buffer.readInt32();
				this.h = buffer.readFloat64();
				h_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!x1_is_set) this.x1 = 0.0;
				if(!y1_is_set) this.y1 = 0.0;
				if(!x2_is_set) this.x2 = 0.0;
				if(!y2_is_set) this.y2 = 0.0;
				if(!w_is_set) this.w = 0.0;
				if(!h_is_set) this.h = 0.0;
				return;
		}
	}
}
function ClippingPath(points, show) {
	this.points = points;
	this.show = show;
}
ClippingPath.prototype.clone = function() {
	let clone = new _ClippingPath();
	clone.points = this.points;
	clone.show = this.show;
	return clone;
}
function _ClippingPath() {};
_ClippingPath.prototype = ClippingPath.prototype;
ClippingPath.prototype.serialize_internal = function(buffer) {
	let points = this.points
	if(points) {
		var index = _objectCacheIndex.get(points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(points, index = _objectCache.length);
			_objectCache.push(points);
			buffer.writeInt32(-index);
			points._objectIndex = index;
			buffer.writeInt32(points.length);
			for(let i=0, len=points.length; i<len; ++i) {
				(points[i] || new _Vector2()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.show);
}
ClippingPath.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.points = _objectCache[index];
	} else {
		let points = this.points
		if(!points || points._objectIndex != -index) this.points = points = [];
		_objectCache[-index] = points;
		for(let i=0, len = points.length = buffer.readInt32(); i<len; ++i) {
				(points[i] || (points[i] = new _Vector2())).deserialize_internal(buffer);
		}
	}
	this.show = buffer.readBool();
}
ClippingPath.prototype.serialize_external = function(buffer) {
	buffer.writeString("points");
	let points = this.points
	let points_startPos = buffer.reserveSize();
	if(points) {
		var index = _objectCacheIndex.get(points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(points, index = _objectCache.length);
			_objectCache.push(points);
			buffer.writeInt32(-index);
			points._objectIndex = index;
			buffer.writeInt32(points.length);
			for(let i=0, len=points.length; i<len; ++i) {
				(points[i] || new _Vector2()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(points_startPos);
	buffer.writeString("show");
	buffer.writeInt32(1);
	buffer.writeBool(this.show);
	buffer.writeString("");
}
ClippingPath.prototype.deserialize_external = function(buffer) {
	let points_is_set = false, show_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "points":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.points = _objectCache[index];
				} else {
					let points = this.points
					if(!points || points._objectIndex != -index) this.points = points = [];
					_objectCache[-index] = points;
					for(let i=0, len = points.length = buffer.readInt32(); i<len; ++i) {
							(points[i] || (points[i] = new _Vector2())).deserialize_external(buffer);
					}
				}
				points_is_set = true;
				break;
			case "show":
				buffer.readInt32();
				this.show = buffer.readBool();
				show_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!points_is_set) this.points = [];
				if(!show_is_set) this.show = false;
				return;
		}
	}
}
var graphics_canvas;
var graphics_context;
var graphics_baseMatrix;
var graphics_totalMatrix;
var graphics_localMatrix;
var graphics_items;
var graphics_alignmentFactor;
var graphics_referenceSize;
var graphics_scaleMode;
var graphics_effectiveScaleMode;
var graphics_anchor;
var graphics_pixelSize;
var graphics_size;
var graphics_pixelRatio;
var graphics_currentClippingPath;
var graphics_currentlyVisibleFor;
var graphics_backgroundColor;
var graphics_defaultColors;
var graphics_currentColor;
var graphics_currentFont;
var graphics_currentFontSize;
var graphics_currentLineWidth;
var graphics_scaleAsPointerGetsCloserBy;
var graphics_scaleAsPointerGetsCloserFactor;
var graphics_scaleAsPointerGetsCloserRadius;
function graphics_init() {
	graphics_canvas = null;
	graphics_context = null;
	graphics_baseMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics_totalMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics_localMatrix = new Matrix2D(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
	graphics_items = [];
	graphics_alignmentFactor = [0, .5, 1];
	graphics_referenceSize = new Vector2(1920, 1080, null);
	graphics_scaleMode = 0/*Auto*/;
	graphics_effectiveScaleMode = 0/*Auto*/;
	graphics_anchor = 2/*Center*/;
	graphics_pixelSize = new Vector2(0.0, 0.0, null);
	graphics_size = new Vector2(0.0, 0.0, null);
	graphics_pixelRatio = 0.0;
	graphics_currentClippingPath = null;
	graphics_currentlyVisibleFor = null;
	graphics_backgroundColor = Color_Black;
	graphics_defaultColors = [new Color("#398CA9", "Blue"), new Color("#C01352", "Red"), new Color("#16C66E", "Green"), new Color("#FFD166", "Yellow")];
	graphics_currentColor = new Color("#ffffff", "");
	graphics_currentFont = null;
	graphics_currentFontSize = 64;
	graphics_currentLineWidth = 8;
	graphics_scaleAsPointerGetsCloserBy = null;
	graphics_scaleAsPointerGetsCloserFactor = 1;
	graphics_scaleAsPointerGetsCloserRadius = 0;
}
async function graphics_setup() {
}
function graphics_onResize() {
	graphics_canvas = document.getElementById("canvas");
	graphics_pixelRatio = window.devicePixelRatio;
	graphics_pixelSize = new Vector2(window.innerWidth*graphics_pixelRatio, window.innerHeight*graphics_pixelRatio, null);
	graphics_isSmallScreen = screen.width < 600 || (localStorage.getItem("smallScreen") == "true")
	graphics_canvas.style.width = window.innerWidth + "px";
	graphics_canvas.style.height = window.innerHeight + "px";
	graphics_canvas.width = graphics_pixelSize.x;
	graphics_canvas.height = graphics_pixelSize.y;
	graphics_canvas.imageSmoothingEnabled = true;
	graphics_canvas.imageSmoothingQuality = "high";
	
	graphics_context = graphics_canvas.getContext("2d");
	graphics_updateBaseMatrix()
}
function graphics_updateBaseMatrix() {
	let statisticsMargin = (Platform_showDebugInfo ? statistics_margin : new Vector2(0.0, 0.0, null))?.clone();
	let referenceSizeWithMargin = Vector2_plus_Vector2(graphics_referenceSize, statisticsMargin);
	let ratio = new Vector2(graphics_pixelSize.x / referenceSizeWithMargin.x, graphics_pixelSize.y / referenceSizeWithMargin.y, null);
	let scale = 0.0;
	if(graphics_scaleMode == 0/*Auto*/) {
		if(ratio.x < ratio.y) {
			graphics_effectiveScaleMode = 1/*FixedWidth*/;
			scale = ratio.x;
		} else {
			graphics_effectiveScaleMode = 2/*FixedHeight*/;
			scale = ratio.y;
		}
		Vector2_assign_Vector2(graphics_size, graphics_referenceSize);
	} else {
		if(graphics_scaleMode == 1/*FixedWidth*/) {
			graphics_effectiveScaleMode = graphics_scaleMode;
			scale = ratio.x;
			Vector2_assign_Vector2(graphics_size, new Vector2(graphics_referenceSize.x, graphics_pixelSize.y / scale, null));
		} else {
			if(graphics_scaleMode == 2/*FixedHeight*/) {
				graphics_effectiveScaleMode = graphics_scaleMode;
				scale = ratio.y;
				Vector2_assign_Vector2(graphics_size, new Vector2(graphics_pixelSize.x / scale, graphics_referenceSize.y, null));
			}
		}
	}
	let offsetX = (graphics_anchor > 0 ? graphics_pixelSize.x / 2 : 0);
	let offsetY = (graphics_anchor > 1 ? graphics_pixelSize.y / 2 : 0);
	Matrix2D_assign_Matrix2D(graphics_baseMatrix, new Matrix2D(scale, 0, 0, scale, offsetX - (statisticsMargin.x / 2) * scale, offsetY - (statisticsMargin.y / 2) * scale));
}
function graphics_startFrame() {
	graphics_reset()
	if(!Platform_fastForward && !Platform_waitingForInitialData)
		if(!graphics_backgroundColor || graphics_backgroundColor.hex == "#000000") {
			graphics_context.clearRect(0, 0, graphics_pixelSize.x, graphics_pixelSize.y)
		} else {
			graphics_context.fillStyle = graphics_backgroundColor.hex
			graphics_context.fillRect(0, 0, graphics_pixelSize.x, graphics_pixelSize.y)
		}
		graphics_context.textBaseline = "top"
}
function graphics_reset() {
	Matrix2D_assign_Matrix2D(graphics_totalMatrix, graphics_baseMatrix);
	graphics_localMatrix.clear();
	graphics_currentlyVisibleFor = null;
	graphics_items.length = 0;
}
function graphics_finishFrame() {
	if(Platform_fastForward) {
		return;
	}
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.videoElementIndex = 0;
		}
	}}
	graphics_drawItems();
	graphics_drawSafeArea();
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null)) {
			for(let i=user.videoElementIndex; i<user.videoElements.length; ++i) {
				PeerNetwork_removeVideoElement(user.videoElements.get(i));
			}
			user.videoElements.setLength(user.videoElementIndex);
			PeerNetwork_setAudioMuted(user.audioElement, core_muteInvisibleUsers && user.videoElementIndex == 0);
		}
	}}
}
function graphics_drawItems() {
	core_displayItems = graphics_items.length;
	gizmo_tick();
	graphics_items.sort((a,b) => b.layer - a.layer);
	for(let _subject=graphics_items, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		it.draw();
	}}
	graphics_resetTransform();
}
function graphics_resetTransform() {
	graphics_context.resetTransform()
	graphics_context.globalAlpha = 1
}
function graphics_isVisibleFor(visibleFor) {
	if(Platform_fastForward) {
		return false;
	}
	let effectiveVisibleFor = visibleFor || graphics_currentlyVisibleFor;
	return effectiveVisibleFor == null || effectiveVisibleFor.some(a => a == null || a.id == input_localUser.id);
}
function graphics_gettouchableBy(visibleFor, touchableBy) {
	let effectiveVisibleBy = visibleFor || graphics_currentlyVisibleFor;
	return ((effectiveVisibleBy != null && effectiveVisibleBy?.length != 0)  && (touchableBy != null && touchableBy?.length != 0)  ? effectiveVisibleBy.intersectWith(touchableBy) : effectiveVisibleBy || touchableBy);
}
function graphics_drawSafeArea() {
	graphics_resetTransform()
	graphics_context.fillStyle = "#404040"
	if(Platform_showSafeArea) {
		if(graphics_effectiveScaleMode == 1) {
			
			let ratio = graphics_pixelSize.x / graphics_referenceSize.x
			let margin = (graphics_pixelSize.y-graphics_referenceSize.y*ratio)/2
			graphics_context.fillRect(0,0,graphics_pixelSize.x, margin)
			graphics_context.fillRect(0,graphics_pixelSize.y-margin,graphics_pixelSize.x, margin)
		} else if(graphics_effectiveScaleMode == 2) {
			
			let ratio = graphics_pixelSize.y / graphics_referenceSize.y
			let margin = (graphics_pixelSize.x-graphics_referenceSize.x*ratio)/2
			graphics_context.fillRect(0, 0, margin, graphics_pixelSize.y)
			graphics_context.fillRect(graphics_pixelSize.x-margin, 0, margin, graphics_pixelSize.y)
		}
	}
}
function graphics_drawImage(image, position, size, visibleFor, frame, layer, alpha, color, align, valign, location) {
	if(!image.texture?.ensureIsAvailable()) return
	if(graphics_isVisibleFor(visibleFor)) {
		let f = image.frames[frame % image.frames.length]
		let sizeX = size.x || f.w
		let sizeY = size.y || (sizeX/f.w)*f.h
		let factor = graphics_getScaleImagesAsPointerGetsCloserFactor(position)
		if(factor > 1) { sizeX *= factor; sizeY *= factor }
		graphics_items.push(new DisplayImage(
			graphics_totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, image.file,
			location, position.location, size.location,
			image.texture._htmlImage,
			f.x1, f.y1, f.w, f.h,
			color
		))
	}
}
function graphics_drawImage2(image, position, size, visibleFor, frame, layer, alpha, color, angle, flipX, flipY, location) {
	if(angle == 0 && !flipX && !flipY) {
		graphics_drawImage(image, position, size, visibleFor, frame, layer, alpha, color, 1, 1, location)
	} else {
		if(!image.texture?.ensureIsAvailable()) return
		if(graphics_isVisibleFor(visibleFor)) {
			let f = image.frames[frame % image.frames.length]
			let sizeX = size.x || f.w
			let sizeY = size.y || (sizeX/f.w)*f.h
			let factor = graphics_getScaleImagesAsPointerGetsCloserFactor(position)
			if(factor > 1) { sizeX *= factor; sizeY *= factor }
			let matrix = graphics_totalMatrix.clone()
			matrix.move(position)
			matrix.rotate(angle)
			if(flipX || flipY) matrix.scale(new Vector2(flipX ? -1:1, flipY ? -1:1 ))
			graphics_items.push(new DisplayImage(
				matrix,
				-sizeX/2,
				-sizeY/2,
				sizeX, sizeY,
				layer, alpha, graphics_currentClippingPath, image.file, 
				location, position.location, size.location,
				image.texture._htmlImage,
				f.x1, f.y1, f.w, f.h,
				color
			))
		}
	}
}
function graphics_drawImage3(image, position, size, visibleFor, framesPerSecond, layer, alpha, color, location) {
	let frame = int_modulo_int(Math.floor(core_frame * Math.max(framesPerSecond, 0) / core_targetFps), image.frames.length);
	graphics_drawImage(image, position, size, visibleFor, frame, layer, alpha, color, 1/*Center*/, 1/*Middle*/, location);
}
function graphics_drawImage4(image, position, size, visibleFor, framesPerSecond, layer, alpha, color, angle, flipX, flipY, location) {
	let frame = int_modulo_int(Math.floor(core_frame * Math.max(framesPerSecond, 0) / core_targetFps), image.frames.length);
	graphics_drawImage2(image, position, size, visibleFor, frame, layer, alpha, color, angle, flipX, flipY, location);
}
function graphics_drawImage5(image, position, size, visibleFor, touchableBy, frame, layer, alpha, color, angle, touchMargin, showTouchArea, hotkey, onTouch, location) {
	graphics_drawImage2(image, position, size, visibleFor, frame, layer, alpha, color, angle, false, false, location);
	let effectivetouchableBy = graphics_gettouchableBy(visibleFor, touchableBy);
	if(size.x == 0 && size.y == 0) {
		Vector2_assign_Vector2(size, image.size);
	} else {
		if(size.y == 0) {
			size.y = size.x * image.size.y / image.size.x;
		}
	}
	input_onTouchDownWithin(position, Vector2_plus_Vector2(size, touchMargin), effectivetouchableBy, "auto", showTouchArea, true, 1/*Center*/, 1/*Middle*/, onTouch);
	if(hotkey) {
		input_onKeyDown(hotkey, effectivetouchableBy, (key,pressedBy) => {
			onTouch(null);
		});
	}
}
function graphics_drawText(text, position, size, color, align, valign, style, font, outlineColor, outlineWidth, visibleFor, layer, alpha, location) {
	if(graphics_isVisibleFor(visibleFor)) {
		let effectiveFont = font || graphics_currentFont
		let fontSize = size.y || size.x || graphics_currentFontSize
		let contextFont = (style ? "bold ":"")+fontSize+"px "+effectiveFont.name;
		graphics_context.font = contextFont
		let textSize = graphics_context.measureText(text)
		let sizeX = textSize.width
		let sizeY = fontSize*effectiveFont.actualHeightFactor
		graphics_items.push(new DisplayText(
			graphics_totalMatrix, 
			position.x - graphics_alignmentFactor[ align]*sizeX,
			position.y - graphics_alignmentFactor[valign]*sizeY,
			sizeX, sizeY, 
			layer, alpha, graphics_currentClippingPath, text, 
			location, position.location, size.location,
			(color || graphics_currentColor).hex, 
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics_currentLineWidth,
			effectiveFont.offset.y*sizeY,
			contextFont
		))
	}
}
function graphics_drawButton(image, text, position, size, frame, textColor, textSize, textOffset, touchMargin, showTouchArea, visibleFor, touchableBy, hotkey, layer, alpha, enabled, alphaWhenDisabled, onTouch, location) {
	if(graphics_isVisibleFor(visibleFor)) {
		let effectiveAlpha = (enabled ? alpha : alpha * alphaWhenDisabled);
		if(text) {
			graphics_drawText(text, Vector2_plus_Vector2(position, textOffset), new Vector2(textSize, 0, null), textColor, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, visibleFor, layer, effectiveAlpha, location);
		}
		if((image != null)) {
			graphics_drawImage(image, position, size, visibleFor, frame, layer, effectiveAlpha, Color_White, 1/*Center*/, 1/*Middle*/, location);
		}
	}
	if(enabled && onTouch != null) {
		let effectivetouchableBy = graphics_gettouchableBy(visibleFor, touchableBy);
		let effectiveSize = ((image != null) ? graphics_getEffectiveSize(image.size, size) : new Vector2(graphics_getTextWidth(text, new Vector2(0.0, 0.0, null), null, 0/*Normal*/), textSize, null))?.clone();
		input_onTouchDownWithin(position, Vector2_plus_Vector2(effectiveSize, touchMargin), effectivetouchableBy, "auto", showTouchArea, true, 1/*Center*/, 1/*Middle*/, onTouch);
		if(hotkey) {
			input_onKeyDown(hotkey, effectivetouchableBy, (key,pressedBy) => {
				onTouch?.(null);
			});
		}
	}
}
function graphics_drawRectangle(position, size, color, outlineColor, outlineWidth, visibleFor, layer, alpha, align, valign, location) {
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics_items.push(new DisplayRectangle(
			graphics_totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, "Rectangle", 
			location, position.location, size.location,
			color || !outlineColor ? (color || graphics_currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics_currentLineWidth
		))
	}
}
function graphics_drawRoundedRectangle(position, size, radius, color, outlineColor, outlineWidth, visibleFor, layer, alpha, align, valign) {
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics_items.push(new DisplayRoundedRectangle(
			graphics_totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, "RoundedRectangle", 
			location, position.location, size.location,
			radius,
			color || !outlineColor ? (color || graphics_currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics_currentLineWidth
		))
	}
}
function graphics_drawCircle(position, size, color, outlineColor, outlineWidth, startAngle, angle, direction, visibleFor, layer, alpha, location) {
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x, sizeY = size.y || size.x
		graphics_items.push(new DisplayCircle(
			graphics_totalMatrix, 
			position.x - sizeX/2, 
			position.y - sizeY/2, 
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, "Circle", 
			location, position.location, size.location,
			startAngle, angle,
			direction == 1,
			color || !outlineColor ? (color || graphics_currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics_currentLineWidth
		))
	}
}
function graphics_drawLine(from, to, color, width, visibleFor, layer, alpha) {
	if(graphics_isVisibleFor(visibleFor)) {
		graphics_items.push(new DisplayLine(
			graphics_totalMatrix,
			from.x, from.y,
			to.x - from.x, to.y - from.y,
			layer, alpha, graphics_currentClippingPath, "Line", 
			location, from.location, null,
			to,
			(color || graphics_currentColor).hex,
			width || graphics_currentLineWidth
		))
	}
}
function graphics_drawLines(points, position, color, width, smooth, visibleFor, layer, alpha) {
	if(graphics_isVisibleFor(visibleFor)) {
		graphics_items.push(new DisplayPolygon(
			graphics_totalMatrix,
			position.x, position.y,
			0, 0,
			layer, alpha, graphics_currentClippingPath, "Line", 
			location, position.location, null,
			points,
			null, 
			(color || graphics_currentColor).hex,
			width || graphics_currentLineWidth,
			smooth, /*close*/false
		))
	}
}
function graphics_drawPolygon(points, position, color, outlineColor, outlineWidth, smooth, visibleFor, layer, alpha) {
	if(graphics_isVisibleFor(visibleFor)) {
		graphics_items.push(new DisplayPolygon(
			graphics_totalMatrix,
			position.x, position.y,
			0, 0,
			layer, alpha, graphics_currentClippingPath, "Polygon", 
			location, position.location, null,
			points,
			color || !outlineColor ? (color || graphics_currentColor).hex : null,
			outlineColor ? outlineColor.hex : null,
			outlineWidth || graphics_currentLineWidth,
			smooth, /*close*/true
		))
	}
}
function graphics_drawVideo(player, position, size, shape, visibleFor, location) {
	if(graphics_isVisibleFor(visibleFor)) {
		if(!size.y) {
			size.y = (shape == 0/*Rectangle*/ ? size.x * 3 / 4 : size.x);
		}
		if(core_mode == 2/*Local*/ || !PeerNetwork_enableVideo) {
			graphics_drawImage(Image_VideoScreen, position, size, null, (shape == 2/*Circle*/ ? 1 : 0), 1000000, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, location);
		} else {
			graphics_items.push(new DisplayVideo(graphics_totalMatrix, position.x, position.y, size.x, size.y, 1000000, 1.0, graphics_currentClippingPath, "Video", null, null, null, player.id, shape));
		}
	}
}
function graphics_drawPointer(player, mode, color) {
	if(mode == 3/*LocalAndRemote*/ || (player == input_localPlayer && mode == 1/*Local*/) || (player != input_localPlayer && mode == 2/*Remote*/)) {
		if(!(color != null)) {
			color = player.color;
		}
		for(let i=0, _subject=player.touches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics_drawImage(Image_finger, Vector2_plus_Vector2(it.smoothPosition, new Vector2(11, 32, null)), new Vector2(0.0, 0.0, null), null, (it.isDown ? 1 : 0), int_maxValue, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
			if((color != null)) {
				if(color.hex == Color_Black.hex) {
					graphics_drawRectangle(Vector2_plus_Vector2(it.smoothPosition, new Vector2(16, 80, null)), new Vector2(26, 10, null), color, new Color("#a0a0a0", ""), 2, null, int_maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
				} else {
					graphics_drawRectangle(Vector2_plus_Vector2(it.smoothPosition, new Vector2(16, 78, null)), new Vector2(26, 10, null), color, null, 0, null, int_maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
				}
			}
		}}
	}
}
function graphics_drawTexture(texture, position, size, visibleFor, layer, alpha, color) {
	if(!texture?.ensureIsAvailable()) return
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x || texture.size.x
		let sizeY = size.y || (sizeX/texture.size.x)*texture.size.y
		graphics_items.push(new DisplayImage(
			graphics_totalMatrix,
			position.x - sizeX/2,
			position.y - sizeY/2,
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, texture.file,
			location, position.location, size.location,
			texture._htmlImage,
			0, 0, texture.size.x, texture.size.y,
			color
		))
	}
}
function graphics_drawTexture2(texture, position, size, sourcePosition, sourceSize, visibleFor, layer, alpha, color) {
	if(!texture?.ensureIsAvailable()) return
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x || texture.size.x
		let sizeY = size.y || (sizeX/texture.size.x)*texture.size.y
		graphics_items.push(new DisplayImage(
			graphics_totalMatrix,
			position.x - sizeX/2,
			position.y - sizeY/2,
			sizeX, sizeY,
			layer, alpha, graphics_currentClippingPath, texture.file, 
			location, position.location, size.location,
			texture._htmlImage,
			sourcePosition.x+texture.size.x/2-sourceSize.x/2,
			sourcePosition.y+texture.size.y/2-sourceSize.y/2,
			sourceSize.x, 
			sourceSize.y,
			color
		))
	}
}
function graphics_clearRectangle(position, size, visibleFor, layer, align, valign) {
	if(graphics_isVisibleFor(visibleFor)) {
		let sizeX = size.x
		let sizeY = size.y || size.x
		graphics_items.push(new DisplayRectangle(
			graphics_totalMatrix,
			align == 0 ? position.x : align == 1 ? position.x-sizeX*.5 : position.x-sizeX,
			valign == 0 ? position.y : valign == 1 ? position.y-sizeY*.5 : position.y-sizeY,
			sizeX, sizeY,
			layer, 1, graphics_currentClippingPath, "Clear", 
			location, position.location, size.location,
			"clear", null, 0
		))
	}
}
function graphics_move(distance, code) {
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5;
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5;
	graphics_localMatrix.move(distance);
	graphics_totalMatrix.move(distance);
	code();
	graphics_localMatrix.m0 = a0;
	graphics_localMatrix.m1 = a1;
	graphics_localMatrix.m2 = a2;
	graphics_localMatrix.m3 = a3;
	graphics_localMatrix.m4 = a4;
	graphics_localMatrix.m5 = a5;
	graphics_totalMatrix.m0 = b0;
	graphics_totalMatrix.m1 = b1;
	graphics_totalMatrix.m2 = b2;
	graphics_totalMatrix.m3 = b3;
	graphics_totalMatrix.m4 = b4;
	graphics_totalMatrix.m5 = b5;
}
function graphics_rotate(angle, code) {
	if(angle==0) {
		code();
		return;
	}
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5;
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5;
	graphics_localMatrix.rotate(angle);
	graphics_totalMatrix.rotate(angle);
	code();
	graphics_localMatrix.m0 = a0;
	graphics_localMatrix.m1 = a1;
	graphics_localMatrix.m2 = a2;
	graphics_localMatrix.m3 = a3;
	graphics_localMatrix.m4 = a4;
	graphics_localMatrix.m5 = a5;
	graphics_totalMatrix.m0 = b0;
	graphics_totalMatrix.m1 = b1;
	graphics_totalMatrix.m2 = b2;
	graphics_totalMatrix.m3 = b3;
	graphics_totalMatrix.m4 = b4;
	graphics_totalMatrix.m5 = b5;
}
function graphics_scale(factor, code) {
	if(factor == 1) {
		code();
		return;
	}
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5;
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5;
	graphics_localMatrix.scale(new Vector2(factor, factor, null));
	graphics_totalMatrix.scale(new Vector2(factor, factor, null));
	code();
	graphics_localMatrix.m0 = a0;
	graphics_localMatrix.m1 = a1;
	graphics_localMatrix.m2 = a2;
	graphics_localMatrix.m3 = a3;
	graphics_localMatrix.m4 = a4;
	graphics_localMatrix.m5 = a5;
	graphics_totalMatrix.m0 = b0;
	graphics_totalMatrix.m1 = b1;
	graphics_totalMatrix.m2 = b2;
	graphics_totalMatrix.m3 = b3;
	graphics_totalMatrix.m4 = b4;
	graphics_totalMatrix.m5 = b5;
}
function graphics_transform(move, rotate, scale, code) {
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5;
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5;
	if(move?.toBool()) {
		graphics_localMatrix.move(move);
		graphics_totalMatrix.move(move);
	}
	if(scale != 1) {
		graphics_localMatrix.scale(new Vector2(scale, scale, null));
		graphics_totalMatrix.scale(new Vector2(scale, scale, null));
	}
	if(rotate) {
		graphics_localMatrix.rotate(rotate);
		graphics_totalMatrix.rotate(rotate);
	}
	code();
	graphics_localMatrix.m0 = a0;
	graphics_localMatrix.m1 = a1;
	graphics_localMatrix.m2 = a2;
	graphics_localMatrix.m3 = a3;
	graphics_localMatrix.m4 = a4;
	graphics_localMatrix.m5 = a5;
	graphics_totalMatrix.m0 = b0;
	graphics_totalMatrix.m1 = b1;
	graphics_totalMatrix.m2 = b2;
	graphics_totalMatrix.m3 = b3;
	graphics_totalMatrix.m4 = b4;
	graphics_totalMatrix.m5 = b5;
}
function graphics_applyMatrix(matrix, code) {
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5;
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5;
	graphics_localMatrix.multiplyLeft(matrix);
	graphics_totalMatrix.multiplyLeft(matrix);
	code();
	graphics_localMatrix.m0 = a0;
	graphics_localMatrix.m1 = a1;
	graphics_localMatrix.m2 = a2;
	graphics_localMatrix.m3 = a3;
	graphics_localMatrix.m4 = a4;
	graphics_localMatrix.m5 = a5;
	graphics_totalMatrix.m0 = b0;
	graphics_totalMatrix.m1 = b1;
	graphics_totalMatrix.m2 = b2;
	graphics_totalMatrix.m3 = b3;
	graphics_totalMatrix.m4 = b4;
	graphics_totalMatrix.m5 = b5;
}
function graphics_clip(points, position, show, code) {
	let prev = graphics_currentClippingPath;
	graphics_currentClippingPath = new ClippingPath([], show);
	for(let i=0, _subject=points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		graphics_currentClippingPath.points.push(Vector2_plus_Vector2(position, it));
	}}
	code();
	graphics_currentClippingPath = prev;
}
function graphics_visibleFor(player, code) {
	let prev = graphics_currentlyVisibleFor;
	graphics_currentlyVisibleFor = player;
	code();
	graphics_currentlyVisibleFor = prev;
	return graphics_currentlyVisibleFor;
}
function graphics_color() {
	return graphics_currentColor;
}
function graphics_color2(color) {
	graphics_currentColor = color;
	return graphics_currentColor;
}
function graphics_color3(color, code) {
	let prev = graphics_currentColor;
	graphics_currentColor = color;
	code();
	graphics_currentColor = prev;
	return graphics_currentColor;
}
function graphics_font() {
	return graphics_currentFont;
}
function graphics_font2(font) {
	graphics_currentFont = font;
	return graphics_currentFont;
}
function graphics_font3(font, code) {
	let prev = graphics_currentFont;
	graphics_currentFont = font;
	code();
	graphics_currentFont = prev;
	return graphics_currentFont;
}
function graphics_fontSize() {
	return graphics_currentFontSize;
}
function graphics_fontSize2(fontSize) {
	graphics_currentFontSize = fontSize;
	return graphics_currentFontSize;
}
function graphics_fontSize3(fontSize, code) {
	let prev = graphics_currentFontSize;
	graphics_currentFontSize = fontSize;
	code();
	graphics_currentFontSize = prev;
	return graphics_currentFontSize;
}
function graphics_lineWidth() {
	return graphics_currentLineWidth;
}
function graphics_lineWidth2(lineWidth) {
	graphics_currentLineWidth = lineWidth;
	return graphics_currentLineWidth;
}
function graphics_lineWidth3(lineWidth, code) {
	let prev = graphics_currentLineWidth;
	graphics_currentLineWidth = lineWidth;
	code();
	graphics_currentLineWidth = prev;
	return graphics_currentLineWidth;
}
function graphics_getTextWidth(text, size, font, style) {
	let effectiveFont = font || graphics_currentFont
	let fontSize = size.y || size.x || graphics_currentFontSize
	graphics_context.font = (style ? "bold ":"")+fontSize+"px "+effectiveFont.name;
	let textSize = graphics_context.measureText(text)
	return textSize.width
}
function graphics_getAbsolutPosition(position) {
	return position.getTransformed(graphics_localMatrix);
}
function graphics_getPixelPosition(position) {
	return Vector2_divide_float(position.getTransformed(graphics_totalMatrix), graphics_pixelRatio);
}
function graphics_getPixelSize(size) {
	return Vector2_divide_float(Vector2_multiply_Vector2(size, new Vector2(graphics_totalMatrix.m0, graphics_totalMatrix.m3, null)), graphics_pixelRatio);
}
function graphics_getEffectiveSize(imageSize, size) {
	let sizeX = size.x || imageSize.x;
	let sizeY = size.y || (sizeX / imageSize.x) * imageSize.y;
	return new Vector2(sizeX, sizeY, null);
}
function graphics_scaleImagesAsPointerGetsCloser(by, factor, radius, $do) {
	let prevBy = graphics_scaleAsPointerGetsCloserBy;
	let prevFactor = graphics_scaleAsPointerGetsCloserFactor;
	let prevRadius = graphics_scaleAsPointerGetsCloserRadius;
	graphics_scaleAsPointerGetsCloserBy = by;
	graphics_scaleAsPointerGetsCloserFactor = factor;
	graphics_scaleAsPointerGetsCloserRadius = radius;
	$do();
	graphics_scaleAsPointerGetsCloserBy = prevBy;
	graphics_scaleAsPointerGetsCloserFactor = prevFactor;
	graphics_scaleAsPointerGetsCloserRadius = prevRadius;
}
function graphics_getScaleImagesAsPointerGetsCloserFactor(position) {
	if(!graphics_scaleAsPointerGetsCloserRadius) {
		return 1.0;
	}
	let distance = ((graphics_scaleAsPointerGetsCloserBy != null) ? graphics_scaleAsPointerGetsCloserBy.pointerPosition.distanceTo(position) : input_players.min2(a => a.pointerPosition.distanceTo(position), Number.MAX_VALUE, 0));
	return math_map3(distance, 0, graphics_scaleAsPointerGetsCloserRadius, graphics_scaleAsPointerGetsCloserFactor, 1);
}
function graphics_createImage(size, file, code) {
	let prevContext = graphics_context
	let prevPixelSizeX = graphics_pixelSize.x
	let prevPixelSizeY = graphics_pixelSize.y
	let prevItems = graphics_items
	graphics_items = []
	let canvas = document.createElement("canvas")
	canvas.width = size.x
	canvas.height = size.y
	graphics_context = canvas.getContext("2d")
	graphics_pixelSize.x = size.x
	graphics_pixelSize.y = size.y
	let a = graphics_localMatrix.matrix, b = graphics_totalMatrix.matrix
	let a0 = graphics_localMatrix.m0, a1 = graphics_localMatrix.m1, a2 = graphics_localMatrix.m2, a3 = graphics_localMatrix.m3, a4 = graphics_localMatrix.m4, a5 = graphics_localMatrix.m5
	let b0 = graphics_totalMatrix.m0, b1 = graphics_totalMatrix.m1, b2 = graphics_totalMatrix.m2, b3 = graphics_totalMatrix.m3, b4 = graphics_totalMatrix.m4, b5 = graphics_totalMatrix.m5
	graphics_localMatrix.set(1, 0, 0, 1, -size.x/2, -size.y/2)
	graphics_totalMatrix.set(1, 0, 0, 1, size.x/2, size.y/2)
	code()
	graphics_drawItems()
	var dataUrl = canvas.toDataURL("image/png");
	if(file) file_saveImage(dataUrl, file);
	graphics_localMatrix.m0 = a0; graphics_localMatrix.m1 = a1; graphics_localMatrix.m2 = a2; graphics_localMatrix.m3 = a3; graphics_localMatrix.m4 = a4; graphics_localMatrix.m5 = a5
	graphics_totalMatrix.m0 = b0; graphics_totalMatrix.m1 = b1; graphics_totalMatrix.m2 = b2; graphics_totalMatrix.m3 = b3; graphics_totalMatrix.m4 = b4; graphics_totalMatrix.m5 = b5
	graphics_context = prevContext
	graphics_pixelSize.x = prevPixelSizeX
	graphics_pixelSize.y = prevPixelSizeY
	graphics_items = prevItems
	return dataUrl
}
function graphics_accessPixel(code) {
	let imageData = graphics_context.getImageData(0,0,graphics_pixelSize.x, graphics_pixelSize.y)
	code(imageData.data)
	graphics_context.putImageData(imageData, 0, 0)
}
function graphics_setPlayerVideo(player, pos, size, shape) {
	let videoObject = graphics_getVideoObject(player);
	if(!(videoObject != null)) {
		videoObject = new VideoObject(new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), 1, null, 0, false, null, player, 0/*Rectangle*/);
	}
	Vector2_assign_Vector2(videoObject.position, pos);
	Vector2_assign_Vector2(videoObject.size, size);
	videoObject.shape = shape;
	videoObject.locked = true;
}
function graphics_getVideoObject(player) {
	for(let i=0, _subject=Framework_objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(it.type == "VideoObject") {
			let v = it;
			if(v.player.id == player.id) {
				return v;
			}
		}
	}}
	return null;
}
function GizomInfluence(file, start, end, deltas, initialValues, label) {
	this.file = file;
	this.start = start;
	this.end = end;
	this.deltas = deltas;
	this.initialValues = initialValues;
	this.label = label;
}
GizomInfluence.prototype.clone = function() {
	let clone = new _GizomInfluence();
	clone.file = this.file;
	clone.start = this.start;
	clone.end = this.end;
	clone.deltas = this.deltas;
	clone.initialValues = this.initialValues;
	clone.label = this.label;
	return clone;
}
function _GizomInfluence() {};
_GizomInfluence.prototype = GizomInfluence.prototype;
GizomInfluence.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	buffer.writeInt32(this.start);
	buffer.writeInt32(this.end);
	let deltas = this.deltas
	if(deltas) {
		var index = _objectCacheIndex.get(deltas);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(deltas, index = _objectCache.length);
			_objectCache.push(deltas);
			buffer.writeInt32(-index);
			deltas._objectIndex = index;
			buffer.writeInt32(deltas.length);
			for(let i=0, len=deltas.length; i<len; ++i) {
				buffer.writeFloat64(deltas[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let initialValues = this.initialValues
	if(initialValues) {
		var index = _objectCacheIndex.get(initialValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(initialValues, index = _objectCache.length);
			_objectCache.push(initialValues);
			buffer.writeInt32(-index);
			initialValues._objectIndex = index;
			buffer.writeInt32(initialValues.length);
			for(let i=0, len=initialValues.length; i<len; ++i) {
				buffer.writeFloat64(initialValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.label);
}
GizomInfluence.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	this.start = buffer.readInt32();
	this.end = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.deltas = _objectCache[index];
	} else {
		let deltas = this.deltas
		if(!deltas || deltas._objectIndex != -index) this.deltas = deltas = [];
		_objectCache[-index] = deltas;
		for(let i=0, len = deltas.length = buffer.readInt32(); i<len; ++i) {
				deltas[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.initialValues = _objectCache[index];
	} else {
		let initialValues = this.initialValues
		if(!initialValues || initialValues._objectIndex != -index) this.initialValues = initialValues = [];
		_objectCache[-index] = initialValues;
		for(let i=0, len = initialValues.length = buffer.readInt32(); i<len; ++i) {
				initialValues[i] = buffer.readFloat64();
		}
	}
	this.label = buffer.readString();
}
GizomInfluence.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("start");
	buffer.writeInt32(4);
	buffer.writeInt32(this.start);
	buffer.writeString("end");
	buffer.writeInt32(4);
	buffer.writeInt32(this.end);
	buffer.writeString("deltas");
	let deltas = this.deltas
	let deltas_startPos = buffer.reserveSize();
	if(deltas) {
		var index = _objectCacheIndex.get(deltas);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(deltas, index = _objectCache.length);
			_objectCache.push(deltas);
			buffer.writeInt32(-index);
			deltas._objectIndex = index;
			buffer.writeInt32(deltas.length);
			for(let i=0, len=deltas.length; i<len; ++i) {
				buffer.writeFloat64(deltas[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(deltas_startPos);
	buffer.writeString("initialValues");
	let initialValues = this.initialValues
	let initialValues_startPos = buffer.reserveSize();
	if(initialValues) {
		var index = _objectCacheIndex.get(initialValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(initialValues, index = _objectCache.length);
			_objectCache.push(initialValues);
			buffer.writeInt32(-index);
			initialValues._objectIndex = index;
			buffer.writeInt32(initialValues.length);
			for(let i=0, len=initialValues.length; i<len; ++i) {
				buffer.writeFloat64(initialValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(initialValues_startPos);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("");
}
GizomInfluence.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, start_is_set = false, end_is_set = false, deltas_is_set = false, initialValues_is_set = false, label_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "start":
				buffer.readInt32();
				this.start = buffer.readInt32();
				start_is_set = true;
				break;
			case "end":
				buffer.readInt32();
				this.end = buffer.readInt32();
				end_is_set = true;
				break;
			case "deltas":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.deltas = _objectCache[index];
				} else {
					let deltas = this.deltas
					if(!deltas || deltas._objectIndex != -index) this.deltas = deltas = [];
					_objectCache[-index] = deltas;
					for(let i=0, len = deltas.length = buffer.readInt32(); i<len; ++i) {
							deltas[i] = buffer.readFloat64();
					}
				}
				deltas_is_set = true;
				break;
			case "initialValues":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.initialValues = _objectCache[index];
				} else {
					let initialValues = this.initialValues
					if(!initialValues || initialValues._objectIndex != -index) this.initialValues = initialValues = [];
					_objectCache[-index] = initialValues;
					for(let i=0, len = initialValues.length = buffer.readInt32(); i<len; ++i) {
							initialValues[i] = buffer.readFloat64();
					}
				}
				initialValues_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!start_is_set) this.start = 0;
				if(!end_is_set) this.end = 0;
				if(!deltas_is_set) this.deltas = [];
				if(!initialValues_is_set) this.initialValues = [];
				if(!label_is_set) this.label = "";
				return;
		}
	}
}
function GizmoOverItem(item, location) {
	this.item = item;
	this.location = location;
}
GizmoOverItem.prototype.clone = function() {
	let clone = new _GizmoOverItem();
	clone.item = this.item;
	clone.location = this.location;
	return clone;
}
function _GizmoOverItem() {};
_GizmoOverItem.prototype = GizmoOverItem.prototype;
GizmoOverItem.prototype.serialize_internal = function(buffer) {
}
GizmoOverItem.prototype.deserialize_internal = function(buffer) {
}
GizmoOverItem.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
GizmoOverItem.prototype.deserialize_external = function(buffer) {
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				return;
		}
	}
}
var gizmo_items;
var gizmo_min;
var gizmo_max;
var gizmo_cursorLocation;
var gizmo_cursorItem;
var gizmo_handleSize;
var gizmo_overHandleDirection;
var gizmo_touchDownPos;
var gizmo_touchDownInsideGizmo;
var gizmo_locationIndex;
var gizmo_waitingForCodeId;
var gizmo_aspectRatio;
var gizmo_isManipulating;
function gizmo_init() {
	gizmo_items = [];
	gizmo_min = new Vector2(0.0, 0.0, null);
	gizmo_max = new Vector2(0.0, 0.0, null);
	gizmo_cursorLocation = null;
	gizmo_cursorItem = null;
	gizmo_handleSize = 0.0;
	gizmo_overHandleDirection = null;
	gizmo_touchDownPos = new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
	gizmo_touchDownInsideGizmo = false;
	gizmo_locationIndex = 0;
	gizmo_waitingForCodeId = 0;
	gizmo_aspectRatio = 0.0;
	gizmo_isManipulating = false;
}
function gizmo_findInfluencedItems() {
	gizmo_items.length = 0;
	gizmo_cursorLocation = null;
	if(!window._cursorFile) {
		return;
	}
	for(let i=0, _subject=graphics_items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it.positionLocation != null) && ((gizmo_cursorLocation = it.positionLocation.find(_cursorFile, _cursorPos)) != null)) {
			gizmo_cursorItem = it;
			break;
		}
		if((it.location != null) && it.location.file == _cursorFile && _cursorPos >= it.location.start && _cursorPos <= it.location.end) {
			gizmo_cursorLocation = it.positionLocation?.leaf() || it.location;
			gizmo_cursorItem = it;
			break;
		}
	}}
	gizmo_min.x = Number.MAX_VALUE;
	gizmo_max.x = -Number.MAX_VALUE;
	gizmo_min.y = Number.MAX_VALUE;
	gizmo_max.y = -Number.MAX_VALUE;
	if(gizmo_cursorLocation != null) {
		for(let i=0, _subject=graphics_items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.location == gizmo_cursorLocation || it.positionLocation?.find2(gizmo_cursorLocation) != null) {
				gizmo_items.push(it);
				if(it.x < gizmo_min.x) {
					gizmo_min.x = it.x;
				}
				if(it.y < gizmo_min.y) {
					gizmo_min.y = it.y;
				}
				if(it.x + it.w > gizmo_max.x) {
					gizmo_max.x = it.x + it.w;
				}
				if(it.y + it.h > gizmo_max.y) {
					gizmo_max.y = it.y + it.h;
				}
			}
		}}
	}
	gizmo_handleSize = math_map3(Math.min(gizmo_max.x - gizmo_min.x, gizmo_max.y - gizmo_min.y), 64, 256, 16, 32);
}
function gizmo_tick() {
	if(Platform_mode != 1/*Manipulator*/) {
		return;
	}
	gizmo_findInfluencedItems();
	if((gizmo_items != null && gizmo_items?.length != 0) ) {
		let size = Vector2_minus_Vector2(gizmo_max, gizmo_min);
		let center = Vector2_divide_float((Vector2_plus_Vector2(gizmo_max, gizmo_min)), 2);
		for(let i=0, _subject=Direction_allDirections, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics_drawImage(Image_ResizeHandle, Vector2_plus_Vector2(center, Vector2_multiply_Vector2(Vector2_divide_float(size, 2), it.vector?.toVector2())), new Vector2(gizmo_handleSize, 0, null), null, 0, int_maxValue, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
		}}
		graphics_drawRectangle(center, Vector2_minus_Vector2(gizmo_max, gizmo_min), null, new Color("#437FDF", ""), 4, null, int_maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
	}
}
function gizmo_clear() {
	gizmo_overHandleDirection = null;
	Vector2_assign_Vector2(gizmo_touchDownPos, Vector2_none);
	gizmo_touchDownInsideGizmo = false;
	gizmo_locationIndex = 0;
	gizmo_waitingForCodeId = 0;
	gizmo_aspectRatio = 1;
	gizmo_items.length = 0;
	Vector2_assign_Vector2(gizmo_min, Vector2_none);
	Vector2_assign_Vector2(gizmo_max, Vector2_none);
}
function gizmo_onTouch(InputType, id, pixelPos, referencePos, shift, alt, cmdOrCtrl) {
	if(Platform_mode != 1/*Manipulator*/) {
		return;
	}
	let movedSinceTouchDown = (referencePos.manhattanDistanceTo(gizmo_touchDownPos)) > 8;
	let insideGizmo = Vector2_greaterOrEqual_Vector2(referencePos, gizmo_min) && Vector2_lessOrEqual_Vector2(referencePos, gizmo_max);
	if(InputType == 1/*TouchDown*/) {
		Vector2_assign_Vector2(gizmo_touchDownPos, referencePos);
		gizmo_touchDownInsideGizmo = insideGizmo;
	} else {
		if(InputType == 3/*TouchUp*/) {
			Vector2_assign_Vector2(gizmo_touchDownPos, Vector2_none);
			gizmo_isManipulating = false;
		}
	}
	if((gizmo_items != null && gizmo_items?.length != 0)  && !gizmo_touchDownPos?.toBool()) {
		let center = Vector2_divide_float((Vector2_plus_Vector2(gizmo_min, gizmo_max)), 2);
		if(referencePos.manhattanDistanceTo(gizmo_max) < gizmo_handleSize) {
			gizmo_overHandleDirection = Direction_DownRight;
		} else {
			if(referencePos.manhattanDistanceTo(gizmo_min) < gizmo_handleSize) {
				gizmo_overHandleDirection = Direction_UpLeft;
			} else {
				if(referencePos.manhattanDistanceTo(new Vector2(gizmo_max.x, gizmo_min.y, null)) < gizmo_handleSize) {
					gizmo_overHandleDirection = Direction_UpRight;
				} else {
					if(referencePos.manhattanDistanceTo(new Vector2(gizmo_min.x, gizmo_max.y, null)) < gizmo_handleSize) {
						gizmo_overHandleDirection = Direction_DownLeft;
					} else {
						if(referencePos.manhattanDistanceTo(new Vector2(gizmo_max.x, center.y, null)) < gizmo_handleSize) {
							gizmo_overHandleDirection = Direction_Right;
						} else {
							if(referencePos.manhattanDistanceTo(new Vector2(gizmo_min.x, center.y, null)) < gizmo_handleSize) {
								gizmo_overHandleDirection = Direction_Left;
							} else {
								if(referencePos.manhattanDistanceTo(new Vector2(center.x, gizmo_min.y, null)) < gizmo_handleSize) {
									gizmo_overHandleDirection = Direction_Up;
								} else {
									if(referencePos.manhattanDistanceTo(new Vector2(center.x, gizmo_max.y, null)) < gizmo_handleSize) {
										gizmo_overHandleDirection = Direction_Down;
									} else {
										gizmo_overHandleDirection = null;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(!(gizmo_overHandleDirection != null) && _codeId >= gizmo_waitingForCodeId) {
		if((InputType == 1/*TouchDown*/ && !insideGizmo) || (InputType == 3/*TouchUp*/ && gizmo_touchDownInsideGizmo && !movedSinceTouchDown)) {
			let overItems = [];
			for(let i=0, _subject=graphics_items, _len=_subject.length; i<_len; ++i) { let item = _subject[i]; {
				if(pixelPos.isInsidePoygon(item.poly)) {
					if((item.positionLocation != null)) {
						gizmo_flattenLocations(overItems, item, item.positionLocation);
					} else {
						if((item.location != null)) {
							overItems.push(new GizmoOverItem(item, item.location));
						}
					}
				}
			}}
			if(overItems.length) {
				if(InputType == 1/*TouchDown*/) {
					gizmo_locationIndex = 0;
				}
				let selectedStackItem = overItems.get(int_modulo_int(gizmo_locationIndex++, overItems.length));
				gizmo_cursorLocation = selectedStackItem.location;
				gizmo_cursorItem = selectedStackItem.item;
				Platform_sendSelectToEditor(gizmo_cursorLocation.file, gizmo_cursorLocation.start);
			} else {
				gizmo_locationIndex = 0;
				gizmo_cursorLocation = null;
				Platform_sendDeselectToEditor();
			}
		}
	}
	if((gizmo_cursorLocation != null)) {
		let influences = [];
		if((gizmo_overHandleDirection != null)) {
			let handle = gizmo_overHandleDirection.vector?.clone();
			let isOrthogonal = handle.x == 0 || handle.y == 0;
			let dx = (referencePos.x - gizmo_touchDownPos.x) * handle.x;
			let dy = (referencePos.y - gizmo_touchDownPos.y) * handle.y;
			let deltas = (shift || isOrthogonal ? [dx, dy] : (gizmo_aspectRatio < 1 ? [dx, dx * gizmo_aspectRatio] : [dy / gizmo_aspectRatio, dy]));
			gizmo_setCursor((isOrthogonal ? ((handle.y == 0 ? "ew-resize" : "ns-resize")) : ((handle.x == handle.y ? "nwse-resize" : "nesw-resize"))));
			for(let i=0, _subject=gizmo_items, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				if((it.sizeLocation != null)) {
					influences.push(new GizomInfluence(it.sizeLocation.file, it.sizeLocation.start, it.sizeLocation.end, deltas, [], ""));
				} else {
					influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.start, gizmo_cursorLocation.end, deltas, [it.w, it.h], "size"));
				}
			}}
			if(!cmdOrCtrl) {
				if(gizmo_cursorItem.location != gizmo_cursorLocation) {
					influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.start, gizmo_cursorLocation.end, [.5 * deltas.get(0) * handle.x, .5 * deltas.get(1) * handle.y], [], ""));
				} else {
					influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.end, gizmo_cursorLocation.end, [.5 * deltas.get(0) * handle.x, .5 * deltas.get(1) * handle.y], [0, 0], "position"));
				}
			} else {
				if(gizmo_cursorItem.location != gizmo_cursorLocation) {
					influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.start, gizmo_cursorLocation.end, [0, 0], [], ""));
				}
			}
		} else {
			gizmo_setCursor("auto");
			if(gizmo_cursorItem.location != gizmo_cursorLocation) {
				influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.start, gizmo_cursorLocation.end, [referencePos.x - gizmo_touchDownPos.x, referencePos.y - gizmo_touchDownPos.y], [], ""));
			} else {
				influences.push(new GizomInfluence(gizmo_cursorLocation.file, gizmo_cursorLocation.end, gizmo_cursorLocation.end, [referencePos.x - gizmo_touchDownPos.x, referencePos.y - gizmo_touchDownPos.y], [0, 0], "position"));
			}
		}
		if(InputType == 2/*TouchMove*/ && gizmo_touchDownPos?.toBool() && _codeId >= gizmo_waitingForCodeId) {
			if(!gizmo_isManipulating && movedSinceTouchDown) {
				gizmo_isManipulating = true;
				gizmo_aspectRatio = (gizmo_max.y - gizmo_min.y) / (gizmo_max.x - gizmo_min.x);
				Platform_sendStartManipulationToEditor(influences);
			}
			if(gizmo_isManipulating) {
				Platform_sendMoveManipulationToEditor(influences, ++gizmo_waitingForCodeId);
			}
		}
	}
}
function gizmo_setCursor(cursor) {
	document.body.style.cursor = cursor
}
function gizmo_flattenLocations(stack, item, location) {
	if(location.file) {
		stack.push(new GizmoOverItem(item, location));
	}
	if((location.right != null)) {
		gizmo_flattenLocations(stack, item, location.right);
	}
	if((location.left != null)) {
		gizmo_flattenLocations(stack, item, location.left);
	}
}
function gizmo_serialize_internal(buffer) {
	if(gizmo_items) {
		var index = _objectCacheIndex.get(gizmo_items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(gizmo_items, index = _objectCache.length);
			_objectCache.push(gizmo_items);
			buffer.writeInt32(-index);
			gizmo_items._objectIndex = index;
			buffer.writeInt32(gizmo_items.length);
			for(let i=0, len=gizmo_items.length; i<len; ++i) {
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	(gizmo_min || new _Vector2()).serialize_internal(buffer);
	(gizmo_max || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(gizmo_handleSize);
	if(gizmo_overHandleDirection) {
		var index = _objectCacheIndex.get(gizmo_overHandleDirection);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(gizmo_overHandleDirection, index = _objectCache.length);
			_objectCache.push(gizmo_overHandleDirection);
			buffer.writeInt32(-index);
			gizmo_overHandleDirection._objectIndex = index;
			gizmo_overHandleDirection.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	(gizmo_touchDownPos || new _Vector2()).serialize_internal(buffer);
	buffer.writeBool(gizmo_touchDownInsideGizmo);
	buffer.writeInt32(gizmo_locationIndex);
	buffer.writeInt32(gizmo_waitingForCodeId);
	buffer.writeFloat64(gizmo_aspectRatio);
	buffer.writeBool(gizmo_isManipulating);
}
function gizmo_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		gizmo_items = _objectCache[index];
	} else {
		if(!gizmo_items || gizmo_items._objectIndex != -index) gizmo_items = [];
		_objectCache[-index] = gizmo_items;
		for(let i=0, len = gizmo_items.length = buffer.readInt32(); i<len; ++i) {
		}
	}
	(gizmo_min || (gizmo_min = new _Vector2())).deserialize_internal(buffer);
	(gizmo_max || (gizmo_max = new _Vector2())).deserialize_internal(buffer);
	gizmo_handleSize = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		gizmo_overHandleDirection = _objectCache[index];
	} else {
		if(!gizmo_overHandleDirection || gizmo_overHandleDirection._objectIndex != -index)
			gizmo_overHandleDirection = new _Direction();
		(_objectCache[-index] = gizmo_overHandleDirection).deserialize_internal(buffer);
	}
	(gizmo_touchDownPos || (gizmo_touchDownPos = new _Vector2())).deserialize_internal(buffer);
	gizmo_touchDownInsideGizmo = buffer.readBool();
	gizmo_locationIndex = buffer.readInt32();
	gizmo_waitingForCodeId = buffer.readInt32();
	gizmo_aspectRatio = buffer.readFloat64();
	gizmo_isManipulating = buffer.readBool();
}
function gizmo_serialize_external(buffer) {
	buffer.writeString("items");
	let gizmo_items_startPos = buffer.reserveSize();
	if(gizmo_items) {
		var index = _objectCacheIndex.get(gizmo_items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(gizmo_items, index = _objectCache.length);
			_objectCache.push(gizmo_items);
			buffer.writeInt32(-index);
			gizmo_items._objectIndex = index;
			buffer.writeInt32(gizmo_items.length);
			for(let i=0, len=gizmo_items.length; i<len; ++i) {
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(gizmo_items_startPos);
	buffer.writeString("min");
	let gizmo_min_startPos = buffer.reserveSize();
	(gizmo_min || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(gizmo_min_startPos);
	buffer.writeString("max");
	let gizmo_max_startPos = buffer.reserveSize();
	(gizmo_max || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(gizmo_max_startPos);
	buffer.writeString("handleSize");
	buffer.writeInt32(8);
	buffer.writeFloat64(gizmo_handleSize);
	buffer.writeString("overHandleDirection");
	let gizmo_overHandleDirection_startPos = buffer.reserveSize();
	if(gizmo_overHandleDirection) {
		var index = _objectCacheIndex.get(gizmo_overHandleDirection);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(gizmo_overHandleDirection, index = _objectCache.length);
			_objectCache.push(gizmo_overHandleDirection);
			buffer.writeInt32(-index);
			gizmo_overHandleDirection._objectIndex = index;
			gizmo_overHandleDirection.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(gizmo_overHandleDirection_startPos);
	buffer.writeString("touchDownPos");
	let gizmo_touchDownPos_startPos = buffer.reserveSize();
	(gizmo_touchDownPos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(gizmo_touchDownPos_startPos);
	buffer.writeString("touchDownInsideGizmo");
	buffer.writeInt32(1);
	buffer.writeBool(gizmo_touchDownInsideGizmo);
	buffer.writeString("locationIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(gizmo_locationIndex);
	buffer.writeString("waitingForCodeId");
	buffer.writeInt32(4);
	buffer.writeInt32(gizmo_waitingForCodeId);
	buffer.writeString("aspectRatio");
	buffer.writeInt32(8);
	buffer.writeFloat64(gizmo_aspectRatio);
	buffer.writeString("isManipulating");
	buffer.writeInt32(1);
	buffer.writeBool(gizmo_isManipulating);
	buffer.writeString("");
}
function gizmo_deserialize_external(buffer) {
	let items_is_set = false, min_is_set = false, max_is_set = false, handleSize_is_set = false, overHandleDirection_is_set = false, touchDownPos_is_set = false, touchDownInsideGizmo_is_set = false, locationIndex_is_set = false, waitingForCodeId_is_set = false, aspectRatio_is_set = false, isManipulating_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "items":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					gizmo_items = _objectCache[index];
				} else {
					if(!gizmo_items || gizmo_items._objectIndex != -index) gizmo_items = [];
					_objectCache[-index] = gizmo_items;
					for(let i=0, len = gizmo_items.length = buffer.readInt32(); i<len; ++i) {
					}
				}
				items_is_set = true;
				break;
			case "min":
				buffer.readInt32();
				(gizmo_min || (gizmo_min = new _Vector2())).deserialize_external(buffer);
				min_is_set = true;
				break;
			case "max":
				buffer.readInt32();
				(gizmo_max || (gizmo_max = new _Vector2())).deserialize_external(buffer);
				max_is_set = true;
				break;
			case "handleSize":
				buffer.readInt32();
				gizmo_handleSize = buffer.readFloat64();
				handleSize_is_set = true;
				break;
			case "overHandleDirection":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					gizmo_overHandleDirection = _objectCache[index];
				} else {
					if(!gizmo_overHandleDirection || gizmo_overHandleDirection._objectIndex != -index)
						gizmo_overHandleDirection = new _Direction();
					(_objectCache[-index] = gizmo_overHandleDirection).deserialize_external(buffer);
				}
				overHandleDirection_is_set = true;
				break;
			case "touchDownPos":
				buffer.readInt32();
				(gizmo_touchDownPos || (gizmo_touchDownPos = new _Vector2())).deserialize_external(buffer);
				touchDownPos_is_set = true;
				break;
			case "touchDownInsideGizmo":
				buffer.readInt32();
				gizmo_touchDownInsideGizmo = buffer.readBool();
				touchDownInsideGizmo_is_set = true;
				break;
			case "locationIndex":
				buffer.readInt32();
				gizmo_locationIndex = buffer.readInt32();
				locationIndex_is_set = true;
				break;
			case "waitingForCodeId":
				buffer.readInt32();
				gizmo_waitingForCodeId = buffer.readInt32();
				waitingForCodeId_is_set = true;
				break;
			case "aspectRatio":
				buffer.readInt32();
				gizmo_aspectRatio = buffer.readFloat64();
				aspectRatio_is_set = true;
				break;
			case "isManipulating":
				buffer.readInt32();
				gizmo_isManipulating = buffer.readBool();
				isManipulating_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!items_is_set) gizmo_items = [];
				if(!min_is_set) gizmo_min = new Vector2(0.0, 0.0, null);
				if(!max_is_set) gizmo_max = new Vector2(0.0, 0.0, null);
				if(!handleSize_is_set) gizmo_handleSize = 0.0;
				if(!overHandleDirection_is_set) gizmo_overHandleDirection = null;
				if(!touchDownPos_is_set) gizmo_touchDownPos = new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, null);
				if(!touchDownInsideGizmo_is_set) gizmo_touchDownInsideGizmo = false;
				if(!locationIndex_is_set) gizmo_locationIndex = 0;
				if(!waitingForCodeId_is_set) gizmo_waitingForCodeId = 0;
				if(!aspectRatio_is_set) gizmo_aspectRatio = 0.0;
				if(!isManipulating_is_set) gizmo_isManipulating = false;
				return;
		}
	}
}
function DisplayItem(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation) {
	this.type = "DisplayItem";
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
	this.layer = layer;
	this.alpha = alpha;
	this.clippingPath = clippingPath;
	this.name = name;
	this.location = location;
	this.positionLocation = positionLocation;
	this.sizeLocation = sizeLocation;
	this.m0 = 0.0;
	this.m1 = 0.0;
	this.m2 = 0.0;
	this.m3 = 0.0;
	this.m4 = 0.0;
	this.m5 = 0.0;
	this.poly = [];
	this.m0 = m.m0;
	this.m1 = m.m1;
	this.m2 = m.m2;
	this.m3 = m.m3;
	this.m4 = m.m4;
	this.m5 = m.m5;
	if(Platform_isDebug && (this.w || this.h)) {
		this.poly = [new Vector2(this.x, this.y, null).transform(m), new Vector2(this.x + this.w, this.y, null).transform(m), new Vector2(this.x + this.w, this.y + this.h, null).transform(m), new Vector2(this.x, this.y + this.h, null).transform(m)];
	}
}
function new_DisplayItem_of_type(type) {
	switch(type) {
		case "DisplayItem": return new _DisplayItem();
		case "DisplayImage": return new _DisplayImage();
		case "DisplayText": return new _DisplayText();
		case "DisplayRectangle": return new _DisplayRectangle();
		case "DisplayRoundedRectangle": return new _DisplayRoundedRectangle();
		case "DisplayPolygon": return new _DisplayPolygon();
		case "DisplayCircle": return new _DisplayCircle();
		case "DisplayLine": return new _DisplayLine();
		case "DisplayVideo": return new _DisplayVideo();
	}
}
DisplayItem.prototype.draw = function() {
}
DisplayItem.prototype.startClipping = function() {
	let points = this.clippingPath.points
	if(points.length >= 2) {
		let x = this.x, y = this.y
		let firstPos = points[points.length-1]
		graphics_context.beginPath();
		graphics_context.moveTo(firstPos.x, firstPos.y)
		for(let p of points) graphics_context.lineTo(p.x, p.y)
		if(this.clippingPath.show) {
			graphics_context.fillStyle = "#ff000080"
			graphics_context.fill()
		}
		graphics_context.save()
		graphics_context.clip()
	}
}
DisplayItem.prototype.endClipping = function() {
	if(this.clippingPath.points.length >= 2)
		graphics_context.restore()
}
DisplayItem.prototype.clone = function() {
	let clone = new _DisplayItem();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	return clone;
}
function _DisplayItem() {};
_DisplayItem.prototype = DisplayItem.prototype;
var lobby_inLobby;
var lobby_enableFullscreen;
var lobby_points;
var lobby_ticks;
var lobby_showSettings;
function lobby_init() {
	lobby_inLobby = true;
	lobby_enableFullscreen = true;
	lobby_points = [];
	lobby_ticks = 0;
	lobby_showSettings = false;
}
function lobby_tick() {
	lobby_tickSettings();
	if(Platform_isStaging) {
		graphics_drawText("Version:"+version?.toString()+" delta:"+(lobby_ticks - core_frame)?.toString()+" ticks:"+lobby_ticks?.toString(), new Vector2(-940, 520, null), new Vector2(20, 0, null), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
		lobby_ticks++;
	}
	if(PeerNetwork_error || core_errorMessage) {
		graphics_drawText(PeerNetwork_error, new Vector2(0.0, 0.0, null), new Vector2(40, 0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
		graphics_drawText(core_errorMessage, new Vector2(0, 40, null), new Vector2(14, 0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
		return;
	}
	let count = input_players.length;
	if(count) {
		let width = (count < 2 ? 900.0 : 1920 / count), offset = -width * (count - 1) / 2;
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let pos = new Vector2(offset + width * it.index, 0, null);
			graphics_drawVideo(it, pos, new Vector2(width, 0, null), 0/*Rectangle*/, null, null);
			if(it.isReadyInLobby) {
				let text = (Loca_language == 0/*English*/ ? "I'm ready" : "Ich bin bereit");
				let basePos = Vector2_plus_Vector2(pos, new Vector2(-(graphics_getTextWidth(text, new Vector2(32, 0, null), null, 0/*Normal*/) + 28) / 2, width * 3 / 8 + 40, null));
				graphics_drawImage(Image_ThumbsUp, basePos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
				graphics_drawText(text, Vector2_plus_Vector2(basePos, new Vector2(32, 4, null)), new Vector2(32, 0, null), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
			}
		}}
	}
	if(core_drawPointsForTesting) {
		input_onTouchDown(null, true, touch => {
			lobby_points.push(touch.position().clone());
		});
		for(let i=0, _subject=lobby_points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			graphics_drawCircle(it, new Vector2(50, 0, null), null, null, 0, (-.25), 1.0, 0/*Clockwise*/, null, 0, 1.0, null);
		}}
	}
	if(Loca_supportedLanguages.length > 1) {
		for(let i=0, _subject=Loca_supportedLanguages, _end = new Vector2(930, -510, null), _delta = new Vector2(40, 0.0, null), _len=_subject.length, _x = _end.x-(_len-1)*_delta.x, _y=_end.y-(_len-1)*_delta.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let it = _subject[i], pos = new Vector2(_x, _y, _end.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _end.location, _delta.location) : null); {
			graphics_drawImage5(Image_Flag.get(i), pos, new Vector2(0.0, 0.0, null), null, null, (Loca_language == i ? 1 : 0), 0, 1.0, Color_White, 0.0, new Vector2(16, 16, null), false, 0/*None*/, touch => {
				Loca_setLanguage(i, null);
			}, null);
		}}
	}
	if(core_mode == 1/*Ping*/) {
		graphics_drawText("Connecting...", new Vector2(0.0, 0.0, null), new Vector2(32, 0, null), null, 1/*Center*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
	} else {
		if((input_players.length >= Platform_supportedUserCount.from && input_players.length <= Platform_supportedUserCount.to)) {
			for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				if(!it.isReadyInLobby) {
					graphics_drawButton(Image_Button, "Start", new Vector2(0, 450, null), new Vector2(0.0, 0.0, null), 0, null, 18, new Vector2(0, 0, null), new Vector2(16, 16, null), false, [it], null, 0/*None*/, 0, 1.0, true, .5, touch => {
						if(lobby_enableFullscreen) {
							if(!Platform_isStaging && !Platform_isDebug && (touch.by == null || input_localUser?.id == touch.by.id)) {
								try {
									if(true) {
										document.body.requestFullscreen()
									} else {
										document.exitFullscreen()
									}
								} catch {
								}
							} ;
						}
						input_playersById.get(touch.by.id).isReadyInLobby = true;
						if(input_players.every(a => a.isReadyInLobby)) {
							core_startApp();
						}
					}, null);
				}
			}}
		}
	}
}
function lobby_tickSettings() {
	if(!(input_localUser != null)) {
		return;
	}
	graphics_drawImage5(Image_settingsIcon, new Vector2(-920, -500, null), new Vector2(32, 0, null), null, [input_localPlayer], 0, 0, 1.0, Color_White, 0.0, new Vector2(16, 16, null), false, 0/*None*/, touch => {
		lobby_showSettings = !lobby_showSettings;
	}, null);
	if(lobby_showSettings) {
		let pos = new Vector2(-650, -500, null);
		if((PeerNetwork_devices.videoInput != null && PeerNetwork_devices.videoInput?.length != 0) ) {
			graphics_drawImage(Image_cameraIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
			for(let i=0, _subject=PeerNetwork_devices.videoInput, _start = Vector2_plus_Vector2(pos, new Vector2(36, 0.0, null)), _delta = new Vector2(0, 26, null), _len=_subject.length, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let device = _subject[i], pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
				graphics_drawText(device.label, pos, new Vector2(18, 0, null), (PeerNetwork_videoInputId == device.deviceId ? Color_Green : Color_White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
				input_onTouchDownWithin(Vector2_plus_Vector2(pos, new Vector2(200, 0, null)), new Vector2(400, 30, null), [input_localPlayer], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
					PeerNetwork_setVideoInput(device.deviceId);
				});
			}}
			Vector2_plusAssign_Vector2(pos, new Vector2(450, 0.0, null));
		}
		if((PeerNetwork_devices.audioInput != null && PeerNetwork_devices.audioInput?.length != 0) ) {
			graphics_drawImage(Image_microphoneIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
			for(let i=0, _subject=PeerNetwork_devices.audioInput, _start = Vector2_plus_Vector2(pos, new Vector2(36, 0.0, null)), _delta = new Vector2(0, 26, null), _len=_subject.length, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let device = _subject[i], pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
				graphics_drawText(device.label, pos, new Vector2(18, 0, null), (PeerNetwork_audioInputId == device.deviceId ? Color_Green : Color_White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
				input_onTouchDownWithin(Vector2_plus_Vector2(pos, new Vector2(200, 0, null)), new Vector2(400, 30, null), [input_localPlayer], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
					PeerNetwork_setAudioInput(device.deviceId);
				});
			}}
			Vector2_plusAssign_Vector2(pos, new Vector2(550, 0.0, null));
		}
		if((PeerNetwork_devices.audioOutput != null && PeerNetwork_devices.audioOutput?.length != 0) ) {
			graphics_drawImage(Image_speakerIcon, pos, new Vector2(0.0, 0.0, null), null, 0, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
			for(let i=0, _subject=PeerNetwork_devices.audioOutput, _start = Vector2_plus_Vector2(pos, new Vector2(36, 0.0, null)), _delta = new Vector2(0, 26, null), _len=_subject.length, _x = _start.x, _y= _start.y; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let device = _subject[i], pos = new Vector2(_x, _y, _start.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _start.location, _delta.location) : null); {
				graphics_drawText(device.label, pos, new Vector2(18, 0, null), (PeerNetwork_audioOutputId == device.deviceId ? Color_Green : Color_White), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
				input_onTouchDownWithin(Vector2_plus_Vector2(pos, new Vector2(200, 0, null)), new Vector2(400, 30, null), [input_localPlayer], "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
					PeerNetwork_setAudioOutput(device.deviceId);
				});
			}}
		}
	}
}
function lobby_serialize_internal(buffer) {
	buffer.writeBool(lobby_inLobby);
	buffer.writeBool(lobby_enableFullscreen);
	if(lobby_points) {
		var index = _objectCacheIndex.get(lobby_points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(lobby_points, index = _objectCache.length);
			_objectCache.push(lobby_points);
			buffer.writeInt32(-index);
			lobby_points._objectIndex = index;
			buffer.writeInt32(lobby_points.length);
			for(let i=0, len=lobby_points.length; i<len; ++i) {
				(lobby_points[i] || new _Vector2()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(lobby_ticks);
	buffer.writeBool(lobby_showSettings);
}
function lobby_deserialize_internal(buffer) {
	lobby_inLobby = buffer.readBool();
	lobby_enableFullscreen = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		lobby_points = _objectCache[index];
	} else {
		if(!lobby_points || lobby_points._objectIndex != -index) lobby_points = [];
		_objectCache[-index] = lobby_points;
		for(let i=0, len = lobby_points.length = buffer.readInt32(); i<len; ++i) {
				(lobby_points[i] || (lobby_points[i] = new _Vector2())).deserialize_internal(buffer);
		}
	}
	lobby_ticks = buffer.readInt32();
	lobby_showSettings = buffer.readBool();
}
function lobby_serialize_external(buffer) {
	buffer.writeString("inLobby");
	buffer.writeInt32(1);
	buffer.writeBool(lobby_inLobby);
	buffer.writeString("enableFullscreen");
	buffer.writeInt32(1);
	buffer.writeBool(lobby_enableFullscreen);
	buffer.writeString("points");
	let lobby_points_startPos = buffer.reserveSize();
	if(lobby_points) {
		var index = _objectCacheIndex.get(lobby_points);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(lobby_points, index = _objectCache.length);
			_objectCache.push(lobby_points);
			buffer.writeInt32(-index);
			lobby_points._objectIndex = index;
			buffer.writeInt32(lobby_points.length);
			for(let i=0, len=lobby_points.length; i<len; ++i) {
				(lobby_points[i] || new _Vector2()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(lobby_points_startPos);
	buffer.writeString("ticks");
	buffer.writeInt32(4);
	buffer.writeInt32(lobby_ticks);
	buffer.writeString("showSettings");
	buffer.writeInt32(1);
	buffer.writeBool(lobby_showSettings);
	buffer.writeString("");
}
function lobby_deserialize_external(buffer) {
	let inLobby_is_set = false, enableFullscreen_is_set = false, points_is_set = false, ticks_is_set = false, showSettings_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "inLobby":
				buffer.readInt32();
				lobby_inLobby = buffer.readBool();
				inLobby_is_set = true;
				break;
			case "enableFullscreen":
				buffer.readInt32();
				lobby_enableFullscreen = buffer.readBool();
				enableFullscreen_is_set = true;
				break;
			case "points":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					lobby_points = _objectCache[index];
				} else {
					if(!lobby_points || lobby_points._objectIndex != -index) lobby_points = [];
					_objectCache[-index] = lobby_points;
					for(let i=0, len = lobby_points.length = buffer.readInt32(); i<len; ++i) {
							(lobby_points[i] || (lobby_points[i] = new _Vector2())).deserialize_external(buffer);
					}
				}
				points_is_set = true;
				break;
			case "ticks":
				buffer.readInt32();
				lobby_ticks = buffer.readInt32();
				ticks_is_set = true;
				break;
			case "showSettings":
				buffer.readInt32();
				lobby_showSettings = buffer.readBool();
				showSettings_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!inLobby_is_set) lobby_inLobby = true;
				if(!enableFullscreen_is_set) lobby_enableFullscreen = true;
				if(!points_is_set) lobby_points = [];
				if(!ticks_is_set) lobby_ticks = 0;
				if(!showSettings_is_set) lobby_showSettings = false;
				return;
		}
	}
}
var Framework_objects;
var Framework_selectedObjects;
var Framework_toBeRemoved;
function Framework_init() {
	Framework_objects = [];
	Framework_selectedObjects = [];
	Framework_toBeRemoved = [];
}
function Framework_clear() {
	for(let _subject=Framework_objects, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		if(!it.locked) {
			Framework_objects.splice(i, 1);
		}
	}}
}
function Framework_clearAtEndOfFrame() {
	for(let i=0, _subject=Framework_objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if(!it.locked) {
			Framework_toBeRemoved.push(it);
		}
	}}
}
function Framework_removeWhere(condition) {
	for(let i=0, _subject=Framework_objects, _len=_subject.length; i<_len; ++i) { let obj = _subject[i]; {
		if(condition(obj)) {
			Framework_toBeRemoved.push(obj);
		}
	}}
}
function Framework_tick() {
	fx_tick();
	for(let i=0, _subject=[...Framework_objects], _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.tick();
	}}
	input_onTouchUp2(null, true, touch => {
		Framework_deselect(touch.by);
	});
	if((Framework_toBeRemoved != null && Framework_toBeRemoved?.length != 0) ) {
		for(let i=0, _subject=Framework_toBeRemoved, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			it.siblings().remove(it);
		}}
		Framework_toBeRemoved.length = 0;
	}
}
function Framework_deselect(player) {
	Framework_selectedObjects.set(player.id, null);
}
function Framework_debugString() {
	let result = "";
	for(let i=0, _subject=Framework_objects, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		result += it.debugString();
	}}
	return result;
}
function Framework_serialize_internal(buffer) {
	if(Framework_objects) {
		var index = _objectCacheIndex.get(Framework_objects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_objects, index = _objectCache.length);
			_objectCache.push(Framework_objects);
			buffer.writeInt32(-index);
			Framework_objects._objectIndex = index;
			buffer.writeInt32(Framework_objects.length);
			for(let i=0, len=Framework_objects.length; i<len; ++i) {
				let Framework_objects_item = Framework_objects[i]
				if(Framework_objects_item) {
					var index = _objectCacheIndex.get(Framework_objects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_objects_item, index = _objectCache.length);
						_objectCache.push(Framework_objects_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_objects_item.type);
						Framework_objects_item._objectIndex = index;
						Framework_objects_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Framework_selectedObjects) {
		var index = _objectCacheIndex.get(Framework_selectedObjects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_selectedObjects, index = _objectCache.length);
			_objectCache.push(Framework_selectedObjects);
			buffer.writeInt32(-index);
			Framework_selectedObjects._objectIndex = index;
			buffer.writeInt32(Framework_selectedObjects.length);
			for(let i=0, len=Framework_selectedObjects.length; i<len; ++i) {
				let Framework_selectedObjects_item = Framework_selectedObjects[i]
				if(Framework_selectedObjects_item) {
					var index = _objectCacheIndex.get(Framework_selectedObjects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_selectedObjects_item, index = _objectCache.length);
						_objectCache.push(Framework_selectedObjects_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_selectedObjects_item.type);
						Framework_selectedObjects_item._objectIndex = index;
						Framework_selectedObjects_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(Framework_toBeRemoved) {
		var index = _objectCacheIndex.get(Framework_toBeRemoved);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_toBeRemoved, index = _objectCache.length);
			_objectCache.push(Framework_toBeRemoved);
			buffer.writeInt32(-index);
			Framework_toBeRemoved._objectIndex = index;
			buffer.writeInt32(Framework_toBeRemoved.length);
			for(let i=0, len=Framework_toBeRemoved.length; i<len; ++i) {
				let Framework_toBeRemoved_item = Framework_toBeRemoved[i]
				if(Framework_toBeRemoved_item) {
					var index = _objectCacheIndex.get(Framework_toBeRemoved_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_toBeRemoved_item, index = _objectCache.length);
						_objectCache.push(Framework_toBeRemoved_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_toBeRemoved_item.type);
						Framework_toBeRemoved_item._objectIndex = index;
						Framework_toBeRemoved_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function Framework_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework_objects = _objectCache[index];
	} else {
		if(!Framework_objects || Framework_objects._objectIndex != -index) Framework_objects = [];
		_objectCache[-index] = Framework_objects;
		for(let i=0, len = Framework_objects.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_objects[i] = _objectCache[index];
				} else {
					let Framework_objects_item = Framework_objects[i]
					let type = buffer.readString();
					if(!Framework_objects_item || Framework_objects_item._objectIndex != -index)
						Framework_objects[i] = Framework_objects_item = new_Object_of_type(type);
					Framework_objects_item.type = type;
					(_objectCache[-index] = Framework_objects_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework_selectedObjects = _objectCache[index];
	} else {
		if(!Framework_selectedObjects || Framework_selectedObjects._objectIndex != -index) Framework_selectedObjects = [];
		_objectCache[-index] = Framework_selectedObjects;
		for(let i=0, len = Framework_selectedObjects.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_selectedObjects[i] = _objectCache[index];
				} else {
					let Framework_selectedObjects_item = Framework_selectedObjects[i]
					let type = buffer.readString();
					if(!Framework_selectedObjects_item || Framework_selectedObjects_item._objectIndex != -index)
						Framework_selectedObjects[i] = Framework_selectedObjects_item = new_Object_of_type(type);
					Framework_selectedObjects_item.type = type;
					(_objectCache[-index] = Framework_selectedObjects_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		Framework_toBeRemoved = _objectCache[index];
	} else {
		if(!Framework_toBeRemoved || Framework_toBeRemoved._objectIndex != -index) Framework_toBeRemoved = [];
		_objectCache[-index] = Framework_toBeRemoved;
		for(let i=0, len = Framework_toBeRemoved.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_toBeRemoved[i] = _objectCache[index];
				} else {
					let Framework_toBeRemoved_item = Framework_toBeRemoved[i]
					let type = buffer.readString();
					if(!Framework_toBeRemoved_item || Framework_toBeRemoved_item._objectIndex != -index)
						Framework_toBeRemoved[i] = Framework_toBeRemoved_item = new_Object_of_type(type);
					Framework_toBeRemoved_item.type = type;
					(_objectCache[-index] = Framework_toBeRemoved_item).deserialize_internal(buffer);
				}
		}
	}
}
function Framework_serialize_external(buffer) {
	buffer.writeString("objects");
	let Framework_objects_startPos = buffer.reserveSize();
	if(Framework_objects) {
		var index = _objectCacheIndex.get(Framework_objects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_objects, index = _objectCache.length);
			_objectCache.push(Framework_objects);
			buffer.writeInt32(-index);
			Framework_objects._objectIndex = index;
			buffer.writeInt32(Framework_objects.length);
			for(let i=0, len=Framework_objects.length; i<len; ++i) {
				let Framework_objects_item = Framework_objects[i]
				if(Framework_objects_item) {
					var index = _objectCacheIndex.get(Framework_objects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_objects_item, index = _objectCache.length);
						_objectCache.push(Framework_objects_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_objects_item.type);
						Framework_objects_item._objectIndex = index;
						Framework_objects_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Framework_objects_startPos);
	buffer.writeString("selectedObjects");
	let Framework_selectedObjects_startPos = buffer.reserveSize();
	if(Framework_selectedObjects) {
		var index = _objectCacheIndex.get(Framework_selectedObjects);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_selectedObjects, index = _objectCache.length);
			_objectCache.push(Framework_selectedObjects);
			buffer.writeInt32(-index);
			Framework_selectedObjects._objectIndex = index;
			buffer.writeInt32(Framework_selectedObjects.length);
			for(let i=0, len=Framework_selectedObjects.length; i<len; ++i) {
				let Framework_selectedObjects_item = Framework_selectedObjects[i]
				if(Framework_selectedObjects_item) {
					var index = _objectCacheIndex.get(Framework_selectedObjects_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_selectedObjects_item, index = _objectCache.length);
						_objectCache.push(Framework_selectedObjects_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_selectedObjects_item.type);
						Framework_selectedObjects_item._objectIndex = index;
						Framework_selectedObjects_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Framework_selectedObjects_startPos);
	buffer.writeString("toBeRemoved");
	let Framework_toBeRemoved_startPos = buffer.reserveSize();
	if(Framework_toBeRemoved) {
		var index = _objectCacheIndex.get(Framework_toBeRemoved);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(Framework_toBeRemoved, index = _objectCache.length);
			_objectCache.push(Framework_toBeRemoved);
			buffer.writeInt32(-index);
			Framework_toBeRemoved._objectIndex = index;
			buffer.writeInt32(Framework_toBeRemoved.length);
			for(let i=0, len=Framework_toBeRemoved.length; i<len; ++i) {
				let Framework_toBeRemoved_item = Framework_toBeRemoved[i]
				if(Framework_toBeRemoved_item) {
					var index = _objectCacheIndex.get(Framework_toBeRemoved_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(Framework_toBeRemoved_item, index = _objectCache.length);
						_objectCache.push(Framework_toBeRemoved_item);
						buffer.writeInt32(-index);
						buffer.writeString(Framework_toBeRemoved_item.type);
						Framework_toBeRemoved_item._objectIndex = index;
						Framework_toBeRemoved_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(Framework_toBeRemoved_startPos);
	buffer.writeString("");
}
function Framework_deserialize_external(buffer) {
	let objects_is_set = false, selectedObjects_is_set = false, toBeRemoved_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "objects":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_objects = _objectCache[index];
				} else {
					if(!Framework_objects || Framework_objects._objectIndex != -index) Framework_objects = [];
					_objectCache[-index] = Framework_objects;
					for(let i=0, len = Framework_objects.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Framework_objects[i] = _objectCache[index];
							} else {
								let Framework_objects_item = Framework_objects[i]
								let type = buffer.readString();
								if(!Framework_objects_item || Framework_objects_item._objectIndex != -index)
									Framework_objects[i] = Framework_objects_item = new_Object_of_type(type);
								Framework_objects_item.type = type;
								(_objectCache[-index] = Framework_objects_item).deserialize_external(buffer);
							}
					}
				}
				objects_is_set = true;
				break;
			case "selectedObjects":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_selectedObjects = _objectCache[index];
				} else {
					if(!Framework_selectedObjects || Framework_selectedObjects._objectIndex != -index) Framework_selectedObjects = [];
					_objectCache[-index] = Framework_selectedObjects;
					for(let i=0, len = Framework_selectedObjects.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Framework_selectedObjects[i] = _objectCache[index];
							} else {
								let Framework_selectedObjects_item = Framework_selectedObjects[i]
								let type = buffer.readString();
								if(!Framework_selectedObjects_item || Framework_selectedObjects_item._objectIndex != -index)
									Framework_selectedObjects[i] = Framework_selectedObjects_item = new_Object_of_type(type);
								Framework_selectedObjects_item.type = type;
								(_objectCache[-index] = Framework_selectedObjects_item).deserialize_external(buffer);
							}
					}
				}
				selectedObjects_is_set = true;
				break;
			case "toBeRemoved":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					Framework_toBeRemoved = _objectCache[index];
				} else {
					if(!Framework_toBeRemoved || Framework_toBeRemoved._objectIndex != -index) Framework_toBeRemoved = [];
					_objectCache[-index] = Framework_toBeRemoved;
					for(let i=0, len = Framework_toBeRemoved.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								Framework_toBeRemoved[i] = _objectCache[index];
							} else {
								let Framework_toBeRemoved_item = Framework_toBeRemoved[i]
								let type = buffer.readString();
								if(!Framework_toBeRemoved_item || Framework_toBeRemoved_item._objectIndex != -index)
									Framework_toBeRemoved[i] = Framework_toBeRemoved_item = new_Object_of_type(type);
								Framework_toBeRemoved_item.type = type;
								(_objectCache[-index] = Framework_toBeRemoved_item).deserialize_external(buffer);
							}
					}
				}
				toBeRemoved_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!objects_is_set) Framework_objects = [];
				if(!selectedObjects_is_set) Framework_selectedObjects = [];
				if(!toBeRemoved_is_set) Framework_toBeRemoved = [];
				return;
		}
	}
}
function $Object(position, size, alpha, visibleFor, layer, locked, location) {
	this.type = "Object";
	this.position = position?.clone();
	this.size = size?.clone();
	this.alpha = alpha;
	this.visibleFor = visibleFor;
	this.layer = layer;
	this.locked = locked;
	this.location = location;
	this.siblings().push(this);
}
function new_Object_of_type(type) {
	switch(type) {
		case "Object": return new _Object();
		case "RectangleObject": return new _RectangleObject();
		case "CircleObject": return new _CircleObject();
		case "TextObject": return new _TextObject();
		case "ImageObject": return new _ImageObject();
		case "Effect": return new _Effect();
		case "VideoObject": return new _VideoObject();
		case "Button": return new _Button();
		case "ParticleSystem": return new _ParticleSystem();
		case "Menu": return new _Menu();
	}
}
$Object.prototype.siblings = function() {
	return Framework_objects;
}
$Object.prototype.debugString = function() {
	return "(Object pos:"+this.position.x?.toString()+" "+this.position.y?.toString()+")";
}
$Object.prototype.tick = function() {
}
$Object.prototype.removeImmediately = function() {
	this.siblings().remove(this);
}
$Object.prototype.removeAtEndOfFrame = function() {
	Framework_toBeRemoved.push(this);
}
$Object.prototype.moveToFront = function() {
	this.siblings().moveToFront(this);
}
$Object.prototype.moveToBack = function() {
	this.siblings().moveToBack(this);
}
$Object.prototype.moveTo = function(pos, duration, delay) {
	let startPosition = this.position?.clone();
	let moveAnimation = fx_animations.findLast(a => a.type == "MoveAnimation" && a.object == this);
	if((moveAnimation != null)) {
		Vector2_assign_Vector2(startPosition, Vector2_plus_Vector2(moveAnimation.startValue, moveAnimation.delta));
	}
	let delta = Vector2_minus_Vector2(pos, startPosition);
	fx_add(new MoveAnimation(fx_endOfPrevAnimation(this)+delay, duration, this, startPosition, delta));
	return this;
}
$Object.prototype.moveTo2 = function(pos, speed, delay) {
	let delta = Vector2_minus_Vector2(pos, this.position);
	let duration = Math.floor(delta.length() / speed);
	fx_add(new MoveAnimation(fx_endOfPrevAnimation(this)+delay, duration, this, this.position, delta));
	return this;
}
$Object.prototype.moveAndScaleTo = function(position, size, duration, delay) {
	let startPosition = this.position?.clone();
	let startSize = this.size?.clone();
	let endSize = (size.y ? size : new Vector2(size.x, size.x * startSize.y / startSize.x, null))?.clone();
	let moveAnimation = fx_animations.findLast(a => a.type == "MoveAnimation" && a.object == this);
	if((moveAnimation != null)) {
		Vector2_assign_Vector2(startPosition, Vector2_plus_Vector2(moveAnimation.startValue, moveAnimation.delta));
	}
	let startTime = fx_endOfPrevAnimation(this)+delay;
	fx_add(new MoveAnimation(startTime, duration, this, startPosition, Vector2_minus_Vector2(position, startPosition)));
	fx_add(new ScaleAnimation(startTime, duration, this, startSize, Vector2_minus_Vector2(endSize, startSize)));
	return this;
}
$Object.prototype.fadeIn = function(duration, delay) {
	this.alpha = 0;
	fx_add(new FadeAnimation(fx_endOfPrevAnimation(this)+delay, duration, this, 0, 1, false));
	return this;
}
$Object.prototype.fadeOut = function(duration, delay, removeWhenDone) {
	let startValue = this.alpha;
	let lastFadeAnimation = fx_animations.findLast(a => a.type == "FadeAnimation" && a.object == this);
	if((lastFadeAnimation != null)) {
		if(lastFadeAnimation.startValue + lastFadeAnimation.delta <= 0) {
			return;
		}
		startValue = lastFadeAnimation.startValue + lastFadeAnimation.delta;
	}
	fx_add(new FadeAnimation(fx_endOfPrevAnimation(this)+delay, duration, this, startValue, -startValue, removeWhenDone));
	return this;
}
$Object.prototype.scaleTo = function(size, duration, delay) {
	fx_add(new ScaleAnimation(fx_endOfPrevAnimation(this)+delay, duration, this, this.size, Vector2_minus_Vector2(size, this.size)));
	return this;
}
$Object.prototype.do = function($do, delay) {
	fx_add(new DelayAnimation(fx_endOfPrevAnimation(this)+delay, 0, this, $do));
}
$Object.prototype.playSound = function(sound, delay) {
	fx_add(new PlaySoundAnimation(fx_endOfPrevAnimation(this)+delay, 0, this, sound));
}
$Object.prototype.fadeAndScaleIn = function(startScale, duration, delay) {
	this.alpha = 0;
	let startTime = fx_endOfPrevAnimation(this)+delay;
	fx_add(new ScaleAnimation(startTime, duration, this, float_multiply_Vector2(startScale, this.size), float_multiply_Vector2((1 - startScale), this.size)));
	fx_add(new FadeAnimation(startTime, duration, this, 0, 1, false));
	return this;
}
$Object.prototype.removeAnimations = function() {
	fx_removeForObject(this);
}
$Object.prototype.clone = function() {
	let clone = new _Object();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	return clone;
}
function _Object() {};
_Object.prototype = $Object.prototype;
$Object.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.alpha);
	let visibleFor = this.visibleFor
	if(visibleFor) {
		var index = _objectCacheIndex.get(visibleFor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(visibleFor, index = _objectCache.length);
			_objectCache.push(visibleFor);
			buffer.writeInt32(-index);
			visibleFor._objectIndex = index;
			buffer.writeInt32(visibleFor.length);
			for(let i=0, len=visibleFor.length; i<len; ++i) {
				let visibleFor_item = visibleFor[i]
				if(visibleFor_item) {
					var index = _objectCacheIndex.get(visibleFor_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(visibleFor_item, index = _objectCache.length);
						_objectCache.push(visibleFor_item);
						buffer.writeInt32(-index);
						visibleFor_item._objectIndex = index;
						visibleFor_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.layer);
	buffer.writeBool(this.locked);
}
$Object.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	this.alpha = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.visibleFor = _objectCache[index];
	} else {
		let visibleFor = this.visibleFor
		if(!visibleFor || visibleFor._objectIndex != -index) this.visibleFor = visibleFor = [];
		_objectCache[-index] = visibleFor;
		for(let i=0, len = visibleFor.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					visibleFor[i] = _objectCache[index];
				} else {
					let visibleFor_item = visibleFor[i]
					if(!visibleFor_item || visibleFor_item._objectIndex != -index)
						visibleFor[i] = visibleFor_item = new _Player();
					(_objectCache[-index] = visibleFor_item).deserialize_internal(buffer);
				}
		}
	}
	this.layer = buffer.readInt32();
	this.locked = buffer.readBool();
}
$Object.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("alpha");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.alpha);
	buffer.writeString("visibleFor");
	let visibleFor = this.visibleFor
	let visibleFor_startPos = buffer.reserveSize();
	if(visibleFor) {
		var index = _objectCacheIndex.get(visibleFor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(visibleFor, index = _objectCache.length);
			_objectCache.push(visibleFor);
			buffer.writeInt32(-index);
			visibleFor._objectIndex = index;
			buffer.writeInt32(visibleFor.length);
			for(let i=0, len=visibleFor.length; i<len; ++i) {
				let visibleFor_item = visibleFor[i]
				if(visibleFor_item) {
					var index = _objectCacheIndex.get(visibleFor_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(visibleFor_item, index = _objectCache.length);
						_objectCache.push(visibleFor_item);
						buffer.writeInt32(-index);
						visibleFor_item._objectIndex = index;
						visibleFor_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(visibleFor_startPos);
	buffer.writeString("layer");
	buffer.writeInt32(4);
	buffer.writeInt32(this.layer);
	buffer.writeString("locked");
	buffer.writeInt32(1);
	buffer.writeBool(this.locked);
	buffer.writeString("");
}
$Object.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, alpha_is_set = false, visibleFor_is_set = false, layer_is_set = false, locked_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "alpha":
				buffer.readInt32();
				this.alpha = buffer.readFloat64();
				alpha_is_set = true;
				break;
			case "visibleFor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.visibleFor = _objectCache[index];
				} else {
					let visibleFor = this.visibleFor
					if(!visibleFor || visibleFor._objectIndex != -index) this.visibleFor = visibleFor = [];
					_objectCache[-index] = visibleFor;
					for(let i=0, len = visibleFor.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								visibleFor[i] = _objectCache[index];
							} else {
								let visibleFor_item = visibleFor[i]
								if(!visibleFor_item || visibleFor_item._objectIndex != -index)
									visibleFor[i] = visibleFor_item = new _Player();
								(_objectCache[-index] = visibleFor_item).deserialize_external(buffer);
							}
					}
				}
				visibleFor_is_set = true;
				break;
			case "layer":
				buffer.readInt32();
				this.layer = buffer.readInt32();
				layer_is_set = true;
				break;
			case "locked":
				buffer.readInt32();
				this.locked = buffer.readBool();
				locked_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!alpha_is_set) this.alpha = 1;
				if(!visibleFor_is_set) this.visibleFor = null;
				if(!layer_is_set) this.layer = 0;
				if(!locked_is_set) this.locked = false;
				return;
		}
	}
}
function Particle(pos, speed, angle, rotationSpeed, frame) {
	this.pos = pos?.clone();
	this.speed = speed?.clone();
	this.angle = angle;
	this.rotationSpeed = rotationSpeed;
	this.frame = frame;
}
Particle.prototype.clone = function() {
	let clone = new _Particle();
	clone.pos = this.pos.clone();
	clone.speed = this.speed.clone();
	clone.angle = this.angle;
	clone.rotationSpeed = this.rotationSpeed;
	clone.frame = this.frame;
	return clone;
}
function _Particle() {};
_Particle.prototype = Particle.prototype;
Particle.prototype.serialize_internal = function(buffer) {
	(this.pos || new _Vector2()).serialize_internal(buffer);
	(this.speed || new _Vector2()).serialize_internal(buffer);
	buffer.writeFloat64(this.angle);
	buffer.writeFloat64(this.rotationSpeed);
	buffer.writeInt32(this.frame);
}
Particle.prototype.deserialize_internal = function(buffer) {
	(this.pos || (this.pos = new _Vector2())).deserialize_internal(buffer);
	(this.speed || (this.speed = new _Vector2())).deserialize_internal(buffer);
	this.angle = buffer.readFloat64();
	this.rotationSpeed = buffer.readFloat64();
	this.frame = buffer.readInt32();
}
Particle.prototype.serialize_external = function(buffer) {
	buffer.writeString("pos");
	let pos_startPos = buffer.reserveSize();
	(this.pos || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(pos_startPos);
	buffer.writeString("speed");
	let speed_startPos = buffer.reserveSize();
	(this.speed || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(speed_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("rotationSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.rotationSpeed);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("");
}
Particle.prototype.deserialize_external = function(buffer) {
	let pos_is_set = false, speed_is_set = false, angle_is_set = false, rotationSpeed_is_set = false, frame_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pos":
				buffer.readInt32();
				(this.pos || (this.pos = new _Vector2())).deserialize_external(buffer);
				pos_is_set = true;
				break;
			case "speed":
				buffer.readInt32();
				(this.speed || (this.speed = new _Vector2())).deserialize_external(buffer);
				speed_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			case "rotationSpeed":
				buffer.readInt32();
				this.rotationSpeed = buffer.readFloat64();
				rotationSpeed_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pos_is_set) this.pos = new Vector2(0.0, 0.0, null);
				if(!speed_is_set) this.speed = new Vector2(0.0, 0.0, null);
				if(!angle_is_set) this.angle = 0.0;
				if(!rotationSpeed_is_set) this.rotationSpeed = 0.0;
				if(!frame_is_set) this.frame = 0;
				return;
		}
	}
}
function MenuItem(image, label, value, type, onClick) {
	this.image = image;
	this.label = label;
	this.value = value;
	this.type = type;
	this.onClick = onClick;
}
MenuItem.prototype.clone = function() {
	let clone = new _MenuItem();
	clone.image = this.image;
	clone.label = this.label;
	clone.value = this.value;
	clone.type = this.type;
	clone.onClick = this.onClick;
	return clone;
}
function _MenuItem() {};
_MenuItem.prototype = MenuItem.prototype;
MenuItem.prototype.serialize_internal = function(buffer) {
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.label);
	buffer.writeBool(this.value);
	buffer.writeInt32(this.type);
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
MenuItem.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.label = buffer.readString();
	this.value = buffer.readBool();
	this.type = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onClick = _objectCache[index];
	} else {
		let onClick = this.onClick
		let _id = buffer.readInt32();
		if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
			this.onClick = onClick = new _lambdaContructors[_id]();
		onClick._id = _id;
		(_objectCache[-index] = onClick).deserialize_internal(buffer);
	}
}
MenuItem.prototype.serialize_external = function(buffer) {
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("value");
	buffer.writeInt32(1);
	buffer.writeBool(this.value);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("onClick");
	let onClick_startPos = buffer.reserveSize();
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onClick_startPos);
	buffer.writeString("");
}
MenuItem.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, label_is_set = false, value_is_set = false, type_is_set = false, onClick_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			case "value":
				buffer.readInt32();
				this.value = buffer.readBool();
				value_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			case "onClick":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onClick = _objectCache[index];
				} else {
					let onClick = this.onClick
					let _id = buffer.readInt32();
					if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
						this.onClick = onClick = new _lambdaContructors[_id]();
					onClick._id = _id;
					(_objectCache[-index] = onClick).deserialize_external(buffer);
				}
				onClick_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!label_is_set) this.label = "";
				if(!value_is_set) this.value = false;
				if(!type_is_set) this.type = 0/*Button*/;
				if(!onClick_is_set) this.onClick = null;
				return;
		}
	}
}
var statistics_backgroundColor;
var statistics_margin;
var statistics_position;
var statistics_size;
var statistics_labelPos;
var statistics_framesPerValue = 15;
var statistics_serverPings;
var statistics_successfullySentServerPings;
var statistics_series;
var statistics_systemLogs;
var statistics_gameLogs;
var statistics_successfullySentGameLogs;
var statistics_successfullySentSystemLogs;
var statistics_startTime;
var statistics_loadTime;
var statistics_connectTime;
var statistics_maxValue;
var statistics_currentSet;
var statistics_sets;
var statistics_id;
var statistics_infos;
var statistics_infoNames;
var statistics_currentlySendingStatistics;
function statistics_init() {
	statistics_backgroundColor = new Color("#202020", "");
	statistics_margin = new Vector2(224, 126, null);
	statistics_position = new Vector2(-960, 540, null);
	statistics_size = new Vector2(1920 + statistics_margin.x, statistics_margin.y, null);
	statistics_labelPos = new Vector2(970, 528, null);
	statistics_serverPings = [];
	statistics_successfullySentServerPings = 0;
	statistics_series = [];
	statistics_systemLogs = [];
	statistics_gameLogs = [];
	statistics_successfullySentGameLogs = 0;
	statistics_successfullySentSystemLogs = 0;
	statistics_startTime = 0.0;
	statistics_loadTime = 0.0;
	statistics_connectTime = 0.0;
	statistics_maxValue = 0.0;
	statistics_currentSet = 0;
	statistics_sets = 1;
	statistics_id = 0;
	statistics_infos = [];
	statistics_infoNames = [];
	statistics_currentlySendingStatistics = false;
}
function statistics_draw() {
	let startPos = Vector2_plus_Vector2(statistics_position, statistics_size);
	let labelPos = statistics_labelPos?.clone();
	let height = statistics_size.y - 20;
	for(let seriesIndex=0, _subject=statistics_series, _len=_subject.length; seriesIndex<_len; ++seriesIndex) { let s = _subject[seriesIndex]; {
		if(s.set != statistics_currentSet) {
			continue;
		}
		let text = s.lastValue()?.toString();
		graphics_drawRectangle(labelPos, new Vector2(8, 8, null), s.color, null, 0, null, 0, 1.0, 0/*Left*/, 1/*Middle*/, null);
		graphics_drawText(text, Vector2_plus_Vector2(labelPos, new Vector2(11, -2, null)), new Vector2(12, 0, null), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
		labelPos.x += graphics_getTextWidth(text, new Vector2(12, 0, null), null, 0/*Normal*/) + 20;
		let len = Math.min(s.values.length, Math.round(statistics_size.x));
		let prevY = 0;
		for(let i=0; i<len; ++i) {
			let value = s.values.get(-1 - i);
			let pos = new Vector2(startPos.x - i, startPos.y - ((value / statistics_maxValue) > 1 ? 1 : (value / statistics_maxValue)) * height + seriesIndex * 3, null);
			if(i) {
				graphics_drawRectangle(pos, new Vector2(4, prevY - pos.y + 4, null), s.color, null, 0, null, 0, 1.0, 1/*Center*/, 0/*Top*/, null);
			}
			prevY = pos.y;
		}
	}}
	for(let _subject=statistics_infos, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		let x = (core_frame - it.frame) / statistics_framesPerValue;
		if(x > statistics_size.x) {
			break;
		}
		graphics_drawText(it.value?.toString(), new Vector2(statistics_position.x + statistics_size.x - x, statistics_position.y + 10 * it.index, null), new Vector2(8, 0, null), null, 1/*Center*/, 0/*Top*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
	}}
	if(core_errorMessage) {
		graphics_drawText(core_errorMessage, statistics_position, new Vector2(12, 0, null), new Color("#ffff00", ""), 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
	}
	graphics_drawText("#"+core_frame?.toString()+" "+statistics_maxValue?.toString(), new Vector2(statistics_position.x + statistics_size.x - 8, labelPos.y, null), new Vector2(12, 0, null), null, 2/*Right*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
	graphics_drawRectangle(statistics_position, statistics_size, statistics_backgroundColor, null, 0, null, 0, 1.0, 0/*Left*/, 0/*Top*/, null);
}
function statistics_log(value) {
	value.frame = core_frame;
	statistics_gameLogs.push(value);
}
function statistics_startSession() {
	let user = JSON.parse(localStorage.getItem("user") || {});
	let server = location.host.getUntil(".", 0);
	let userId = input_localUser.id;
	statistics_id = core_roomId * 100 + userId;
	let sendingSystemLogsUntil = statistics_systemLogs.length;
	statistics_currentlySendingStatistics = true;
	http_postDirectly(""+Platform_protocolAndHost()+":3114/startSession", ({id:statistics_id, gameId:core_gameId, roomId:core_roomId, userId:userId, userIndex:input_localUser.index, userEmail:user.email, staging:Platform_isStaging, server:server, loadTime:statistics_loadTime-statistics_startTime, connectTime:statistics_connectTime-statistics_startTime, systemLogs:statistics_systemLogs.get3(statistics_successfullySentSystemLogs)}), result => {
		statistics_successfullySentSystemLogs = sendingSystemLogsUntil;
		statistics_currentlySendingStatistics = false;
	});
}
function statistics_saveStatistics() {
	if(statistics_currentlySendingStatistics) {
		return;
	}
	statistics_currentlySendingStatistics = true;
	let connections = [];
	let peerPingsToSend = [[], [], [], [], [], [], [], []];
	let sendingPeerLogsUntil = [0, 0, 0, 0, 0, 0, 0, 0];
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let p = _subject[i]; {
		let internalUser = input_internalUsers.get(p.id);
		connections.push(internalUser.connectionType);
		let inputFrameSeries = statistics_series.find(a => a.userIndex == p.index && a.set == 0);
		if((inputFrameSeries != null)) {
			peerPingsToSend.set(i * 2, inputFrameSeries.values.get3(inputFrameSeries.successfullySent));
			sendingPeerLogsUntil.set(i * 2, inputFrameSeries.values.length);
		}
		let bufferFrameSeries = statistics_series.find(a => a.userIndex == p.index && a.set == 1);
		if((bufferFrameSeries != null)) {
			peerPingsToSend.set(i * 2 + 1, bufferFrameSeries.values.get3(bufferFrameSeries.successfullySent));
			sendingPeerLogsUntil.set(i * 2 + 1, bufferFrameSeries.values.length);
		}
	}}
	let sendingServerPingsUntil = statistics_serverPings.length;
	let sendingSystemLogsUntil = statistics_systemLogs.length;
	let sendingGameLogsUntil = statistics_gameLogs.length;
	http_postDirectly(""+Platform_protocolAndHost()+":3114/saveStatistics", ({id:statistics_id, connections:connections, peerPings:peerPingsToSend, serverPings:statistics_serverPings.get3(statistics_successfullySentServerPings), systemLogs:statistics_systemLogs.get3(statistics_successfullySentSystemLogs), gameLogs:statistics_gameLogs.get3(statistics_successfullySentGameLogs)}), result => {
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let p = _subject[i]; {
			let inputFrameSeries = statistics_series.find(a => a.userIndex == p.index && a.set == 0);
			if((inputFrameSeries != null)) {
				inputFrameSeries.successfullySent = sendingPeerLogsUntil.get(i * 2);
			}
			let bufferFrameSeries = statistics_series.find(a => a.userIndex == p.index && a.set == 1);
			if((bufferFrameSeries != null)) {
				bufferFrameSeries.successfullySent = sendingPeerLogsUntil.get(i * 2 + 1);
			}
		}}
		statistics_successfullySentServerPings = sendingServerPingsUntil;
		statistics_successfullySentSystemLogs = sendingSystemLogsUntil;
		statistics_successfullySentGameLogs = sendingGameLogsUntil;
		statistics_currentlySendingStatistics = false;
	});
}
function statistics_add(name, value, color, set) {
	let s = statistics_series.find(a => a.name == name && a.set == set);
	if(!(s != null)) {
		statistics_series.push(s = new StatisticsGraphSeries(-1, set, name, [], [], color, 0));
		statistics_series.orderBy5(a => a.name);
		(set + 1 > statistics_sets ? statistics_sets = set + 1 : statistics_sets);
	}
	s.color = color;
	s.add(value);
}
function statistics_add2(userIndex, value, color, set) {
	let s = statistics_series.find(a => a.userIndex == userIndex && a.set == set);
	if(!(s != null)) {
		statistics_series.push(s = new StatisticsGraphSeries(userIndex, set, userIndex.toString(), [], [], color, 0));
		statistics_series.orderBy5(a => a.name);
		(set + 1 > statistics_sets ? statistics_sets = set + 1 : statistics_sets);
	}
	s.color = color;
	s.add(value);
}
function statistics_addInfo(name, value) {
	let index = statistics_infoNames.indexOf(name);
	if(index == -1) {
		index = statistics_infoNames.length;
		statistics_infoNames.push(name);
	}
	statistics_infos.push(new StatisticsInfo(value, index, core_frame));
}
function statistics_tick() {
	input_onTouchDownWithin(statistics_position, statistics_size, null, "auto", false, true, 0/*Left*/, 0/*Top*/, touch => {
		(statistics_currentSet = (((statistics_currentSet+1) % statistics_sets) + statistics_sets) % statistics_sets);
	});
	statistics_maxValue = 12;
	for(let i=0, _subject=statistics_series, _len=_subject.length; i<_len; ++i) { let s = _subject[i]; {
		if(s.set != statistics_currentSet) {
			continue;
		}
		let len = Math.min(s.values.length, 50);
		for(let i=0; i<len; ++i) {
			let value = s.values.get(-1 - i);
			if(value > statistics_maxValue) {
				statistics_maxValue = value;
			}
		}
	}}
	statistics_draw();
}
var networkVisualizer_posForPlayer;
function networkVisualizer_init() {
	networkVisualizer_posForPlayer = [0, -10000, -10000, -10000, -10000, -10000];
}
function networkVisualizer_draw() {
	if(core_simulateInputsForTesting) {
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			graphics_drawCircle(new Vector2(1110 + player.index * 20, -540 + networkVisualizer_posForPlayer.get(player.index), null), new Vector2(20, 0, null), player.color, null, 0, (-.25), 1.0, 0/*Clockwise*/, null, 0, 1.0, null);
		}}
	}
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		let internaluser = input_internalUsers.get(player.id);
		if((internaluser != null)) {
			let bufferY = 510 - networkVisualizer_getHeightForFrame(core_frame - internaluser.bufferFrames + 1);
			graphics_drawLine(new Vector2(960, bufferY, null), new Vector2(1100, bufferY, null), player.color, 3, null, 0, 1.0);
			graphics_drawText(internaluser.bufferFrames?.toString(), new Vector2(1110, bufferY, null), new Vector2(20, 0, null), player.color, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
			graphics_drawRectangle(new Vector2(984 + player.index * 32, 510, null), new Vector2(24, networkVisualizer_getHeightForFrame(internaluser.inputFrame), null), player.color, null, 0, null, 0, 1.0, 1/*Center*/, 2/*Bottom*/, null);
		}
	}}
	if(core_replayFrom != -1) {
		let bufferY = 510 - networkVisualizer_getHeightForFrame(core_replayFrom);
		graphics_drawLine(new Vector2(960, bufferY, null), new Vector2(1100, bufferY, null), Color_White, 3, null, 0, 1.0);
		graphics_drawText((core_frame - core_replayFrom)?.toString(), new Vector2(1110, bufferY, null), new Vector2(20, 0, null), Color_White, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, 0, 1.0, null);
	}
}
function networkVisualizer_tick() {
	if(core_simulateInputsForTesting) {
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(networkVisualizer_posForPlayer.get(it.index) == -10000) {
				networkVisualizer_posForPlayer.set(it.index, networkVisualizer_posForPlayer.get(0));
			}
		}}
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			core_smooth(player, () => {
				if(player.id == 1) {
					core_replayLog += "C";
				}
				input_onKeyDown2([player], (key,pressedBy) => {
					if(player.id == 1) {
						core_replayLog += "D";
					}
					if((networkVisualizer_posForPlayer.addToItem(player.index, 2)) > 1080) {
						networkVisualizer_posForPlayer.subtractFromItem(player.index, 1080);
					}
				});
			});
		}}
	}
	networkVisualizer_draw();
}
function networkVisualizer_getHeightForFrame(frame) {
	return (50 + frame - core_frame) * 20;
}
function networkVisualizer_serialize_internal(buffer) {
	if(networkVisualizer_posForPlayer) {
		var index = _objectCacheIndex.get(networkVisualizer_posForPlayer);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(networkVisualizer_posForPlayer, index = _objectCache.length);
			_objectCache.push(networkVisualizer_posForPlayer);
			buffer.writeInt32(-index);
			networkVisualizer_posForPlayer._objectIndex = index;
			buffer.writeInt32(networkVisualizer_posForPlayer.length);
			for(let i=0, len=networkVisualizer_posForPlayer.length; i<len; ++i) {
				buffer.writeInt32(networkVisualizer_posForPlayer[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function networkVisualizer_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		networkVisualizer_posForPlayer = _objectCache[index];
	} else {
		if(!networkVisualizer_posForPlayer || networkVisualizer_posForPlayer._objectIndex != -index) networkVisualizer_posForPlayer = [];
		_objectCache[-index] = networkVisualizer_posForPlayer;
		for(let i=0, len = networkVisualizer_posForPlayer.length = buffer.readInt32(); i<len; ++i) {
				networkVisualizer_posForPlayer[i] = buffer.readInt32();
		}
	}
}
function networkVisualizer_serialize_external(buffer) {
	buffer.writeString("posForPlayer");
	let networkVisualizer_posForPlayer_startPos = buffer.reserveSize();
	if(networkVisualizer_posForPlayer) {
		var index = _objectCacheIndex.get(networkVisualizer_posForPlayer);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(networkVisualizer_posForPlayer, index = _objectCache.length);
			_objectCache.push(networkVisualizer_posForPlayer);
			buffer.writeInt32(-index);
			networkVisualizer_posForPlayer._objectIndex = index;
			buffer.writeInt32(networkVisualizer_posForPlayer.length);
			for(let i=0, len=networkVisualizer_posForPlayer.length; i<len; ++i) {
				buffer.writeInt32(networkVisualizer_posForPlayer[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(networkVisualizer_posForPlayer_startPos);
	buffer.writeString("");
}
function networkVisualizer_deserialize_external(buffer) {
	let posForPlayer_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "posForPlayer":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					networkVisualizer_posForPlayer = _objectCache[index];
				} else {
					if(!networkVisualizer_posForPlayer || networkVisualizer_posForPlayer._objectIndex != -index) networkVisualizer_posForPlayer = [];
					_objectCache[-index] = networkVisualizer_posForPlayer;
					for(let i=0, len = networkVisualizer_posForPlayer.length = buffer.readInt32(); i<len; ++i) {
							networkVisualizer_posForPlayer[i] = buffer.readInt32();
					}
				}
				posForPlayer_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!posForPlayer_is_set) networkVisualizer_posForPlayer = [0, -10000, -10000, -10000, -10000, -10000];
				return;
		}
	}
}
function file_saveText(filename, text) {
	var element = document.createElement("a");
	element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
	element.setAttribute("download", filename);
	element.style.display = "none";
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}
function file_saveBinary(filename, buffer) {
	var binary = "";
	var bytes = new Uint8Array(buffer.buffer);
	var len = bytes.byteLength;
	for (var i = 0; i < len; i++) {
		binary += String.fromCharCode(bytes[i]);
	}
	var base64 = window.btoa( binary );
	var dataUrl = "data:text/plain;base64," + base64;
	
	var element = document.createElement("a");
	element.setAttribute("href", dataUrl);
	element.setAttribute("download", filename);
	element.style.display = "none";
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}
function file_openBinary(then, $else) {
	fileInput = document.createElement("input")
	fileInput.type = "file"
	fileInput.style.display = "none"
	fileInput.onchange = e => {
		var file = e.target.files[0];
		if (!file) {
			$else?.("")
			return
		}
		var reader = new FileReader();
		reader.onload = function(e) {
			let buffer = new Buffer(e.target.result, 0, 0, 0);
			document.body.removeChild(fileInput);
			then(buffer);
		}
		reader.onabort = e => {
			$else?.(reader.error)
		}
		reader.onerror = e => {
			$else?.(reader.error)
		}
		reader.readAsArrayBuffer(file)
	}
	document.body.appendChild(fileInput)
	fileInput.click()
}
var HTMLElement_elements;
function HTMLElement_init() {
	HTMLElement_elements = [];
}
function HTMLElement(position, size, color) {
	this.type = "HTMLElement";
	this.position = position?.clone();
	this.size = size?.clone();
	this.color = color;
	this.element = null;
	HTMLElement_elements.push(this);
}
function new_HTMLElement_of_type(type) {
	switch(type) {
		case "HTMLElement": return new _HTMLElement();
		case "HTMLInput": return new _HTMLInput();
	}
}
HTMLElement.prototype.tick = function() {
}
function HTMLElement_clear() {
	if(HTMLElement_elements) {
		for(let el of HTMLElement_elements) {
			el.remove()
		}
	}
}
HTMLElement.prototype.clone = function() {
	let clone = new _HTMLElement();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.color = this.color;
	clone.element = this.element;
	return clone;
}
function _HTMLElement() {};
_HTMLElement.prototype = HTMLElement.prototype;
function HTMLElement_serialize_internal(buffer) {
	if(HTMLElement_elements) {
		var index = _objectCacheIndex.get(HTMLElement_elements);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(HTMLElement_elements, index = _objectCache.length);
			_objectCache.push(HTMLElement_elements);
			buffer.writeInt32(-index);
			HTMLElement_elements._objectIndex = index;
			buffer.writeInt32(HTMLElement_elements.length);
			for(let i=0, len=HTMLElement_elements.length; i<len; ++i) {
				let HTMLElement_elements_item = HTMLElement_elements[i]
				if(HTMLElement_elements_item) {
					var index = _objectCacheIndex.get(HTMLElement_elements_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(HTMLElement_elements_item, index = _objectCache.length);
						_objectCache.push(HTMLElement_elements_item);
						buffer.writeInt32(-index);
						buffer.writeString(HTMLElement_elements_item.type);
						HTMLElement_elements_item._objectIndex = index;
						HTMLElement_elements_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function HTMLElement_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		HTMLElement_elements = _objectCache[index];
	} else {
		if(!HTMLElement_elements || HTMLElement_elements._objectIndex != -index) HTMLElement_elements = [];
		_objectCache[-index] = HTMLElement_elements;
		for(let i=0, len = HTMLElement_elements.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					HTMLElement_elements[i] = _objectCache[index];
				} else {
					let HTMLElement_elements_item = HTMLElement_elements[i]
					let type = buffer.readString();
					if(!HTMLElement_elements_item || HTMLElement_elements_item._objectIndex != -index)
						HTMLElement_elements[i] = HTMLElement_elements_item = new_HTMLElement_of_type(type);
					HTMLElement_elements_item.type = type;
					(_objectCache[-index] = HTMLElement_elements_item).deserialize_internal(buffer);
				}
		}
	}
}
HTMLElement.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
HTMLElement.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
function HTMLElement_serialize_external(buffer) {
	buffer.writeString("elements");
	let HTMLElement_elements_startPos = buffer.reserveSize();
	if(HTMLElement_elements) {
		var index = _objectCacheIndex.get(HTMLElement_elements);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(HTMLElement_elements, index = _objectCache.length);
			_objectCache.push(HTMLElement_elements);
			buffer.writeInt32(-index);
			HTMLElement_elements._objectIndex = index;
			buffer.writeInt32(HTMLElement_elements.length);
			for(let i=0, len=HTMLElement_elements.length; i<len; ++i) {
				let HTMLElement_elements_item = HTMLElement_elements[i]
				if(HTMLElement_elements_item) {
					var index = _objectCacheIndex.get(HTMLElement_elements_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(HTMLElement_elements_item, index = _objectCache.length);
						_objectCache.push(HTMLElement_elements_item);
						buffer.writeInt32(-index);
						buffer.writeString(HTMLElement_elements_item.type);
						HTMLElement_elements_item._objectIndex = index;
						HTMLElement_elements_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(HTMLElement_elements_startPos);
	buffer.writeString("");
}
function HTMLElement_deserialize_external(buffer) {
	let elements_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "elements":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					HTMLElement_elements = _objectCache[index];
				} else {
					if(!HTMLElement_elements || HTMLElement_elements._objectIndex != -index) HTMLElement_elements = [];
					_objectCache[-index] = HTMLElement_elements;
					for(let i=0, len = HTMLElement_elements.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								HTMLElement_elements[i] = _objectCache[index];
							} else {
								let HTMLElement_elements_item = HTMLElement_elements[i]
								let type = buffer.readString();
								if(!HTMLElement_elements_item || HTMLElement_elements_item._objectIndex != -index)
									HTMLElement_elements[i] = HTMLElement_elements_item = new_HTMLElement_of_type(type);
								HTMLElement_elements_item.type = type;
								(_objectCache[-index] = HTMLElement_elements_item).deserialize_external(buffer);
							}
					}
				}
				elements_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!elements_is_set) HTMLElement_elements = [];
				return;
		}
	}
}
HTMLElement.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
HTMLElement.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, color_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(1920, 100, null);
				if(!color_is_set) this.color = null;
				return;
		}
	}
}
var IndexedDB_db;
function IndexedDB_init() {
	IndexedDB_db = null;
}
function IndexedDB_start(databaseName, storeName, version) {
	try {
		core_log("IndexedDB: start");
		IndexedDB_storeName = storeName;
		var request = indexedDB.open(databaseName, version)
		request.onupgradeneeded = e => {
			core_log("IndexedDB: upgradeneeded");
			IndexedDB_db = e.target.result;
			if(!IndexedDB_db.objectStoreNames.contains(storeName))
				IndexedDB_db.createObjectStore(storeName, { keyPath: "id" });
			core_log("IndexedDB successfully upgraded to version "+version)
		}
		request.onsuccess = e => {
			IndexedDB_db = e.target.result;
			core_log("IndexedDB: success");
		}
		request.onerror = e => {
			core_log("IndexedDB: error "+request.error);
		}
		core_log("IndexedDB: finished");
	} catch(e) {
		core_log("IndexedDB: exception "+e.message)
	}
}
function IndexedDB_open(storeName, id, then, $else) {
	try {
		let trans = IndexedDB_db.transaction(storeName, "readonly")
		let req = trans.objectStore(IndexedDB_storeName).get(id)
		req.onsuccess = async e => {
			let result = req.result
			if(result) {
				then(result)
			} else {
				$else?.()
			}
		}
		req.onerror = e => {
			core_log("Error in IndexedDB.open: "+req.error)
			$else?.()
		}
	} catch(e) {
		core_log("Error in IndexedDB.open: "+e.message)
		$else?.()
	}
}
async function IndexedDB_openBuffer(storeName, id, then, $else) {
	try {
		let trans = IndexedDB_db.transaction(storeName, "readonly")
		let req = trans.objectStore(IndexedDB_storeName).get(id)
		req.onsuccess = async e => {
			let result = req.result
			if(result) {
				let arrayBuffer = await result.data.arrayBuffer()
				let buffer = new Buffer(arrayBuffer, 0, 0, 0)
				then(buffer)
			} else {
				$else?.()
			}
		}
		req.onerror = e => {
			core_log("Error in IndexedDB.open: "+req.error)
			$else?.()
		}
	} catch(e) {
		core_log("Error in IndexedDB.open: "+e.message)
		$else?.()
	}
}
function IndexedDB_save(storeName, data, then, $else) {
	try {
		let trans = IndexedDB_db.transaction(storeName, "readwrite")
		trans.onerror = e => {
			core_log("Error in IndexedDB.save: "+trans.error)
			$else?.()
		}
		trans.objectStore(IndexedDB_storeName).put(data).onsuccess = e => {
			then?.()
		}
	} catch(e) {
		core_log("Error in IndexedDB.save: "+e.message)
		$else?.()
	}
}
function IndexedDB_saveBuffer(storeName, id, buffer, then, $else) {
	try {
		let trans = IndexedDB_db.transaction(storeName, "readwrite")
		trans.onerror = e => {
			core_log("Error in IndexedDB.save: "+trans.error)
			$else?.()
		}
		let dataView = new DataView(buffer.buffer, 0, buffer.writePos)
		let data = new Blob([dataView])
		trans.objectStore(IndexedDB_storeName).put({id, data}).onsuccess = e => {
			then?.()
		}
	} catch(e) {
		core_log("Error in IndexedDB.save: "+e.message)
		$else?.()
	}
}
function RoomInfo(time, userId) {
	this.time = time;
	this.userId = userId;
}
RoomInfo.prototype.clone = function() {
	let clone = new _RoomInfo();
	clone.time = this.time;
	clone.userId = this.userId;
	return clone;
}
function _RoomInfo() {};
_RoomInfo.prototype = RoomInfo.prototype;
var core_eventStreamVersion;
var core_sendInterval;
var core_smoothStrength;
var core_smoothTouchPosition;
var core_simulateConnection;
var core_simulateInputsForTesting;
var core_simulateRollback;
var core_drawPointsForTesting;
var core_sendStatisticsEvery;
var core_showVideoForStaging;
var core_muteInvisibleUsers;
var core_sendInputsMode;
var core_targetFps = 30;
var core_targetFrameTime = 1000 / core_targetFps;
var core_mode;
var core_errorMessage;
var core_startTime;
var core_serverStartTime;
var core_frame;
var core_frames;
var core_frameWithNewWatches;
var core_startInLobby;
var core_joinFrame;
var core_isPremiere;
var core_checksums;
var core_lastChecksumFrame;
var core_lastPingTime;
var core_animationStartFrame;
var core_now;
var core_logTable;
var core_eventLog;
var core_replayLog;
var core_sentLog;
var core_receivedLog;
var core_writeLog;
var core_parseLog;
var core_touchLog;
var core_checksumLog;
var core_lastNetworkFrame;
var core_lastAnimationFrame;
var core_drawTime;
var core_tickTime;
var core_restoreTime;
var core_replayTime;
var core_saveTime;
var core_replayFrames;
var core_displayItems;
var core_tickMessageSize;
var core_logging;
var core_replayFrom;
var core_lastSendFrame;
var core_snapshot;
var core_secondSnapshotForTesting;
var core_snapshotFrame;
var core_nextSnapshotFrame;
var core_snapshotBuffer;
var core_roomString;
var core_roomId;
var core_gameId;
function core_init() {
	core_eventStreamVersion = 1;
	core_sendInterval = 1;
	core_smoothStrength = 90;
	core_smoothTouchPosition = true;
	core_simulateConnection = true;
	core_simulateInputsForTesting = false;
	core_simulateRollback = false;
	core_drawPointsForTesting = false;
	core_sendStatisticsEvery = (3*60000);
	core_showVideoForStaging = true;
	core_muteInvisibleUsers = false;
	core_sendInputsMode = 1/*Peer*/;
	core_mode = 0/*None*/;
	core_errorMessage = "";
	core_startTime = 0.0;
	core_serverStartTime = 0.0;
	core_frame = 0;
	core_frames = 0;
	core_frameWithNewWatches = 0;
	core_startInLobby = false;
	core_joinFrame = 0;
	core_isPremiere = false;
	core_checksums = [];
	core_lastChecksumFrame = 0;
	core_lastPingTime = 0.0;
	core_animationStartFrame = 0;
	core_now = 0.0;
	core_logTable = "frame,id,iframe,ahead,buffer,id,iframe,ahead,buffer,id,iframe,ahead,buffer,id,iframe,ahead,buffer,messageSize,now,animTime,networkTime,tickTime,drawTime,displayItems,iteration,restoreTime,replayFrames,replayTime,snapshotSize,saveTime,pingPong,checksums,events,replay,controller,send,receive,write,parse,touch\n";
	core_eventLog = "";
	core_replayLog = "";
	core_sentLog = "";
	core_receivedLog = "";
	core_writeLog = "";
	core_parseLog = "";
	core_touchLog = "";
	core_checksumLog = "";
	core_lastNetworkFrame = 0.0;
	core_lastAnimationFrame = 0.0;
	core_drawTime = 0.0;
	core_tickTime = 0.0;
	core_restoreTime = 0.0;
	core_replayTime = 0.0;
	core_saveTime = 0.0;
	core_replayFrames = 0;
	core_displayItems = 0;
	core_tickMessageSize = 0;
	core_logging = true;
	core_replayFrom = -1;
	core_lastSendFrame = 0;
	core_snapshot = new Buffer(null, 1024, 0, 0);
	core_secondSnapshotForTesting = new Buffer(null, 1024, 0, 0);
	core_snapshotFrame = -1;
	core_nextSnapshotFrame = -1;
	core_snapshotBuffer = new Buffer(null, 1024, 0, 0);
	core_roomString = "";
	core_roomId = 0;
	core_gameId = "";
}
function core_initDatabase() {
	IndexedDB_start("up4playing", "snapshot", 5);
}
function core_startConnected(frame) {
	if(core_mode == 3/*Connected*/) {
		return;
	}
	let user = input_localUser;
	user.startInputFrame(0);
	input_handleJoin(frame);
	user.collectInputs = true;
	if(core_logging) {
		core_writeLog += " #"+core_joinFrame?.toString()+" Join";
	}
	core_log("startConnected"+", joinFrame: "+core_joinFrame?.toString());
	core_frame = frame;
	core_mode = 3/*Connected*/;
	core_snapshotFrame = -1;
	core_nextSnapshotFrame = 0;
	core_checkSaveState();
	statistics_connectTime = performance.now();
	core_log("Connected"+", user.id: "+user.id?.toString()+", frame: "+frame?.toString()+", startTime: "+core_startTime?.toString()+", serverStartTime: "+core_serverStartTime?.toString());
}
function core_startLocal() {
	core_mode = 2/*Local*/;
	input_internalUsers.length = 0;
	math_setRandomSeed(math_generateRandomSeed());
	core_stop();
}
function core_stop() {
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.reset();
			it.startInputFrame(0);
		}
	}}
	core_startTime = core_serverStartTime = Date.now();
	core_frames = 0;
	core_frameWithNewWatches = 0;
	core_startInLobby = false;
	core_errorMessage = "";
	audio_stop();
	core_isPremiere = true;
	core_startTime = core_serverStartTime = Date.now();
	core_reset();
	core_animationFrame();
}
function core_record() {
	core_frames = core_frameWithNewWatches = core_frame;
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.writePos = it.inputs.readPos;
			it.startInputFrame(core_frame);
		}
	}}
	if(Platform_isDebug) {
		Platform_sendFrame(core_frame, core_frames);
	}
}
function core_reset() {
	input_players.length = 0;
	input_playersById.length = 0;
	core_errorMessage = "";
	HTMLElement_clear();
	math_randomValueIndex = 0;
	core_frame = 0;
	input_isCertain = true;
	lobby_inLobby = core_startInLobby;
	Time_now = core_serverStartTime;
	core_snapshotFrame = -1;
	core_checksums.length = 0;
	core_lastChecksumFrame = -1;
	audio_stop();
	core_initAll();
	if(!core_startInLobby) {
		for(let i=input_internalUsers.length; i<Platform_userCount; ++i) {
			input_internalUsers.push(new InternalUser(i, true, 0, 0, false, true, -1, 0, [], new Buffer(null, 1024, 0, 0), null, [], null, 0, null, null, null, "", false, false, 0));
		}
		if(input_internalUsers.length > Platform_userCount) {
			input_internalUsers.splice(Platform_userCount, input_internalUsers.length-Platform_userCount);
		}
		for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let internalUser = _subject[i]; {
			let user = new Player(internalUser.id, i, null, new Vector2(0.0, 0.0, null), 0);
			input_playersById.set(internalUser.id, user);
			input_players.push(user);
		}}
		let localUserId = (input_localUser?.id < input_internalUsers.length ? input_localUser.id : 0);
		input_localUser = input_internalUsers.get(localUserId);
		input_localPlayer = input_playersById.get(localUserId);
		input_updatePlayers();
	}
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputs.readPos = 0;
		}
	}}
	if(!core_startInLobby) {
		core_startApp();
	}
	if(core_simulateRollback) {
		core_checkSaveState();
	}
}
function core_restart() {
	core_initAll();
	let newPlayers = [];
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let user = new Player(it.id, i, null, new Vector2(0.0, 0.0, null), 0);
		input_playersById.set(it.id, user);
		newPlayers.push(user);
	}}
	input_players = newPlayers;
	let localUserId = (input_localUser?.id < input_internalUsers.length ? input_localUser.id : 0);
	input_localUser = input_internalUsers.get(localUserId);
	input_localPlayer = input_playersById.get(localUserId);
	input_updatePlayers();
	core_startApp();
}
function core_goToFrame(targetFrame, replayFromStart) {
	core_isPremiere = false;
	if(replayFromStart) {
		core_frameWithNewWatches = 0;
	}
	if(targetFrame < core_frame || replayFromStart) {
		core_reset();
	}
	while(core_frame < targetFrame) {
		core_step(true, false);
	}
	core_adjustStartTime();
	core_animationFrame();
	core_isPremiere = true;
}
function core_smooth(player, $do) {
	let user = input_internalUsers.get(player.id);
	if((user != null) && (user.local || core_frame <= user.smoothFrame)) {
		$do();
	}
}
function core_animationFrame() {
	core_now = Date.now();
	ServerNetwork_ping();
	if(core_mode == 0/*None*/ || core_mode == 1/*Ping*/) {
		graphics_startFrame();
		lobby_tick();
		graphics_finishFrame();
		return;
	} else {
		if(core_mode == 3/*Connected*/) {
			PeerNetwork_processSendStateQueue();
		}
	}
	let targetFrame = Math.floor((core_now - core_startTime) / core_targetFrameTime) + 1;
	if(core_mode == 2/*Local*/ && targetFrame > core_frame + core_targetFps * 2) {
		let prevTargetFrame = targetFrame;
		targetFrame = core_frame;
		core_startTime = Math.round(core_now - targetFrame * core_targetFrameTime);
		core_log(("Paused "+(prevTargetFrame - core_frame)?.toString()+" frames, adjusting startTime. prevTargetTime:"+prevTargetFrame?.toString()+" frame:"+core_frame?.toString()+" targetFrame:"+Math.floor((core_now - core_startTime) / core_targetFrameTime)?.toString()));
	}
	if(core_frame < targetFrame) {
		if(core_simulateInputsForTesting && (input_localUser != null) && input_localUser.collectInputs) {
			for(let i=core_frame; i<targetFrame; ++i) {
				input_handleKeyEvent(5/*KeyDown*/, 135/*F24*/, "");
			}
		}
		core_animationStartFrame = core_frame;
		try {
			core_sendInputs(targetFrame - 1);
			core_checkRewindAndReplayState();
		} catch(error) {
			core_onError(error);
		}
		while(core_frame < targetFrame) {
			for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
				if(user?.local) {
					user.startInputFrame(core_frame + 1);
				}
			}}
			core_step(false, core_frame == targetFrame - 1);
			core_collectStatistics();
			core_lastNetworkFrame = core_now;
		}
	}
	core_lastAnimationFrame = core_now;
	if(Platform_mode == 3/*Play*/ && core_frame >= core_frames) {
		Platform_record();
	}
	if(Date.now()-core_lastPingTime>1000) {
		core_lastPingTime = Date.now();
		PeerNetwork_ping();
	}
}
function core_collectStatistics() {
	if(core_mode == 3/*Connected*/ && input_players.length > 1 && core_frame > core_joinFrame + 120) {
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let internalUser = input_internalUsers.get(it.id);
			if(!internalUser.local) {
				internalUser.collectStatistics(core_frame);
				statistics_add2(it.index, core_frame - internalUser.inputFrame, it.color, 0);
				statistics_add2(it.index, core_frame - internalUser.smoothFrame, it.color, 1);
			}
		}}
		if(core_replayFrom != -1) {
			statistics_add("replay", core_frame - core_replayFrom, Color_Gray, 0);
		}
	} else {
		if(core_mode == 2/*Local*/ && core_simulateRollback) {
			for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				it.simulateRollback(core_frame);
			}}
		}
	}
	if(core_logging) {
		try {
			core_logTable += ""+(core_frame - 1)?.toString();
			for(let i=0; i<4; ++i) {
				let user = input_internalUsers.find(a => a.index == i);
				if((user != null)) {
					core_logTable += ","+user.id?.toString()+","+user.inputFrame?.toString()+","+(core_frame - user.inputFrame)?.toString()+","+user.bufferFrames?.toString();
				} else {
					core_logTable += ",,,,";
				}
			}
			core_logTable += ","+core_tickMessageSize?.toString()+","+core_now?.toString()+","+(core_now - core_lastAnimationFrame)?.toString()+","+(core_now - core_lastNetworkFrame)?.toString()+","+core_tickTime.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+","+core_drawTime.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+","+core_displayItems?.toString()+","+(core_frame - core_animationStartFrame)?.toString();
			core_logTable += ","+core_restoreTime.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+","+core_replayFrames?.toString()+","+core_replayTime.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+","+core_snapshot.writePos?.toString()+","+core_saveTime.toLocaleString("en-US", {maximumFractionDigits:2, minimumFractionDigits:2, minimumIntegerDigits:1, useGrouping:false})+","+ServerNetwork_lastPingPongTime?.toString();
			core_logTable += ",\""+core_checksumLog.trim()+"\",\""+core_eventLog.trim()+"\",\""+core_replayLog.trim()+"\",\""+input_players.get(0)?.controller?.leftStick?.toString()+"\",\""+core_sentLog.trim()+"\",\""+core_receivedLog.trim()+"\",\""+core_writeLog.trim()+"\",\""+core_parseLog.trim()+"\",\""+core_touchLog.trim()+"\"\n";
		} catch(error) {
			core_onError(error);
		}
		core_eventLog = "";
		core_replayLog = "";
		core_sentLog = "";
		core_receivedLog = "";
		core_writeLog = "";
		core_parseLog = "";
		core_touchLog = "";
		core_checksumLog = "";
		ServerNetwork_lastPingPongTime = 0;
		core_tickMessageSize = 0;
	}
}
function core_sendInputs(inputFrame) {
	if(core_mode != 3/*Connected*/) {
		return;
	}
	if(core_frame >= core_lastSendFrame + core_sendInterval) {
		if(core_sendInputsMode == 1/*Peer*/) {
			PeerNetwork_sendInputs(inputFrame);
		}
		if(core_sendInputsMode == 2/*Server*/) {
			ServerNetwork_sendInputs(inputFrame);
		}
		core_lastSendFrame = core_frame;
	}
}
function core_switchUser(userIndex) {
	let prevPlayer = input_localPlayer;
	input_localPlayer = input_players.get(userIndex);
	input_localUser = input_internalUsers.find(a => a.id == input_localPlayer.id);
	for(let i=0, _subject=prevPlayer.touches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		input_handleUpdateTouchAfterSwitchingUser(it.id, it.referencePosition);
	}}
}
function core_switchSendInterval(sendInterval) {
	core_sendInterval = sendInterval;
	ServerNetwork_sendSwitch(core_sendInputsMode, sendInterval);
}
function core_switchSendInputMode(sendInputsMode) {
	core_sendInputsMode = sendInputsMode;
	ServerNetwork_sendSwitch(sendInputsMode, core_sendInterval);
}
function core_step(fastForward, draw) {
	try {
		Time_now = (core_serverStartTime + Math.round(core_frame * core_targetFrameTime));
		Platform_fastForward = fastForward;
		let certainFrame = input_internalUsers.min4(a => Math.min(a.inputFrame, a.smoothFrame), int_maxValue, 0, a => a.active);
		let isCertain = core_frame <= certainFrame;
		if(Platform_isDebug && !fastForward && (Platform_mode == 4/*Record*/ || Platform_mode == 3/*Play*/ || Platform_waitingForInitialData)) {
			Platform_sendFrame(core_frame, Math.max(core_frame + 1, core_frames));
		}
		core_checkSaveState();
		if(core_logging) {
			core_replayLog += " #"+core_frame?.toString()+" c:"+certainFrame?.toString();
			core_parseLog += " #"+core_frame?.toString();
			if(fastForward) {
				core_parseLog += "f";
				core_replayLog += "f";
			}
			if(isCertain) {
				core_parseLog += "c";
				core_replayLog += "c";
			}
		}
		input_updateGameControllers();
		input_handleLost();
		input_parseInputs(core_frame);
		Physics_step();
		core_tick(draw);
		if((HTMLElement_elements != null && HTMLElement_elements?.length != 0) ) {
			for(let i=0, _subject=HTMLElement_elements, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				it.tick();
			}}
		}
	} catch(error) {
		core_onError(error);
	}
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.clearEvent();
		}
	}}
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.clearEvents();
	}}
	core_frame++;
	if(core_frames < core_frame) {
		core_frames = core_frame;
	}
	if(core_frameWithNewWatches < core_frame) {
		core_frameWithNewWatches = core_frame;
	}
}
function core_tick(draw) {
	graphics_startFrame();
	if(draw && !Platform_waitingForInitialData) {
		if(input_showPointers || Platform_mode == 3/*Play*/) {
			for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				graphics_drawPointer(it, (Platform_isDebug ? 1/*Local*/ : input_showPointersMode), null);
			}}
		}
	}
	audio_startFrame();
	if(Platform_showDebugInfo) {
		if(draw) {
			statistics_tick();
		}
		networkVisualizer_tick();
	}
	try {
		if(lobby_inLobby) {
			lobby_tick();
		} else {
			Framework_tick();
			core_tickTime = Time_measure(() => {
				core_appTick();
			});
		}
	} catch(error) {
		core_onError(error);
	}
	if(draw && !Platform_waitingForInitialData) {
		core_drawTime = Time_measure(() => {
			graphics_finishFrame();
		});
		if(Platform_mode != 1/*Manipulator*/) {
			input_updateCursor();
		}
	}
	audio_finishFrame();
}
function core_appTick() {
	if(window.app_tick) app_tick();
}
function core_appDebugString() {
	(window.app_debugString || "")
}
function core_checkRewindAndReplayState() {
	if((core_mode != 3/*Connected*/ && !core_simulateRollback) || input_internalUsers.length == 1) {
		return;
	}
	if(core_mode == 2/*Local*/ && core_simulateRollback) {
		core_nextSnapshotFrame = core_frame - 5;
	} else {
		core_nextSnapshotFrame = (input_internalUsers.min4(a => Math.min(a.smoothFrame, a.inputFrame), int_maxValue, 0, a => a.active && !a.local)) + 1;
	}
	core_replayLog += "(next:"+core_nextSnapshotFrame?.toString()+")";
	if(core_snapshotFrame != -1) {
		core_rewindAndReplayState(core_snapshot, core_snapshotFrame);
	}
}
function core_rewindAndReplayState(snapshot, snapshotFrame) {
	core_replayLog += " rewind to "+snapshotFrame?.toString()+"(";
	core_restoreTime = Time_measure(() => {
		snapshot.rewind();
		deserialize_internal(snapshot);
		let userCount = snapshot.readInt();
		for(let i=0; i<userCount; ++i) {
			let user = input_internalUsers.get(i);
			user.inputs.readPos = snapshot.readInt();
		}
	});
	core_replayLog += ")";
	let targetFrame = core_frame;
	core_frame = core_replayFrom = snapshotFrame;
	core_replayFrames = targetFrame - core_frame;
	core_snapshotFrame = -1;
	core_replayLog += "\{";
	core_replayTime = Time_measure(() => {
		while(core_frame < targetFrame) {
			core_step(true, false);
		}
	});
	core_replayLog += "\} ";
}
function core_checkSaveState() {
	if(core_mode != 3/*Connected*/ && !core_simulateRollback) {
		return;
	}
	if(core_snapshotFrame == -1 && core_frame >= core_nextSnapshotFrame) {
		core_replayLog += " save"+core_frame?.toString()+"(";
		core_snapshotFrame = core_frame;
		core_saveState(core_snapshot);
		core_replayLog += ")";
	}
}
function core_saveState(snapshot) {
	snapshot.reset();
	core_saveTime = Time_measure(() => {
		serialize_internal(snapshot);
	});
	if(core_simulateRollback) {
		deserialize_internal(snapshot);
		serialize_internal(core_secondSnapshotForTesting);
		if(Buffer_notEqual_Buffer(snapshot, core_secondSnapshotForTesting)) {
			core_onError(new Error("Inconsistent serialization", ""));
		}
	}
	if(input_players.length >= 2 && core_frame > 200) {
		let myChecksum = snapshot.checksum();
		let theirChecksum = core_checksums.get(core_frame);
		if(core_logging) {
			core_checksumLog += " <"+input_localUser.id?.toString()+"*> #"+core_frame?.toString()+" "+myChecksum?.toString()+" writePos:"+snapshot.writePos?.toString();
		}
		if(!theirChecksum) {
			core_checksums.set(core_frame, myChecksum);
		} else {
			if(!(Math.abs(theirChecksum - myChecksum) < 0.00001)) {
				core_onWrongChecksum(core_frame, myChecksum, theirChecksum);
			}
		}
		core_lastChecksumFrame = core_frame;
	}
	snapshot.writeInt(input_internalUsers.length);
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		snapshot.writeInt(it.inputs.readPos);
	}}
	core_replayLog += "sn.writepos:"+snapshot.writePos?.toString()+" ";
}
function core_log(text) {
	let str = new Date().hourMinuteSecondString() + " " + text
	statistics_systemLogs.push(str)
	if(core_logging) {
		core_eventLog += str + "\n"
		console.log(str)
	}
}
function core_startApp() {
	lobby_inLobby = false
	if(window.app_start) app_start()
}
function core_adjustStartTime() {
	core_startTime = Math.round(Date.now() - core_frame * core_targetFrameTime - (core_targetFrameTime * .5));
}
function core_adjustStartTimeIfNeeded() {
	if(Platform_mode < 3/*Play*/) {
		core_adjustStartTime();
	}
}
function core_saveEventStreamAndLogs() {
	if(input_isCertain) {
		core_saveEventStream();
		setTimeout(() => {
			core_saveLogs();
		}, (1*1000));
	}
}
function core_saveLogs() {
	core_logTable += ",,,,,,,,,,,,,,,,,,,,,,,,\""+core_eventLog.trim()+"\"";
	file_saveText(""+input_localUser.id?.toString()+" "+appName?.toString()+" "+new Date(Time_now).invariantDayMonthYearHourMinuteSecondString(Loca_language)+" v"+version?.toString()+".csv", core_logTable);
}
function core_saveEventStream() {
	let buffer = new Buffer(null, 1024, 0, 0);
	buffer.writeInt(core_eventStreamVersion);
	buffer.writeInt(core_frame - 1);
	buffer.writeInt(core_frames);
	buffer.writeString(math_randomSeed);
	buffer.writeBool(core_startInLobby);
	buffer.writeBool(Platform_isStaging);
	let userCount = input_internalUsers.count(a => a != null);
	buffer.writeInt8(userCount);
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			buffer.writeInt(it.id);
			buffer.writeBool(it.local);
			buffer.writeBuffer(it.inputs);
		}
	}}
	let date = new Date(Time_now);
	file_saveBinary(""+appName?.toString()+" "+date.dayShortMonthNameYearString(Loca_language)+" "+date.hourMinuteSecondString(Loca_language)+" v"+version?.toString()+".state", buffer);
}
function core_openEventStream() {
	Platform_pause();
	file_openBinary(buffer => {
		let version = buffer.readInt();
		let targetFrame = buffer.readInt();
		core_frames = buffer.readInt();
		let randomSeed = buffer.readString();
		core_startInLobby = buffer.readBool();
		Platform_isStaging = buffer.readBool();
		let userCount = buffer.readInt8();
		input_internalUsers.length = 0;
		for(let i=0; i<userCount; ++i) {
			let user = new InternalUser(buffer.readInt(), buffer.readBool(), 0, 0, false, false, -1, 0, [], new Buffer(null, 1024, 0, 0), null, [], null, 0, null, null, null, "", false, false, 0);
			if(user.local) {
				input_localUser = user;
			}
			buffer.readBuffer(user.inputs, 0);
			input_internalUsers.set(user.id, user);
		}
		for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if((it != null)) {
				it.collectInputs = true;
				if(Platform_isDebug) {
					it.local = true;
				}
				it.startInputFrame(core_frames);
			}
		}}
		math_setRandomSeed(randomSeed);
		Platform_sendClearTimeline();
		core_goToFrame(targetFrame, true);
		Platform_sendFrame(targetFrame, core_frames);
	}, null);
}
function core_join(gameId, roomString, userId) {
	setTimeout(() => {
		statistics_startSession();
		if(core_sendStatisticsEvery) {
			Platform_setInterval(core_sendStatisticsEvery, () => {
				statistics_saveStatistics();
			});
		}
	}, (30*1000));
	core_isPremiere = true;
	core_initAll();
	core_log("Platform.url: "+location.href);
	core_log("Date.realtime.dayMonthYearHourMinuteSecondString: "+new Date().dayMonthYearHourMinuteSecondString(Loca_language));
	core_log("Platform.userAgent: "+navigator.userAgent.replace(/,/g," ")?.toString());
	core_startInLobby = true;
	core_gameId = gameId;
	core_roomString = roomString;
	core_roomId = parseInt(roomString);
	input_localUser = new InternalUser(userId, true, 0, 0, false, false, -1, 0, [], new Buffer(null, 1024, 0, 0), null, [], null, 0, null, null, null, "", false, false, 0);
	core_setupVideoAndNetwork();
	lobby_enableFullscreen = !Platform_isStaging;
}
function core_initAll() {
	init()
	graphics_updateBaseMatrix();
}
async function core_setupVideoAndNetwork() {
	await PeerNetwork_setupLocalMedia(/*enableVideo*/!Platform_isStaging || core_showVideoForStaging, /*enableAudio*/!Platform_isStaging)
	ServerNetwork_setup()
}
function core_storeUserId() {
	localStorage.setItem("room" + core_roomId, JSON.stringify(new RoomInfo(Date.now(), input_localUser.id)));
}
function core_onWrongChecksum(frame, mine, theirs) {
	let message = "Out of sync. frame:"+frame?.toString()+" mine:"+mine?.toString()+" theirs:"+theirs?.toString();
	if(core_logging) {
		core_checksumLog += message;
	}
	core_onError(new Error(message, ""));
}
function core_onError(error) {
	core_errorMessage = error.stack;
	if(core_logging) {
		core_eventLog += core_errorMessage + "\n";
	}
	statistics_systemLogs.push(core_errorMessage);
	if(window.sendErrorToEditor) sendErrorToEditor(error)
	else console.error(error);
}
var Snapshot_autoSaveCount;
var Snapshot_lastSnapshotSize;
var Snapshot_snapshots;
var Snapshot_snapshotStarts;
var Snapshot_snapshotEvery;
var Snapshot_autoSaveAtEndOfStep;
function Snapshot_init() {
	Snapshot_autoSaveCount = 0;
	Snapshot_lastSnapshotSize = 0;
	Snapshot_snapshots = new Buffer(null, 1024, 0, 0);
	Snapshot_snapshotStarts = [];
	Snapshot_snapshotEvery = 100;
	Snapshot_autoSaveAtEndOfStep = false;
}
function Snapshot_toString(value) {
	let buffer = new Buffer(null, 1024, 0, 0);
	setup_serialize();
	value.serialize_external(buffer);
	return btoa(String.fromCharCode(...new Uint8Array(buffer.buffer, 0, buffer.writePos))); 
}
function Snapshot_fromString(value, base64String) {
	let bytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0))
	let buffer = new Buffer(bytes.buffer,0,0,0);
	setup_deserialize();
	value.deserialize_external(buffer);
}
function Snapshot_fromBase64(value, base64String) {
	let bytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0))
	let buffer = new Buffer(bytes.buffer,0,0,0);
	setup_deserialize();
	value.deserialize_internal(buffer);
}
function Snapshot_save() {
	let buffer = new Buffer(null, 1024, 0, 0);
	serialize_internal(buffer);
	return buffer;
}
function Snapshot_restore(buffer) {
	deserialize_internal(buffer);
}
function Snapshot_autoSave() {
	Snapshot_autoSaveAtEndOfStep = true;
}
function Snapshot_onEndOfStep() {
	if(input_isCertain) {
		if(Snapshot_autoSaveAtEndOfStep && ++Snapshot_autoSaveCount > 5) {
			let snap = Snapshot_save();
			IndexedDB_saveBuffer("snapshot", ""+core_gameId+"-0", snap, null, null);
			Snapshot_lastSnapshotSize = snap.writePos;
		}
		if(core_frame / Snapshot_snapshotEvery > Snapshot_snapshotStarts.length) {
			Snapshot_snapshotStarts.push(Snapshot_snapshots.writePos);
			serialize_internal(Snapshot_snapshots);
		}
		Snapshot_autoSaveAtEndOfStep = false;
	}
}
function StatisticsGraphSeries(userIndex, set, name, values, recentValues, color, successfullySent) {
	this.userIndex = userIndex;
	this.set = set;
	this.name = name;
	this.values = values;
	this.recentValues = recentValues;
	this.color = color;
	this.successfullySent = successfullySent;
}
StatisticsGraphSeries.prototype.lastValue = function() {
	return (this.values.length > 0 ? this.values.get(this.values.length - 1) : 0);
}
StatisticsGraphSeries.prototype.add = function(value) {
	this.recentValues.push(value);
	if(this.recentValues.length >= statistics_framesPerValue) {
		this.values.push(this.recentValues.max2(a => a, -Number.MAX_VALUE, 0));
		this.recentValues.length = 0;
	}
}
StatisticsGraphSeries.prototype.clone = function() {
	let clone = new _StatisticsGraphSeries();
	clone.userIndex = this.userIndex;
	clone.set = this.set;
	clone.name = this.name;
	clone.values = this.values;
	clone.recentValues = this.recentValues;
	clone.color = this.color;
	clone.successfullySent = this.successfullySent;
	return clone;
}
function _StatisticsGraphSeries() {};
_StatisticsGraphSeries.prototype = StatisticsGraphSeries.prototype;
StatisticsGraphSeries.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.userIndex);
	buffer.writeInt32(this.set);
	buffer.writeString(this.name);
	let values = this.values
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let recentValues = this.recentValues
	if(recentValues) {
		var index = _objectCacheIndex.get(recentValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(recentValues, index = _objectCache.length);
			_objectCache.push(recentValues);
			buffer.writeInt32(-index);
			recentValues._objectIndex = index;
			buffer.writeInt32(recentValues.length);
			for(let i=0, len=recentValues.length; i<len; ++i) {
				buffer.writeFloat64(recentValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.successfullySent);
}
StatisticsGraphSeries.prototype.deserialize_internal = function(buffer) {
	this.userIndex = buffer.readInt32();
	this.set = buffer.readInt32();
	this.name = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.values = _objectCache[index];
	} else {
		let values = this.values
		if(!values || values._objectIndex != -index) this.values = values = [];
		_objectCache[-index] = values;
		for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
				values[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.recentValues = _objectCache[index];
	} else {
		let recentValues = this.recentValues
		if(!recentValues || recentValues._objectIndex != -index) this.recentValues = recentValues = [];
		_objectCache[-index] = recentValues;
		for(let i=0, len = recentValues.length = buffer.readInt32(); i<len; ++i) {
				recentValues[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	this.successfullySent = buffer.readInt32();
}
StatisticsGraphSeries.prototype.serialize_external = function(buffer) {
	buffer.writeString("userIndex");
	buffer.writeInt32(4);
	buffer.writeInt32(this.userIndex);
	buffer.writeString("set");
	buffer.writeInt32(4);
	buffer.writeInt32(this.set);
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("values");
	let values = this.values
	let values_startPos = buffer.reserveSize();
	if(values) {
		var index = _objectCacheIndex.get(values);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(values, index = _objectCache.length);
			_objectCache.push(values);
			buffer.writeInt32(-index);
			values._objectIndex = index;
			buffer.writeInt32(values.length);
			for(let i=0, len=values.length; i<len; ++i) {
				buffer.writeFloat64(values[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(values_startPos);
	buffer.writeString("recentValues");
	let recentValues = this.recentValues
	let recentValues_startPos = buffer.reserveSize();
	if(recentValues) {
		var index = _objectCacheIndex.get(recentValues);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(recentValues, index = _objectCache.length);
			_objectCache.push(recentValues);
			buffer.writeInt32(-index);
			recentValues._objectIndex = index;
			buffer.writeInt32(recentValues.length);
			for(let i=0, len=recentValues.length; i<len; ++i) {
				buffer.writeFloat64(recentValues[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(recentValues_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("successfullySent");
	buffer.writeInt32(4);
	buffer.writeInt32(this.successfullySent);
	buffer.writeString("");
}
StatisticsGraphSeries.prototype.deserialize_external = function(buffer) {
	let userIndex_is_set = false, set_is_set = false, name_is_set = false, values_is_set = false, recentValues_is_set = false, color_is_set = false, successfullySent_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "userIndex":
				buffer.readInt32();
				this.userIndex = buffer.readInt32();
				userIndex_is_set = true;
				break;
			case "set":
				buffer.readInt32();
				this.set = buffer.readInt32();
				set_is_set = true;
				break;
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "values":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.values = _objectCache[index];
				} else {
					let values = this.values
					if(!values || values._objectIndex != -index) this.values = values = [];
					_objectCache[-index] = values;
					for(let i=0, len = values.length = buffer.readInt32(); i<len; ++i) {
							values[i] = buffer.readFloat64();
					}
				}
				values_is_set = true;
				break;
			case "recentValues":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.recentValues = _objectCache[index];
				} else {
					let recentValues = this.recentValues
					if(!recentValues || recentValues._objectIndex != -index) this.recentValues = recentValues = [];
					_objectCache[-index] = recentValues;
					for(let i=0, len = recentValues.length = buffer.readInt32(); i<len; ++i) {
							recentValues[i] = buffer.readFloat64();
					}
				}
				recentValues_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "successfullySent":
				buffer.readInt32();
				this.successfullySent = buffer.readInt32();
				successfullySent_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!userIndex_is_set) this.userIndex = -1;
				if(!set_is_set) this.set = 0;
				if(!name_is_set) this.name = null;
				if(!values_is_set) this.values = [];
				if(!recentValues_is_set) this.recentValues = [];
				if(!color_is_set) this.color = null;
				if(!successfullySent_is_set) this.successfullySent = 0;
				return;
		}
	}
}
function StatisticsInfo(value, index, frame) {
	this.value = value;
	this.index = index;
	this.frame = frame;
}
StatisticsInfo.prototype.clone = function() {
	let clone = new _StatisticsInfo();
	clone.value = this.value;
	clone.index = this.index;
	clone.frame = this.frame;
	return clone;
}
function _StatisticsInfo() {};
_StatisticsInfo.prototype = StatisticsInfo.prototype;
StatisticsInfo.prototype.serialize_internal = function(buffer) {
	buffer.writeFloat64(this.value);
	buffer.writeInt32(this.index);
	buffer.writeInt32(this.frame);
}
StatisticsInfo.prototype.deserialize_internal = function(buffer) {
	this.value = buffer.readFloat64();
	this.index = buffer.readInt32();
	this.frame = buffer.readInt32();
}
StatisticsInfo.prototype.serialize_external = function(buffer) {
	buffer.writeString("value");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.value);
	buffer.writeString("index");
	buffer.writeInt32(4);
	buffer.writeInt32(this.index);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("");
}
StatisticsInfo.prototype.deserialize_external = function(buffer) {
	let value_is_set = false, index_is_set = false, frame_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "value":
				buffer.readInt32();
				this.value = buffer.readFloat64();
				value_is_set = true;
				break;
			case "index":
				buffer.readInt32();
				this.index = buffer.readInt32();
				index_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!value_is_set) this.value = 0.0;
				if(!index_is_set) this.index = 0;
				if(!frame_is_set) this.frame = 0;
				return;
		}
	}
}
function AStarNode(pos, f, g, h, cost, visited, closed, parent) {
	this.pos = pos?.clone();
	this.f = f;
	this.g = g;
	this.h = h;
	this.cost = cost;
	this.visited = visited;
	this.closed = closed;
	this.parent = parent;
}
AStarNode.prototype.clone = function() {
	let clone = new _AStarNode();
	clone.pos = this.pos.clone();
	clone.f = this.f;
	clone.g = this.g;
	clone.h = this.h;
	clone.cost = this.cost;
	clone.visited = this.visited;
	clone.closed = this.closed;
	clone.parent = this.parent;
	return clone;
}
function _AStarNode() {};
_AStarNode.prototype = AStarNode.prototype;
AStarNode.prototype.serialize_internal = function(buffer) {
	(this.pos || new _IntVector2()).serialize_internal(buffer);
	buffer.writeInt32(this.f);
	buffer.writeInt32(this.g);
	buffer.writeInt32(this.h);
	buffer.writeInt32(this.cost);
	buffer.writeBool(this.visited);
	buffer.writeBool(this.closed);
	let parent = this.parent
	if(parent) {
		var index = _objectCacheIndex.get(parent);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(parent, index = _objectCache.length);
			_objectCache.push(parent);
			buffer.writeInt32(-index);
			parent._objectIndex = index;
			parent.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
AStarNode.prototype.deserialize_internal = function(buffer) {
	(this.pos || (this.pos = new _IntVector2())).deserialize_internal(buffer);
	this.f = buffer.readInt32();
	this.g = buffer.readInt32();
	this.h = buffer.readInt32();
	this.cost = buffer.readInt32();
	this.visited = buffer.readBool();
	this.closed = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.parent = _objectCache[index];
	} else {
		let parent = this.parent
		if(!parent || parent._objectIndex != -index)
			this.parent = parent = new _AStarNode();
		(_objectCache[-index] = parent).deserialize_internal(buffer);
	}
}
AStarNode.prototype.serialize_external = function(buffer) {
	buffer.writeString("pos");
	let pos_startPos = buffer.reserveSize();
	(this.pos || new _IntVector2()).serialize_external(buffer);
	buffer.writeSize(pos_startPos);
	buffer.writeString("f");
	buffer.writeInt32(4);
	buffer.writeInt32(this.f);
	buffer.writeString("g");
	buffer.writeInt32(4);
	buffer.writeInt32(this.g);
	buffer.writeString("h");
	buffer.writeInt32(4);
	buffer.writeInt32(this.h);
	buffer.writeString("cost");
	buffer.writeInt32(4);
	buffer.writeInt32(this.cost);
	buffer.writeString("visited");
	buffer.writeInt32(1);
	buffer.writeBool(this.visited);
	buffer.writeString("closed");
	buffer.writeInt32(1);
	buffer.writeBool(this.closed);
	buffer.writeString("parent");
	let parent_startPos = buffer.reserveSize();
	let parent = this.parent
	if(parent) {
		var index = _objectCacheIndex.get(parent);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(parent, index = _objectCache.length);
			_objectCache.push(parent);
			buffer.writeInt32(-index);
			parent._objectIndex = index;
			parent.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(parent_startPos);
	buffer.writeString("");
}
AStarNode.prototype.deserialize_external = function(buffer) {
	let pos_is_set = false, f_is_set = false, g_is_set = false, h_is_set = false, cost_is_set = false, visited_is_set = false, closed_is_set = false, parent_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pos":
				buffer.readInt32();
				(this.pos || (this.pos = new _IntVector2())).deserialize_external(buffer);
				pos_is_set = true;
				break;
			case "f":
				buffer.readInt32();
				this.f = buffer.readInt32();
				f_is_set = true;
				break;
			case "g":
				buffer.readInt32();
				this.g = buffer.readInt32();
				g_is_set = true;
				break;
			case "h":
				buffer.readInt32();
				this.h = buffer.readInt32();
				h_is_set = true;
				break;
			case "cost":
				buffer.readInt32();
				this.cost = buffer.readInt32();
				cost_is_set = true;
				break;
			case "visited":
				buffer.readInt32();
				this.visited = buffer.readBool();
				visited_is_set = true;
				break;
			case "closed":
				buffer.readInt32();
				this.closed = buffer.readBool();
				closed_is_set = true;
				break;
			case "parent":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.parent = _objectCache[index];
				} else {
					let parent = this.parent
					if(!parent || parent._objectIndex != -index)
						this.parent = parent = new _AStarNode();
					(_objectCache[-index] = parent).deserialize_external(buffer);
				}
				parent_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pos_is_set) this.pos = new IntVector2(0, 0, null);
				if(!f_is_set) this.f = 0;
				if(!g_is_set) this.g = 0;
				if(!h_is_set) this.h = 0;
				if(!cost_is_set) this.cost = 1;
				if(!visited_is_set) this.visited = false;
				if(!closed_is_set) this.closed = false;
				if(!parent_is_set) this.parent = null;
				return;
		}
	}
}
function BinaryHeap(content) {
	this.content = content;
}
BinaryHeap.prototype.scoreFunction = function(node) {
	return node.f;
}
BinaryHeap.prototype.push = function(element) {
	this.content.push(element);
	this.sinkDown(this.content.length - 1);
}
BinaryHeap.prototype.pop = function() {
	let result = this.content.get(0);
	let end = this.content.pop();
	if(this.content.length > 0) {
		this.content.set(0, end);
		this.bubbleUp(0);
	}
	return result;
}
BinaryHeap.prototype.remove = function(node) {
	let i = this.content.indexOf(node);
	let end = this.content.pop();
	if(i != this.content.length - 1) {
		this.content.set(i, end);
		if(this.scoreFunction(end) < this.scoreFunction(node)) {
			this.sinkDown(i);
		} else {
			this.bubbleUp(i);
		}
	}
}
BinaryHeap.prototype.size = function() {
	return this.content.length;
}
BinaryHeap.prototype.rescoreElement = function(node) {
	this.sinkDown(this.content.indexOf(node));
}
BinaryHeap.prototype.sinkDown = function(number) {
	let n = number;
	let element = this.content.get(n);
	while((n > 0)) {
		let parentN = (((n + 1) >> 1)) - 1;
		let parent = this.content.get(parentN);
		if(this.scoreFunction(element) < this.scoreFunction(parent)) {
			this.content.set(parentN, element);
			this.content.set(n, parent);
			n = parentN;
		} else {
			break;
		}
	}
}
BinaryHeap.prototype.bubbleUp = function(number) {
	let n = number;
	let length = this.content.length, element = this.content.get(n), elemScore = this.scoreFunction(element);
	while(true) {
		let child2N = ((n + 1) << 1);
		let child1N = child2N - 1;
		let swap = -1;
		let child1Score = 0;
		if(child1N < length) {
			let child1 = this.content.get(child1N);
			child1Score = this.scoreFunction(child1);
			if(child1Score < elemScore) {
				swap = child1N;
			}
		}
		if(child2N < length) {
			let child2 = this.content.get(child2N);
			let child2Score = this.scoreFunction(child2);
			if(child2Score < ((swap == -1 ? elemScore : child1Score))) {
				swap = child2N;
			}
		}
		if(swap != -1) {
			this.content.set(n, this.content.get(swap));
			this.content.set(swap, element);
			n = swap;
		} else {
			break;
		}
	}
}
BinaryHeap.prototype.clone = function() {
	let clone = new _BinaryHeap();
	clone.content = this.content;
	return clone;
}
function _BinaryHeap() {};
_BinaryHeap.prototype = BinaryHeap.prototype;
BinaryHeap.prototype.serialize_internal = function(buffer) {
	let content = this.content
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
BinaryHeap.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.content = _objectCache[index];
	} else {
		let content = this.content
		if(!content || content._objectIndex != -index) this.content = content = [];
		_objectCache[-index] = content;
		for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					content[i] = _objectCache[index];
				} else {
					let content_item = content[i]
					if(!content_item || content_item._objectIndex != -index)
						content[i] = content_item = new _AStarNode();
					(_objectCache[-index] = content_item).deserialize_internal(buffer);
				}
		}
	}
}
BinaryHeap.prototype.serialize_external = function(buffer) {
	buffer.writeString("content");
	let content = this.content
	let content_startPos = buffer.reserveSize();
	if(content) {
		var index = _objectCacheIndex.get(content);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(content, index = _objectCache.length);
			_objectCache.push(content);
			buffer.writeInt32(-index);
			content._objectIndex = index;
			buffer.writeInt32(content.length);
			for(let i=0, len=content.length; i<len; ++i) {
				let content_item = content[i]
				if(content_item) {
					var index = _objectCacheIndex.get(content_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(content_item, index = _objectCache.length);
						_objectCache.push(content_item);
						buffer.writeInt32(-index);
						content_item._objectIndex = index;
						content_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(content_startPos);
	buffer.writeString("");
}
BinaryHeap.prototype.deserialize_external = function(buffer) {
	let content_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "content":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.content = _objectCache[index];
				} else {
					let content = this.content
					if(!content || content._objectIndex != -index) this.content = content = [];
					_objectCache[-index] = content;
					for(let i=0, len = content.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								content[i] = _objectCache[index];
							} else {
								let content_item = content[i]
								if(!content_item || content_item._objectIndex != -index)
									content[i] = content_item = new _AStarNode();
								(_objectCache[-index] = content_item).deserialize_external(buffer);
							}
					}
				}
				content_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!content_is_set) this.content = [];
				return;
		}
	}
}
function BoxCollider(position, size, radius, right, bottom, left, top, rightLine, bottomLine, leftLine, topLine, bottomRight, bottomLeft, topLeft, topRight) {
	this.position = position?.clone();
	this.size = size?.clone();
	this.rightLine = rightLine;
	this.bottomLine = bottomLine;
	this.leftLine = leftLine;
	this.topLine = topLine;
	this.bottomRight = bottomRight;
	this.bottomLeft = bottomLeft;
	this.topLeft = topLeft;
	this.topRight = topRight;
	if(left) {
		this.leftLine = new Line(Vector2_plus_Vector2(position, new Vector2(-(size.x / 2 + radius), -(size.y / 2 + ((this.topLeft ? radius : 0))), null)), Vector2_plus_Vector2(position, new Vector2(-(size.x / 2 + radius), (size.y / 2 + ((this.bottomLeft ? radius : 0))), null)), 2/*Segment*/);
	}
	if(right) {
		this.rightLine = new Line(Vector2_plus_Vector2(position, new Vector2((size.x / 2 + radius), -(size.y / 2 + ((this.topRight ? radius : 0))), null)), Vector2_plus_Vector2(position, new Vector2((size.x / 2 + radius), (size.y / 2 + ((this.bottomRight ? radius : 0))), null)), 2/*Segment*/);
	}
	if(top) {
		this.topLine = new Line(Vector2_plus_Vector2(position, new Vector2(-(size.x / 2 + ((this.topLeft ? radius : 0))), -(size.y / 2 + radius), null)), Vector2_plus_Vector2(position, new Vector2((size.x / 2 + ((this.topRight ? radius : 0))), -(size.y / 2 + radius), null)), 2/*Segment*/);
	}
	if(bottom) {
		this.bottomLine = new Line(Vector2_plus_Vector2(position, new Vector2(-(size.x / 2 + ((this.bottomLeft ? radius : 0))), (size.y / 2 + radius), null)), Vector2_plus_Vector2(position, new Vector2((size.x / 2 + ((this.bottomRight ? radius : 0))), (size.y / 2 + radius), null)), 2/*Segment*/);
	}
}
BoxCollider.prototype.clone = function() {
	let clone = new _BoxCollider();
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.rightLine = this.rightLine;
	clone.bottomLine = this.bottomLine;
	clone.leftLine = this.leftLine;
	clone.topLine = this.topLine;
	clone.bottomRight = this.bottomRight;
	clone.bottomLeft = this.bottomLeft;
	clone.topLeft = this.topLeft;
	clone.topRight = this.topRight;
	return clone;
}
function _BoxCollider() {};
_BoxCollider.prototype = BoxCollider.prototype;
BoxCollider.prototype.serialize_internal = function(buffer) {
	(this.position || new _Vector2()).serialize_internal(buffer);
	(this.size || new _Vector2()).serialize_internal(buffer);
	let rightLine = this.rightLine
	if(rightLine) {
		var index = _objectCacheIndex.get(rightLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(rightLine, index = _objectCache.length);
			_objectCache.push(rightLine);
			buffer.writeInt32(-index);
			rightLine._objectIndex = index;
			rightLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let bottomLine = this.bottomLine
	if(bottomLine) {
		var index = _objectCacheIndex.get(bottomLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(bottomLine, index = _objectCache.length);
			_objectCache.push(bottomLine);
			buffer.writeInt32(-index);
			bottomLine._objectIndex = index;
			bottomLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let leftLine = this.leftLine
	if(leftLine) {
		var index = _objectCacheIndex.get(leftLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(leftLine, index = _objectCache.length);
			_objectCache.push(leftLine);
			buffer.writeInt32(-index);
			leftLine._objectIndex = index;
			leftLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let topLine = this.topLine
	if(topLine) {
		var index = _objectCacheIndex.get(topLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(topLine, index = _objectCache.length);
			_objectCache.push(topLine);
			buffer.writeInt32(-index);
			topLine._objectIndex = index;
			topLine.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.bottomRight);
	buffer.writeBool(this.bottomLeft);
	buffer.writeBool(this.topLeft);
	buffer.writeBool(this.topRight);
}
BoxCollider.prototype.deserialize_internal = function(buffer) {
	(this.position || (this.position = new _Vector2())).deserialize_internal(buffer);
	(this.size || (this.size = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.rightLine = _objectCache[index];
	} else {
		let rightLine = this.rightLine
		if(!rightLine || rightLine._objectIndex != -index)
			this.rightLine = rightLine = new _Line();
		(_objectCache[-index] = rightLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.bottomLine = _objectCache[index];
	} else {
		let bottomLine = this.bottomLine
		if(!bottomLine || bottomLine._objectIndex != -index)
			this.bottomLine = bottomLine = new _Line();
		(_objectCache[-index] = bottomLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.leftLine = _objectCache[index];
	} else {
		let leftLine = this.leftLine
		if(!leftLine || leftLine._objectIndex != -index)
			this.leftLine = leftLine = new _Line();
		(_objectCache[-index] = leftLine).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.topLine = _objectCache[index];
	} else {
		let topLine = this.topLine
		if(!topLine || topLine._objectIndex != -index)
			this.topLine = topLine = new _Line();
		(_objectCache[-index] = topLine).deserialize_internal(buffer);
	}
	this.bottomRight = buffer.readBool();
	this.bottomLeft = buffer.readBool();
	this.topLeft = buffer.readBool();
	this.topRight = buffer.readBool();
}
BoxCollider.prototype.serialize_external = function(buffer) {
	buffer.writeString("position");
	let position_startPos = buffer.reserveSize();
	(this.position || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(position_startPos);
	buffer.writeString("size");
	let size_startPos = buffer.reserveSize();
	(this.size || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(size_startPos);
	buffer.writeString("rightLine");
	let rightLine_startPos = buffer.reserveSize();
	let rightLine = this.rightLine
	if(rightLine) {
		var index = _objectCacheIndex.get(rightLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(rightLine, index = _objectCache.length);
			_objectCache.push(rightLine);
			buffer.writeInt32(-index);
			rightLine._objectIndex = index;
			rightLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(rightLine_startPos);
	buffer.writeString("bottomLine");
	let bottomLine_startPos = buffer.reserveSize();
	let bottomLine = this.bottomLine
	if(bottomLine) {
		var index = _objectCacheIndex.get(bottomLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(bottomLine, index = _objectCache.length);
			_objectCache.push(bottomLine);
			buffer.writeInt32(-index);
			bottomLine._objectIndex = index;
			bottomLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(bottomLine_startPos);
	buffer.writeString("leftLine");
	let leftLine_startPos = buffer.reserveSize();
	let leftLine = this.leftLine
	if(leftLine) {
		var index = _objectCacheIndex.get(leftLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(leftLine, index = _objectCache.length);
			_objectCache.push(leftLine);
			buffer.writeInt32(-index);
			leftLine._objectIndex = index;
			leftLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(leftLine_startPos);
	buffer.writeString("topLine");
	let topLine_startPos = buffer.reserveSize();
	let topLine = this.topLine
	if(topLine) {
		var index = _objectCacheIndex.get(topLine);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(topLine, index = _objectCache.length);
			_objectCache.push(topLine);
			buffer.writeInt32(-index);
			topLine._objectIndex = index;
			topLine.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(topLine_startPos);
	buffer.writeString("bottomRight");
	buffer.writeInt32(1);
	buffer.writeBool(this.bottomRight);
	buffer.writeString("bottomLeft");
	buffer.writeInt32(1);
	buffer.writeBool(this.bottomLeft);
	buffer.writeString("topLeft");
	buffer.writeInt32(1);
	buffer.writeBool(this.topLeft);
	buffer.writeString("topRight");
	buffer.writeInt32(1);
	buffer.writeBool(this.topRight);
	buffer.writeString("");
}
BoxCollider.prototype.deserialize_external = function(buffer) {
	let position_is_set = false, size_is_set = false, rightLine_is_set = false, bottomLine_is_set = false, leftLine_is_set = false, topLine_is_set = false, bottomRight_is_set = false, bottomLeft_is_set = false, topLeft_is_set = false, topRight_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "position":
				buffer.readInt32();
				(this.position || (this.position = new _Vector2())).deserialize_external(buffer);
				position_is_set = true;
				break;
			case "size":
				buffer.readInt32();
				(this.size || (this.size = new _Vector2())).deserialize_external(buffer);
				size_is_set = true;
				break;
			case "rightLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.rightLine = _objectCache[index];
				} else {
					let rightLine = this.rightLine
					if(!rightLine || rightLine._objectIndex != -index)
						this.rightLine = rightLine = new _Line();
					(_objectCache[-index] = rightLine).deserialize_external(buffer);
				}
				rightLine_is_set = true;
				break;
			case "bottomLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.bottomLine = _objectCache[index];
				} else {
					let bottomLine = this.bottomLine
					if(!bottomLine || bottomLine._objectIndex != -index)
						this.bottomLine = bottomLine = new _Line();
					(_objectCache[-index] = bottomLine).deserialize_external(buffer);
				}
				bottomLine_is_set = true;
				break;
			case "leftLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.leftLine = _objectCache[index];
				} else {
					let leftLine = this.leftLine
					if(!leftLine || leftLine._objectIndex != -index)
						this.leftLine = leftLine = new _Line();
					(_objectCache[-index] = leftLine).deserialize_external(buffer);
				}
				leftLine_is_set = true;
				break;
			case "topLine":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.topLine = _objectCache[index];
				} else {
					let topLine = this.topLine
					if(!topLine || topLine._objectIndex != -index)
						this.topLine = topLine = new _Line();
					(_objectCache[-index] = topLine).deserialize_external(buffer);
				}
				topLine_is_set = true;
				break;
			case "bottomRight":
				buffer.readInt32();
				this.bottomRight = buffer.readBool();
				bottomRight_is_set = true;
				break;
			case "bottomLeft":
				buffer.readInt32();
				this.bottomLeft = buffer.readBool();
				bottomLeft_is_set = true;
				break;
			case "topLeft":
				buffer.readInt32();
				this.topLeft = buffer.readBool();
				topLeft_is_set = true;
				break;
			case "topRight":
				buffer.readInt32();
				this.topRight = buffer.readBool();
				topRight_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!position_is_set) this.position = new Vector2(0.0, 0.0, null);
				if(!size_is_set) this.size = new Vector2(0.0, 0.0, null);
				if(!rightLine_is_set) this.rightLine = null;
				if(!bottomLine_is_set) this.bottomLine = null;
				if(!leftLine_is_set) this.leftLine = null;
				if(!topLine_is_set) this.topLine = null;
				if(!bottomRight_is_set) this.bottomRight = true;
				if(!bottomLeft_is_set) this.bottomLeft = true;
				if(!topLeft_is_set) this.topLeft = true;
				if(!topRight_is_set) this.topRight = true;
				return;
		}
	}
}
var game_showColliders;
var game_log;
function game_init() {
	game_showColliders = false;
	game_log = false;
}
function game_findPath(startPos, endPos, size, getNeighbors, heuristic) {
	let grid = [];
	for(let x=0; x<size.x; ++x) {
		grid.set(x, []);
		for(let y=0; y<size.y; ++y) {
			grid.get(x).set(y, new AStarNode(new IntVector2(x, y, null), 0, 0, 0, 1, false, false, null));
		}
	}
	let diagonal = false;
	let start = grid.get(startPos.x).get(startPos.y);
	let end = grid.get(endPos.x).get(endPos.y);
	let openHeap = new BinaryHeap([]);
	openHeap.push(start);
	while(openHeap.size() > 0) {
		let currentNode = openHeap.pop();
		if(currentNode == end) {
			let curr = currentNode;
			let result = [];
			while((curr.parent != null)) {
				result.push(curr);
				curr = curr.parent;
			}
			result.push(curr);
			return result.reverse();
		}
		currentNode.closed = true;
		let neighbors = getNeighbors(grid, currentNode.pos.x, currentNode.pos.y);
		for(let i=0; i<neighbors.length; ++i) {
			let neighbor = neighbors.get(i);
			if(neighbor.closed) {
				continue;
			}
			let gScore = currentNode.g + neighbor.cost;
			let beenVisited = neighbor.visited;
			if(!beenVisited || gScore < neighbor.g) {
				neighbor.visited = true;
				neighbor.parent = currentNode;
				neighbor.h = neighbor.h || heuristic(neighbor.pos, end.pos);
				neighbor.g = gScore;
				neighbor.f = neighbor.g + neighbor.h;
				if(!beenVisited) {
					openHeap.push(neighbor);
				} else {
					openHeap.rescoreElement(neighbor);
				}
			}
		}
	}
	return [];
}
function game_resolveCollision(sourcePosition, targetPosition, colliders, radius, slideThreshold) {
	let threshold = radius + slideThreshold;
	let primarilyX = Math.abs(targetPosition.x - sourcePosition.x) > Math.abs(targetPosition.y - sourcePosition.y);
	let movement = new Line(sourcePosition, targetPosition, 2/*Segment*/);
	let hasCollided = false;
	for(let i=0, _subject=colliders, _len=_subject.length; i<_len; ++i) { let c = _subject[i]; {
		if((c.leftLine != null) && movement.end.x > movement.start.x) {
			let line = c.leftLine;
			let p = movement.intersectionWith(line);
			if(p?.toBool()) {
				hasCollided = true;
				if(c.topLeft && (p.y - line.start.y) <= threshold) {
					if(game_log) {
						System_watch("Move Right, Hit TopLeft Corner", null);
					}
					if(primarilyX) {
						targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
					} else {
						targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
					}
				} else {
					if(c.bottomLeft && (line.end.y - p.y) <= threshold) {
						if(game_log) {
							System_watch("Move Right, Hit BottomLeft Corner", null);
						}
						if(primarilyX) {
							targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
						} else {
							targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
						}
					} else {
						if(game_log) {
							System_watch("Move Right, Hit Left Side", null);
						}
						targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
					}
				}
			}
		} else {
			if((c.rightLine != null) && movement.end.x < movement.start.x) {
				let line = c.rightLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(c.topRight && (p.y - line.start.y) <= threshold) {
						if(game_log) {
							System_watch("Move Left, Hit TopRight Corner", null);
						}
						if(primarilyX) {
							targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
						} else {
							targetPosition.x = Math.max(targetPosition.x, line.start.x + 1);
						}
					} else {
						if(c.bottomRight && (line.end.y - p.y) <= threshold) {
							if(game_log) {
								System_watch("Move Left, Hit BottomRight Corner", null);
							}
							if(primarilyX) {
								targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
							} else {
								targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
							}
						} else {
							if(game_log) {
								System_watch("Move Left, Hit Right Side", null);
							}
							targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
						}
					}
				}
			}
		}
		if((c.topLine != null) && movement.end.y > movement.start.y) {
			let line = c.topLine;
			let p = movement.intersectionWith(line);
			if(p?.toBool()) {
				hasCollided = true;
				if(c.topLeft && (p.x - line.start.x) <= threshold) {
					if(game_log) {
						System_watch("Move Down, Hit TopLeft Corner", null);
					}
					if(primarilyX) {
						targetPosition.y = Math.min(targetPosition.y, line.start.y - 1);
					} else {
						targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
					}
				} else {
					if(c.topRight && (line.end.x - p.x) <= threshold) {
						if(game_log) {
							System_watch("Move Down, Hit TopRight Corner", null);
						}
						if(primarilyX) {
							targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
						} else {
							targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
						}
					} else {
						if(game_log) {
							System_watch("Move Down, Hit Top Side", null);
						}
						targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
					}
				}
			}
		} else {
			if((c.bottomLine != null) && movement.end.y < movement.start.y) {
				let line = c.bottomLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(c.bottomLeft && (p.x - line.start.x) <= threshold) {
						if(game_log) {
							System_watch("Move Up, Hit BottomLeft Corner", null);
						}
						if(primarilyX) {
							targetPosition.y = Math.max(targetPosition.y, line.start.y + 1);
						} else {
							targetPosition.x = Math.min(targetPosition.x, line.start.x - 1);
						}
					} else {
						if(c.bottomRight && (line.end.x - p.x) <= threshold) {
							if(game_log) {
								System_watch("Move Up, Hit BottomRight Corner", null);
							}
							if(primarilyX) {
								targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
							} else {
								targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
							}
						} else {
							if(game_log) {
								System_watch("Move Up, Hit Bottom Side", null);
							}
							targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
						}
					}
				}
			}
		}
	}}
	let iterations = 0;
	while(hasCollided) {
		primarilyX = Math.abs(targetPosition.x - sourcePosition.x) > Math.abs(targetPosition.y - sourcePosition.y);
		movement = new Line(sourcePosition, targetPosition, 2/*Segment*/);
		hasCollided = false;
		if(++iterations > 3) {
			return sourcePosition;
		}
		for(let i=0, _subject=colliders, _len=_subject.length; i<_len; ++i) { let c = _subject[i]; {
			if((c.leftLine != null) && movement.end.x > movement.start.x) {
				let line = c.leftLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(game_log) {
						System_watch("Check after collision, Hit Left Side", null);
					}
					targetPosition.x = Math.min(targetPosition.x, line.end.x - 1);
				}
			} else {
				if((c.rightLine != null) && movement.end.x < movement.start.x) {
					let line = c.rightLine;
					let p = movement.intersectionWith(line);
					if(p?.toBool()) {
						hasCollided = true;
						if(game_log) {
							System_watch("Check after collision, Hit Right Side", null);
						}
						targetPosition.x = Math.max(targetPosition.x, line.end.x + 1);
					}
				}
			}
			if((c.topLine != null) && movement.end.y > movement.start.y) {
				let line = c.topLine;
				let p = movement.intersectionWith(line);
				if(p?.toBool()) {
					hasCollided = true;
					if(game_log) {
						System_watch("Check after collision, Hit Top Side", null);
					}
					targetPosition.y = Math.min(targetPosition.y, line.end.y - 1);
				}
			} else {
				if((c.bottomLine != null) && movement.end.y < movement.start.y) {
					let line = c.bottomLine;
					let p = movement.intersectionWith(line);
					if(p?.toBool()) {
						hasCollided = true;
						if(game_log) {
							System_watch("Check after collision, Hit Bottom Side", null);
						}
						targetPosition.y = Math.max(targetPosition.y, line.end.y + 1);
					}
				}
			}
		}}
	}
	return targetPosition;
}
function game_serialize_internal(buffer) {
	buffer.writeBool(game_showColliders);
	buffer.writeBool(game_log);
}
function game_deserialize_internal(buffer) {
	game_showColliders = buffer.readBool();
	game_log = buffer.readBool();
}
function game_serialize_external(buffer) {
	buffer.writeString("showColliders");
	buffer.writeInt32(1);
	buffer.writeBool(game_showColliders);
	buffer.writeString("log");
	buffer.writeInt32(1);
	buffer.writeBool(game_log);
	buffer.writeString("");
}
function game_deserialize_external(buffer) {
	let showColliders_is_set = false, log_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "showColliders":
				buffer.readInt32();
				game_showColliders = buffer.readBool();
				showColliders_is_set = true;
				break;
			case "log":
				buffer.readInt32();
				game_log = buffer.readBool();
				log_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!showColliders_is_set) game_showColliders = false;
				if(!log_is_set) game_log = false;
				return;
		}
	}
}
function InternalUser(id, local, connectionId, index, active, collectInputs, inputFrame, inputsSentPos, lastTouchMoveIndex, inputs, mediaStream, videoElements, audioElement, videoElementIndex, peerConnection, dataChannel, recreateDataChannelInterval, connectionType, offerByMe, receivedAnswer, nextLostMessageAtFrame) {
	this.id = id;
	this.local = local;
	this.connectionId = connectionId;
	this.index = index;
	this.active = active;
	this.collectInputs = collectInputs;
	this.inputFrame = inputFrame;
	this.inputsSentPos = inputsSentPos;
	this.lastTouchMoveIndex = lastTouchMoveIndex;
	this.inputs = inputs;
	this.downTouches = [];
	this.movingTouches = [];
	this.upTouches = [];
	this.wheelEvents = [];
	this.downKeys = [];
	this.upKeys = [];
	this.pressedKeys = [];
	this.textInputs = [];
	this.textCompositions = [];
	this.navigations = [];
	this.mediaStream = mediaStream;
	this.videoElements = videoElements;
	this.audioElement = audioElement;
	this.videoElementIndex = videoElementIndex;
	this.peerConnection = peerConnection;
	this.dataChannel = dataChannel;
	this.recreateDataChannelInterval = recreateDataChannelInterval;
	this.connectionType = connectionType;
	this.offerByMe = offerByMe;
	this.receivedAnswer = receivedAnswer;
	this.nextLostMessageAtFrame = nextLostMessageAtFrame;
	this.aheads = [];
	this.aheadsMax = [];
	this.bufferFrames = 0;
	this.smoothFrame = int_maxValue;
}
InternalUser.prototype.startInputFrame = function(index) {
	this.lastTouchMoveIndex.length = 0;
	this.inputFrame = index;
}
InternalUser.prototype.clearEvent = function() {
	this.downTouches.length = 0;
	this.movingTouches.length = 0;
	this.upTouches.length = 0;
	this.wheelEvents.length = 0;
	this.textCompositions.length = 0;
	this.textInputs.length = 0;
	this.downKeys.length = 0;
	this.upKeys.length = 0;
	this.pressedKeys.length = 0;
	this.navigations.length = 0;
}
InternalUser.prototype.collectStatistics = function(frame) {
	let ahead = frame - this.inputFrame;
	if(ahead < 50) {
		this.aheads.push(ahead)
		if(this.aheads.length > 200) this.aheads.splice(0, 1);
	}
	let aheadMax = this.aheads.max(a => a, int_minValue, 0);
	this.aheadsMax.push(aheadMax)
	if(this.aheadsMax.length > 600) this.aheadsMax.splice(0, 1);
	this.bufferFrames = Math.ceil(this.aheadsMax.average());
	this.smoothFrame = frame - this.bufferFrames;
}
InternalUser.prototype.simulateRollback = function(frame) {
	this.bufferFrames = 5;
	this.smoothFrame = frame - this.bufferFrames;
}
InternalUser.prototype.clone = function() {
	let clone = new _InternalUser();
	clone.id = this.id;
	clone.local = this.local;
	clone.connectionId = this.connectionId;
	clone.index = this.index;
	clone.active = this.active;
	clone.collectInputs = this.collectInputs;
	clone.inputFrame = this.inputFrame;
	clone.inputsSentPos = this.inputsSentPos;
	clone.lastTouchMoveIndex = this.lastTouchMoveIndex;
	clone.inputs = this.inputs;
	clone.downTouches = this.downTouches;
	clone.movingTouches = this.movingTouches;
	clone.upTouches = this.upTouches;
	clone.wheelEvents = this.wheelEvents;
	clone.downKeys = this.downKeys;
	clone.upKeys = this.upKeys;
	clone.pressedKeys = this.pressedKeys;
	clone.textInputs = this.textInputs;
	clone.textCompositions = this.textCompositions;
	clone.navigations = this.navigations;
	clone.mediaStream = this.mediaStream;
	clone.videoElements = this.videoElements;
	clone.audioElement = this.audioElement;
	clone.videoElementIndex = this.videoElementIndex;
	clone.peerConnection = this.peerConnection;
	clone.dataChannel = this.dataChannel;
	clone.recreateDataChannelInterval = this.recreateDataChannelInterval;
	clone.connectionType = this.connectionType;
	clone.offerByMe = this.offerByMe;
	clone.receivedAnswer = this.receivedAnswer;
	clone.nextLostMessageAtFrame = this.nextLostMessageAtFrame;
	clone.aheads = this.aheads;
	clone.aheadsMax = this.aheadsMax;
	clone.bufferFrames = this.bufferFrames;
	clone.smoothFrame = this.smoothFrame;
	return clone;
}
function _InternalUser() {};
_InternalUser.prototype = InternalUser.prototype;
function Touch(id, by, phase, type, referencePosition, referenceStartPosition, smoothPosition, isDown, handled) {
	this.id = id;
	this.by = by;
	this.phase = phase;
	this.type = type;
	this.referencePosition = referencePosition?.clone();
	this.referenceStartPosition = referenceStartPosition?.clone();
	this.smoothPosition = smoothPosition?.clone();
	this.isDown = isDown;
	this.handled = handled;
}
Touch.prototype.position = function() {
	return this.referencePosition.getRelativeTo(graphics_localMatrix);
}
Touch.prototype.startPosition = function() {
	return this.referenceStartPosition.getRelativeTo(graphics_localMatrix);
}
Touch.prototype.markAsHandled = function() {
	this.handled = true;
}
Touch.prototype.clone = function() {
	let clone = new _Touch();
	clone.id = this.id;
	clone.by = this.by;
	clone.phase = this.phase;
	clone.type = this.type;
	clone.referencePosition = this.referencePosition.clone();
	clone.referenceStartPosition = this.referenceStartPosition.clone();
	clone.smoothPosition = this.smoothPosition.clone();
	clone.isDown = this.isDown;
	clone.handled = this.handled;
	return clone;
}
function _Touch() {};
_Touch.prototype = Touch.prototype;
Touch.prototype.serialize_internal = function(buffer) {
	buffer.writeInt32(this.id);
	let by = this.by
	if(by) {
		var index = _objectCacheIndex.get(by);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(by, index = _objectCache.length);
			_objectCache.push(by);
			buffer.writeInt32(-index);
			by._objectIndex = index;
			by.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.phase);
	buffer.writeInt32(this.type);
	(this.referencePosition || new _Vector2()).serialize_internal(buffer);
	(this.referenceStartPosition || new _Vector2()).serialize_internal(buffer);
	(this.smoothPosition || new _Vector2()).serialize_internal(buffer);
	buffer.writeBool(this.isDown);
	buffer.writeBool(this.handled);
}
Touch.prototype.deserialize_internal = function(buffer) {
	this.id = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.by = _objectCache[index];
	} else {
		let by = this.by
		if(!by || by._objectIndex != -index)
			this.by = by = new _Player();
		(_objectCache[-index] = by).deserialize_internal(buffer);
	}
	this.phase = buffer.readInt32();
	this.type = buffer.readInt32();
	(this.referencePosition || (this.referencePosition = new _Vector2())).deserialize_internal(buffer);
	(this.referenceStartPosition || (this.referenceStartPosition = new _Vector2())).deserialize_internal(buffer);
	(this.smoothPosition || (this.smoothPosition = new _Vector2())).deserialize_internal(buffer);
	this.isDown = buffer.readBool();
	this.handled = buffer.readBool();
}
Touch.prototype.serialize_external = function(buffer) {
	buffer.writeString("id");
	buffer.writeInt32(4);
	buffer.writeInt32(this.id);
	buffer.writeString("by");
	let by_startPos = buffer.reserveSize();
	let by = this.by
	if(by) {
		var index = _objectCacheIndex.get(by);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(by, index = _objectCache.length);
			_objectCache.push(by);
			buffer.writeInt32(-index);
			by._objectIndex = index;
			by.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(by_startPos);
	buffer.writeString("phase");
	buffer.writeInt32(4);
	buffer.writeInt32(this.phase);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("referencePosition");
	let referencePosition_startPos = buffer.reserveSize();
	(this.referencePosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(referencePosition_startPos);
	buffer.writeString("referenceStartPosition");
	let referenceStartPosition_startPos = buffer.reserveSize();
	(this.referenceStartPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(referenceStartPosition_startPos);
	buffer.writeString("smoothPosition");
	let smoothPosition_startPos = buffer.reserveSize();
	(this.smoothPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(smoothPosition_startPos);
	buffer.writeString("isDown");
	buffer.writeInt32(1);
	buffer.writeBool(this.isDown);
	buffer.writeString("handled");
	buffer.writeInt32(1);
	buffer.writeBool(this.handled);
	buffer.writeString("");
}
Touch.prototype.deserialize_external = function(buffer) {
	let id_is_set = false, by_is_set = false, phase_is_set = false, type_is_set = false, referencePosition_is_set = false, referenceStartPosition_is_set = false, smoothPosition_is_set = false, isDown_is_set = false, handled_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "id":
				buffer.readInt32();
				this.id = buffer.readInt32();
				id_is_set = true;
				break;
			case "by":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.by = _objectCache[index];
				} else {
					let by = this.by
					if(!by || by._objectIndex != -index)
						this.by = by = new _Player();
					(_objectCache[-index] = by).deserialize_external(buffer);
				}
				by_is_set = true;
				break;
			case "phase":
				buffer.readInt32();
				this.phase = buffer.readInt32();
				phase_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			case "referencePosition":
				buffer.readInt32();
				(this.referencePosition || (this.referencePosition = new _Vector2())).deserialize_external(buffer);
				referencePosition_is_set = true;
				break;
			case "referenceStartPosition":
				buffer.readInt32();
				(this.referenceStartPosition || (this.referenceStartPosition = new _Vector2())).deserialize_external(buffer);
				referenceStartPosition_is_set = true;
				break;
			case "smoothPosition":
				buffer.readInt32();
				(this.smoothPosition || (this.smoothPosition = new _Vector2())).deserialize_external(buffer);
				smoothPosition_is_set = true;
				break;
			case "isDown":
				buffer.readInt32();
				this.isDown = buffer.readBool();
				isDown_is_set = true;
				break;
			case "handled":
				buffer.readInt32();
				this.handled = buffer.readBool();
				handled_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!id_is_set) this.id = 0;
				if(!by_is_set) this.by = null;
				if(!phase_is_set) this.phase = 0/*Still*/;
				if(!type_is_set) this.type = 0/*Left*/;
				if(!referencePosition_is_set) this.referencePosition = new Vector2(0.0, 0.0, null);
				if(!referenceStartPosition_is_set) this.referenceStartPosition = new Vector2(0.0, 0.0, null);
				if(!smoothPosition_is_set) this.smoothPosition = new Vector2(0.0, 0.0, null);
				if(!isDown_is_set) this.isDown = false;
				if(!handled_is_set) this.handled = false;
				return;
		}
	}
}
function ScrollEvent(userId, delta, referencePosition, handled) {
	this.userId = userId;
	this.delta = delta?.clone();
	this.referencePosition = referencePosition?.clone();
	this.handled = handled;
}
ScrollEvent.prototype.position = function() {
	return this.referencePosition.getRelativeTo(graphics_localMatrix);
}
ScrollEvent.prototype.markAsHandled = function() {
	this.handled = true;
}
ScrollEvent.prototype.clone = function() {
	let clone = new _ScrollEvent();
	clone.userId = this.userId;
	clone.delta = this.delta.clone();
	clone.referencePosition = this.referencePosition.clone();
	clone.handled = this.handled;
	return clone;
}
function _ScrollEvent() {};
_ScrollEvent.prototype = ScrollEvent.prototype;
function DigitalButton(name, key, state, prevState) {
	this.name = name;
	this.key = key;
	this.state = state;
	this.prevState = prevState;
}
DigitalButton.prototype.down = function() {
	return this.state && !this.prevState;
}
DigitalButton.prototype.up = function() {
	return !this.state && this.prevState;
}
DigitalButton.prototype.toString = function() {
	return this.name;
}
DigitalButton.prototype.assign = function(name, key) {
	this.name = name;
	this.key = key;
	this.state = false;
	this.prevState = false;
}
DigitalButton.prototype.startFrame = function() {
	this.prevState = this.state;
	this.state = false;
}
DigitalButton.prototype.clone = function() {
	let clone = new _DigitalButton();
	clone.name = this.name;
	clone.key = this.key;
	clone.state = this.state;
	clone.prevState = this.prevState;
	return clone;
}
function _DigitalButton() {};
_DigitalButton.prototype = DigitalButton.prototype;
DigitalButton.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.name);
	buffer.writeInt32(this.key);
	buffer.writeBool(this.state);
	buffer.writeBool(this.prevState);
}
DigitalButton.prototype.deserialize_internal = function(buffer) {
	this.name = buffer.readString();
	this.key = buffer.readInt32();
	this.state = buffer.readBool();
	this.prevState = buffer.readBool();
}
DigitalButton.prototype.serialize_external = function(buffer) {
	buffer.writeString("name");
	buffer.writeString(this.name);
	buffer.writeString("key");
	buffer.writeInt32(4);
	buffer.writeInt32(this.key);
	buffer.writeString("state");
	buffer.writeInt32(1);
	buffer.writeBool(this.state);
	buffer.writeString("prevState");
	buffer.writeInt32(1);
	buffer.writeBool(this.prevState);
	buffer.writeString("");
}
DigitalButton.prototype.deserialize_external = function(buffer) {
	let name_is_set = false, key_is_set = false, state_is_set = false, prevState_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "name":
				this.name = buffer.readString();
				name_is_set = true;
				break;
			case "key":
				buffer.readInt32();
				this.key = buffer.readInt32();
				key_is_set = true;
				break;
			case "state":
				buffer.readInt32();
				this.state = buffer.readBool();
				state_is_set = true;
				break;
			case "prevState":
				buffer.readInt32();
				this.prevState = buffer.readBool();
				prevState_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!name_is_set) this.name = "";
				if(!key_is_set) this.key = 0/*None*/;
				if(!state_is_set) this.state = false;
				if(!prevState_is_set) this.prevState = false;
				return;
		}
	}
}
function ControllerButtonPlayerAndIndex(userId, buttonIndex) {
	this.userId = userId;
	this.buttonIndex = buttonIndex;
}
ControllerButtonPlayerAndIndex.prototype.clone = function() {
	let clone = new _ControllerButtonPlayerAndIndex();
	clone.userId = this.userId;
	clone.buttonIndex = this.buttonIndex;
	return clone;
}
function _ControllerButtonPlayerAndIndex() {};
_ControllerButtonPlayerAndIndex.prototype = ControllerButtonPlayerAndIndex.prototype;
var GameController_deadZone;
function GameController_init() {
	GameController_deadZone = .1;
}
function GameController(inMotion, type) {
	this.leftStick = new Vector2(0.0, 0.0, null);
	this.rightStick = new Vector2(0.0, 0.0, null);
	this.right = new DigitalButton("", 0/*None*/, false, false);
	this.down = new DigitalButton("", 0/*None*/, false, false);
	this.left = new DigitalButton("", 0/*None*/, false, false);
	this.up = new DigitalButton("", 0/*None*/, false, false);
	this.a = new DigitalButton("", 0/*None*/, false, false);
	this.b = new DigitalButton("", 0/*None*/, false, false);
	this.x = new DigitalButton("", 0/*None*/, false, false);
	this.y = new DigitalButton("", 0/*None*/, false, false);
	this.buttons = [this.right, this.down, this.left, this.up, this.a, this.b, this.x, this.y];
	this.inMotion = inMotion;
	this.type = type;
}
GameController.prototype.startFrame = function() {
	this.leftStick.x = 0;
	this.leftStick.y = 0;
	this.rightStick.x = 0;
	this.rightStick.y = 0;
	this.a.startFrame();
	this.b.startFrame();
	this.x.startFrame();
	this.y.startFrame();
}
GameController.prototype.clone = function() {
	let clone = new _GameController();
	clone.leftStick = this.leftStick.clone();
	clone.rightStick = this.rightStick.clone();
	clone.right = this.right.clone();
	clone.down = this.down.clone();
	clone.left = this.left.clone();
	clone.up = this.up.clone();
	clone.a = this.a.clone();
	clone.b = this.b.clone();
	clone.x = this.x.clone();
	clone.y = this.y.clone();
	clone.buttons = this.buttons;
	clone.inMotion = this.inMotion;
	clone.type = this.type;
	return clone;
}
function _GameController() {};
_GameController.prototype = GameController.prototype;
function GameController_serialize_internal(buffer) {
	buffer.writeFloat64(GameController_deadZone);
}
function GameController_deserialize_internal(buffer) {
	GameController_deadZone = buffer.readFloat64();
}
GameController.prototype.serialize_internal = function(buffer) {
	(this.leftStick || new _Vector2()).serialize_internal(buffer);
	(this.rightStick || new _Vector2()).serialize_internal(buffer);
	(this.right || new _DigitalButton()).serialize_internal(buffer);
	(this.down || new _DigitalButton()).serialize_internal(buffer);
	(this.left || new _DigitalButton()).serialize_internal(buffer);
	(this.up || new _DigitalButton()).serialize_internal(buffer);
	(this.a || new _DigitalButton()).serialize_internal(buffer);
	(this.b || new _DigitalButton()).serialize_internal(buffer);
	(this.x || new _DigitalButton()).serialize_internal(buffer);
	(this.y || new _DigitalButton()).serialize_internal(buffer);
	let buttons = this.buttons
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				(buttons[i] || new _DigitalButton()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.inMotion);
	buffer.writeInt32(this.type);
}
GameController.prototype.deserialize_internal = function(buffer) {
	(this.leftStick || (this.leftStick = new _Vector2())).deserialize_internal(buffer);
	(this.rightStick || (this.rightStick = new _Vector2())).deserialize_internal(buffer);
	(this.right || (this.right = new _DigitalButton())).deserialize_internal(buffer);
	(this.down || (this.down = new _DigitalButton())).deserialize_internal(buffer);
	(this.left || (this.left = new _DigitalButton())).deserialize_internal(buffer);
	(this.up || (this.up = new _DigitalButton())).deserialize_internal(buffer);
	(this.a || (this.a = new _DigitalButton())).deserialize_internal(buffer);
	(this.b || (this.b = new _DigitalButton())).deserialize_internal(buffer);
	(this.x || (this.x = new _DigitalButton())).deserialize_internal(buffer);
	(this.y || (this.y = new _DigitalButton())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.buttons = _objectCache[index];
	} else {
		let buttons = this.buttons
		if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
		_objectCache[-index] = buttons;
		for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
				(buttons[i] || (buttons[i] = new _DigitalButton())).deserialize_internal(buffer);
		}
	}
	this.inMotion = buffer.readBool();
	this.type = buffer.readInt32();
}
function GameController_serialize_external(buffer) {
	buffer.writeString("deadZone");
	buffer.writeInt32(8);
	buffer.writeFloat64(GameController_deadZone);
	buffer.writeString("");
}
function GameController_deserialize_external(buffer) {
	let deadZone_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "deadZone":
				buffer.readInt32();
				GameController_deadZone = buffer.readFloat64();
				deadZone_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!deadZone_is_set) GameController_deadZone = .1;
				return;
		}
	}
}
GameController.prototype.serialize_external = function(buffer) {
	buffer.writeString("leftStick");
	let leftStick_startPos = buffer.reserveSize();
	(this.leftStick || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(leftStick_startPos);
	buffer.writeString("rightStick");
	let rightStick_startPos = buffer.reserveSize();
	(this.rightStick || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(rightStick_startPos);
	buffer.writeString("right");
	let right_startPos = buffer.reserveSize();
	(this.right || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(right_startPos);
	buffer.writeString("down");
	let down_startPos = buffer.reserveSize();
	(this.down || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(down_startPos);
	buffer.writeString("left");
	let left_startPos = buffer.reserveSize();
	(this.left || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(left_startPos);
	buffer.writeString("up");
	let up_startPos = buffer.reserveSize();
	(this.up || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(up_startPos);
	buffer.writeString("a");
	let a_startPos = buffer.reserveSize();
	(this.a || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(a_startPos);
	buffer.writeString("b");
	let b_startPos = buffer.reserveSize();
	(this.b || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(b_startPos);
	buffer.writeString("x");
	let x_startPos = buffer.reserveSize();
	(this.x || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(x_startPos);
	buffer.writeString("y");
	let y_startPos = buffer.reserveSize();
	(this.y || new _DigitalButton()).serialize_external(buffer);
	buffer.writeSize(y_startPos);
	buffer.writeString("buttons");
	let buttons = this.buttons
	let buttons_startPos = buffer.reserveSize();
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				(buttons[i] || new _DigitalButton()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(buttons_startPos);
	buffer.writeString("inMotion");
	buffer.writeInt32(1);
	buffer.writeBool(this.inMotion);
	buffer.writeString("type");
	buffer.writeInt32(4);
	buffer.writeInt32(this.type);
	buffer.writeString("");
}
GameController.prototype.deserialize_external = function(buffer) {
	let leftStick_is_set = false, rightStick_is_set = false, right_is_set = false, down_is_set = false, left_is_set = false, up_is_set = false, a_is_set = false, b_is_set = false, x_is_set = false, y_is_set = false, buttons_is_set = false, inMotion_is_set = false, type_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "leftStick":
				buffer.readInt32();
				(this.leftStick || (this.leftStick = new _Vector2())).deserialize_external(buffer);
				leftStick_is_set = true;
				break;
			case "rightStick":
				buffer.readInt32();
				(this.rightStick || (this.rightStick = new _Vector2())).deserialize_external(buffer);
				rightStick_is_set = true;
				break;
			case "right":
				buffer.readInt32();
				(this.right || (this.right = new _DigitalButton())).deserialize_external(buffer);
				right_is_set = true;
				break;
			case "down":
				buffer.readInt32();
				(this.down || (this.down = new _DigitalButton())).deserialize_external(buffer);
				down_is_set = true;
				break;
			case "left":
				buffer.readInt32();
				(this.left || (this.left = new _DigitalButton())).deserialize_external(buffer);
				left_is_set = true;
				break;
			case "up":
				buffer.readInt32();
				(this.up || (this.up = new _DigitalButton())).deserialize_external(buffer);
				up_is_set = true;
				break;
			case "a":
				buffer.readInt32();
				(this.a || (this.a = new _DigitalButton())).deserialize_external(buffer);
				a_is_set = true;
				break;
			case "b":
				buffer.readInt32();
				(this.b || (this.b = new _DigitalButton())).deserialize_external(buffer);
				b_is_set = true;
				break;
			case "x":
				buffer.readInt32();
				(this.x || (this.x = new _DigitalButton())).deserialize_external(buffer);
				x_is_set = true;
				break;
			case "y":
				buffer.readInt32();
				(this.y || (this.y = new _DigitalButton())).deserialize_external(buffer);
				y_is_set = true;
				break;
			case "buttons":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.buttons = _objectCache[index];
				} else {
					let buttons = this.buttons
					if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
					_objectCache[-index] = buttons;
					for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
							(buttons[i] || (buttons[i] = new _DigitalButton())).deserialize_external(buffer);
					}
				}
				buttons_is_set = true;
				break;
			case "inMotion":
				buffer.readInt32();
				this.inMotion = buffer.readBool();
				inMotion_is_set = true;
				break;
			case "type":
				buffer.readInt32();
				this.type = buffer.readInt32();
				type_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!leftStick_is_set) this.leftStick = new Vector2(0.0, 0.0, null);
				if(!rightStick_is_set) this.rightStick = new Vector2(0.0, 0.0, null);
				if(!right_is_set) this.right = new DigitalButton("", 0/*None*/, false, false);
				if(!down_is_set) this.down = new DigitalButton("", 0/*None*/, false, false);
				if(!left_is_set) this.left = new DigitalButton("", 0/*None*/, false, false);
				if(!up_is_set) this.up = new DigitalButton("", 0/*None*/, false, false);
				if(!a_is_set) this.a = new DigitalButton("", 0/*None*/, false, false);
				if(!b_is_set) this.b = new DigitalButton("", 0/*None*/, false, false);
				if(!x_is_set) this.x = new DigitalButton("", 0/*None*/, false, false);
				if(!y_is_set) this.y = new DigitalButton("", 0/*None*/, false, false);
				if(!buttons_is_set) this.buttons = [this.right, this.down, this.left, this.up, this.a, this.b, this.x, this.y];
				if(!inMotion_is_set) this.inMotion = false;
				if(!type_is_set) this.type = 0/*Keyboard*/;
				return;
		}
	}
}
function InternetGamePadButton(pressed, touched, value) {
	this.pressed = pressed;
	this.touched = touched;
	this.value = value;
}
InternetGamePadButton.prototype.clone = function() {
	let clone = new _InternetGamePadButton();
	clone.pressed = this.pressed;
	clone.touched = this.touched;
	clone.value = this.value;
	return clone;
}
function _InternetGamePadButton() {};
_InternetGamePadButton.prototype = InternetGamePadButton.prototype;
InternetGamePadButton.prototype.serialize_internal = function(buffer) {
	buffer.writeBool(this.pressed);
	buffer.writeBool(this.touched);
	buffer.writeFloat64(this.value);
}
InternetGamePadButton.prototype.deserialize_internal = function(buffer) {
	this.pressed = buffer.readBool();
	this.touched = buffer.readBool();
	this.value = buffer.readFloat64();
}
InternetGamePadButton.prototype.serialize_external = function(buffer) {
	buffer.writeString("pressed");
	buffer.writeInt32(1);
	buffer.writeBool(this.pressed);
	buffer.writeString("touched");
	buffer.writeInt32(1);
	buffer.writeBool(this.touched);
	buffer.writeString("value");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.value);
	buffer.writeString("");
}
InternetGamePadButton.prototype.deserialize_external = function(buffer) {
	let pressed_is_set = false, touched_is_set = false, value_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "pressed":
				buffer.readInt32();
				this.pressed = buffer.readBool();
				pressed_is_set = true;
				break;
			case "touched":
				buffer.readInt32();
				this.touched = buffer.readBool();
				touched_is_set = true;
				break;
			case "value":
				buffer.readInt32();
				this.value = buffer.readFloat64();
				value_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!pressed_is_set) this.pressed = false;
				if(!touched_is_set) this.touched = false;
				if(!value_is_set) this.value = 0.0;
				return;
		}
	}
}
function InternetGamePad(axes, buttons, id) {
	this.axes = axes;
	this.buttons = buttons;
	this.id = id;
}
InternetGamePad.prototype.clone = function() {
	let clone = new _InternetGamePad();
	clone.axes = this.axes;
	clone.buttons = this.buttons;
	clone.id = this.id;
	return clone;
}
function _InternetGamePad() {};
_InternetGamePad.prototype = InternetGamePad.prototype;
InternetGamePad.prototype.serialize_internal = function(buffer) {
	let axes = this.axes
	if(axes) {
		var index = _objectCacheIndex.get(axes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(axes, index = _objectCache.length);
			_objectCache.push(axes);
			buffer.writeInt32(-index);
			axes._objectIndex = index;
			buffer.writeInt32(axes.length);
			for(let i=0, len=axes.length; i<len; ++i) {
				buffer.writeFloat64(axes[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let buttons = this.buttons
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.id);
}
InternetGamePad.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.axes = _objectCache[index];
	} else {
		let axes = this.axes
		if(!axes || axes._objectIndex != -index) this.axes = axes = [];
		_objectCache[-index] = axes;
		for(let i=0, len = axes.length = buffer.readInt32(); i<len; ++i) {
				axes[i] = buffer.readFloat64();
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.buttons = _objectCache[index];
	} else {
		let buttons = this.buttons
		if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
		_objectCache[-index] = buttons;
		for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					buttons[i] = _objectCache[index];
				} else {
					let buttons_item = buttons[i]
					if(!buttons_item || buttons_item._objectIndex != -index)
						buttons[i] = buttons_item = new _InternetGamePadButton();
					(_objectCache[-index] = buttons_item).deserialize_internal(buffer);
				}
		}
	}
	this.id = buffer.readString();
}
InternetGamePad.prototype.serialize_external = function(buffer) {
	buffer.writeString("axes");
	let axes = this.axes
	let axes_startPos = buffer.reserveSize();
	if(axes) {
		var index = _objectCacheIndex.get(axes);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(axes, index = _objectCache.length);
			_objectCache.push(axes);
			buffer.writeInt32(-index);
			axes._objectIndex = index;
			buffer.writeInt32(axes.length);
			for(let i=0, len=axes.length; i<len; ++i) {
				buffer.writeFloat64(axes[i]);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(axes_startPos);
	buffer.writeString("buttons");
	let buttons = this.buttons
	let buttons_startPos = buffer.reserveSize();
	if(buttons) {
		var index = _objectCacheIndex.get(buttons);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(buttons, index = _objectCache.length);
			_objectCache.push(buttons);
			buffer.writeInt32(-index);
			buttons._objectIndex = index;
			buffer.writeInt32(buttons.length);
			for(let i=0, len=buttons.length; i<len; ++i) {
				let buttons_item = buttons[i]
				if(buttons_item) {
					var index = _objectCacheIndex.get(buttons_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(buttons_item, index = _objectCache.length);
						_objectCache.push(buttons_item);
						buffer.writeInt32(-index);
						buttons_item._objectIndex = index;
						buttons_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(buttons_startPos);
	buffer.writeString("id");
	buffer.writeString(this.id);
	buffer.writeString("");
}
InternetGamePad.prototype.deserialize_external = function(buffer) {
	let axes_is_set = false, buttons_is_set = false, id_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "axes":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.axes = _objectCache[index];
				} else {
					let axes = this.axes
					if(!axes || axes._objectIndex != -index) this.axes = axes = [];
					_objectCache[-index] = axes;
					for(let i=0, len = axes.length = buffer.readInt32(); i<len; ++i) {
							axes[i] = buffer.readFloat64();
					}
				}
				axes_is_set = true;
				break;
			case "buttons":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.buttons = _objectCache[index];
				} else {
					let buttons = this.buttons
					if(!buttons || buttons._objectIndex != -index) this.buttons = buttons = [];
					_objectCache[-index] = buttons;
					for(let i=0, len = buttons.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								buttons[i] = _objectCache[index];
							} else {
								let buttons_item = buttons[i]
								if(!buttons_item || buttons_item._objectIndex != -index)
									buttons[i] = buttons_item = new _InternetGamePadButton();
								(_objectCache[-index] = buttons_item).deserialize_external(buffer);
							}
					}
				}
				buttons_is_set = true;
				break;
			case "id":
				this.id = buffer.readString();
				id_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!axes_is_set) this.axes = [];
				if(!buttons_is_set) this.buttons = [];
				if(!id_is_set) this.id = "";
				return;
		}
	}
}
var input_internalUsers;
var input_localUser;
var input_localPlayer;
var input_isCertain;
var input_controllerButtonMap;
var input_players;
var input_playersById;
var input_cursor;
var input_showPointersMode;
var input_showPointers;
var input_ignoreFirstClick;
var input_isTextInputActive;
function input_textInput() {
	let localPlayer = input_playersById.get(input_localUser.id);
	return localPlayer.textInput;
}
function input_init() {
	input_internalUsers = [];
	input_localUser = null;
	input_localPlayer = null;
	input_isCertain = false;
	input_controllerButtonMap = new Map();
	input_players = [];
	input_playersById = [];
	input_cursor = "pointer";
	input_showPointersMode = 2/*Remote*/;
	input_showPointers = true;
	input_ignoreFirstClick = false;
	input_isTextInputActive = false;
	input_initHandlers();
}
function input_logicalToPixelPosition(pos) {
	let p = pos.getTransformed(graphics_totalMatrix)
	return new Vector2(p.x/Platform_pixelRatio, p.y/Platform_pixelRatio, null)
}
function input_initHandlers() {
	window.onpointerdown = e => {
		if(e.button == 0 && Platform_mode == 0) {
			Platform_record();
			if(input_ignoreFirstClick) return;
		}
		input_handleTouchEvent(1, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.onpointermove = e => {
		input_handleTouchEvent(2, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.onpointerup = e => {
		input_handleTouchEvent(3, e.pageX, e.pageY, e.pointerType, e.pointerId, e.button, e.shiftKey, e.altKey, e.ctrlKey || e.metaKey);
	}
	window.oncontextmenu = e => {
		e.preventDefault();
		e.stopPropagation();
		return false;
	}
	window.onwheel = e => {
		e.preventDefault();
		e.stopPropagation();
		if(e.button == 0 && Platform_mode == 0) Platform_record();
		input_handleWheelEvent(e.pageX, e.pageY, -e.deltaX, -e.deltaY)
		return false; 
	}
	window.onkeydown = e => {
		let keyCode = e.keyCode
		let key = e.key
		let ctrlOrCmd = e.ctrlKey || e.metaKey
		if(window.require && key == "t" && e.metaKey && e.shiftKey)
			require("electron").remote.getCurrentWindow().toggleDevTools()
		else
		if(ctrlOrCmd && key == "o") {
			
			core_openEventStream();
			e.preventDefault();
		}
		else
		if(ctrlOrCmd && key == "s") {
			
			core_saveEventStream();
			e.preventDefault();
		}
		else
		if(ctrlOrCmd && key == "l") {
			
			statistics_saveStatistics()
			core_saveLogs();
			e.preventDefault();
		}
		else
		if((key == "F1" || key == "F2" || key == "F3" || key == "F4") && !ctrlOrCmd && Platform_isDebug) {
			let index = key[1] - "1"
			core_switchUser(index);
			e.preventDefault();
		}
		else
		if(key >= "1" && key <= "0") {
			let index = key - "0"
			if(e.altKey) { core_save(index); e.preventDefault(); } else
			if(e.ctrlKey) { core_restore(index); e.preventDefault(); }
		}
		else
		
		if(ctrlOrCmd && key == "F1") {/*keep room, keep userId, keep master*/ ServerCore_sendReload(false, false, true ); e.preventDefault();} else
		if(ctrlOrCmd && key == "F2") {/*keep room, keep userId, everybody*/ ServerCore_sendReload(false, false, false); e.preventDefault();} else
		if(ctrlOrCmd && key == "F3") {/*new room, keep userId, everybody*/ ServerCore_sendReload(true, false, false); e.preventDefault();} else
		if(ctrlOrCmd && key == "F4") {/*new room, new userId, everybody*/ ServerCore_sendReload(true, true, false); e.preventDefault();} else
		
		
		if(ctrlOrCmd && key == "F5") {core_switchSendInterval( 3); e.preventDefault();} else
		if(ctrlOrCmd && key == "F6") {core_switchSendInterval(10); e.preventDefault();} else
		if(ctrlOrCmd && key == "F7") {core_switchSendInterval(20); e.preventDefault();} else
		if(ctrlOrCmd && key == "F8") {core_switchSendInterval(30); e.preventDefault();} else
		if(ctrlOrCmd && key == "F9") {core_switchSendInterval(40); e.preventDefault();} else
			
		if(ctrlOrCmd && key == "F10") {core_switchSendInputMode(1); e.preventDefault();} else
		if(ctrlOrCmd && key == "F11") {core_switchSendInputMode(2); e.preventDefault();} else
			
		if(key == "F9") {
			if(e.shiftKey) { core_saveLogs(); }
			else { Platform_toggleDebugInfo(); }
			e.preventDefault();
		} else if(key == "F10") { 
			Platform_toggleSmallScreen();
		} else {
			input_handleKeyEvent(5, keyCode, key?.length == 1 ? key : "")
			if(keyCode == 9) e.preventDefault();
		}
	}
	window.onkeyup = e => {
		input_handleKeyEvent(6, e.keyCode)
	}
		
	
	window.onpopstate = e => {
		input_handleNavigate(location.pathname);
	}
	
	if(window._input) window._input.value = ""
}
function input_setLastTouchMoveIndex(id, index) {
	let lastMoveIndex = input_localUser.lastTouchMoveIndex;
	lastMoveIndex.push(id);
	lastMoveIndex.push(index);
}
function input_getLastTouchMoveIndex(id) {
	let lastMoveIndex = input_localUser.lastTouchMoveIndex;
	let i = 0;
	while(i < lastMoveIndex.length) {
		if(lastMoveIndex.get(i) == id) {
			return lastMoveIndex.get(i + 1);
		}
		i += 2;
	}
	return 0;
}
function input_handleTextInput(type, text) {
	if(core_mode == 0/*None*/ || Platform_mode != 4/*Record*/ || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(type);
	inputs.writeString(text);
}
function input_handleKeyEvent(inputType, keyCode, key) {
	if(core_mode == 0/*None*/ || Platform_mode != 4/*Record*/ || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	let composite = inputType;
	let controllerButton = input_controllerButtonMap.get(keyCode);
	if(controllerButton) {
		composite += ((controllerButton.buttonIndex + 1) << 5);
		if(core_mode == 2/*Local*/ && !core_simulateConnection) {
			inputs = input_internalUsers.get(controllerButton.userId).inputs;
		}
	}
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt32(keyCode);
	if(inputType == 5/*KeyDown*/) {
		inputs.writeString(key);
	}
}
function input_handleTouchEvent(inputType, x, y, pointerType, pointerId, button, shift, alt, cmdOrCtrl) {
	let touchType = 0, id = 0;
	if(pointerType == "mouse") {
		touchType = (button < 0 ? 0 : button > 2 ? 2 : button);
	} else {
		if(pointerType == "touch") {
			touchType = 3;
			id = pointerId;
		} else {
			touchType = 4;
		}
	}
	let pixelPos = new Vector2(x * graphics_pixelRatio, y * graphics_pixelRatio, null);
	let referencePos = pixelPos.getRelativeTo(graphics_baseMatrix);
	gizmo_onTouch(inputType, id, pixelPos, referencePos, shift, alt, cmdOrCtrl);
	if(core_mode == 0/*None*/ || Platform_mode != 4/*Record*/ || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	if(inputType == 2/*TouchMove*/) {
		let index = input_getLastTouchMoveIndex(id);
		if(index) {
			inputs.dataView.setInt16(index, Math.round(referencePos.x));
			inputs.dataView.setInt16(index + 2, Math.round(referencePos.y));
			if(core_logging) {
				core_writeLog += " #"+input_localUser.inputFrame?.toString()+" override "+id?.toString()+" at "+index?.toString()+" to "+Math.round(referencePos.x)?.toString()+" "+Math.round(referencePos.y)?.toString();
			}
			return;
		} else {
			input_setLastTouchMoveIndex(id, inputs.writePos + 6);
			if(core_logging) {
				core_writeLog += " save "+id?.toString()+" at "+(inputs.writePos + 6)?.toString();
			}
		}
	}
	let composite = inputType + (touchType << 5) + (int_modulo_int(Math.floor(Math.abs(id)), 128) << 8);
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
	if(core_logging) {
		core_writeLog += " #"+input_localUser.inputFrame?.toString()+" "+composite?.toString()+" "+Math.round(referencePos.x)?.toString()+" "+Math.round(referencePos.y)?.toString()+" ("+inputs.readPos?.toString()+"/"+inputs.writePos?.toString()+")";
	}
}
function input_handleUpdateTouchAfterSwitchingUser(id, referencePos) {
	let inputs = input_localUser.inputs;
	let composite = 2/*TouchMove*/ + (0/*Left*/ << 5) + (int_modulo_int(Math.floor(Math.abs(id)), 128) << 8);
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(composite);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
}
function input_handleWheelEvent(x, y, deltaX, deltaY) {
	if(core_mode == 0/*None*/ || Platform_mode != 4/*Record*/ || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	let referencePos = new Vector2(x * graphics_pixelRatio, y * graphics_pixelRatio, null).getRelativeTo(graphics_baseMatrix);
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(4/*Scroll*/);
	inputs.writeInt16(Math.round(referencePos.x));
	inputs.writeInt16(Math.round(referencePos.y));
	inputs.writeInt16(Math.round(deltaX));
	inputs.writeInt16(Math.round(deltaY));
	if(core_logging) {
		core_writeLog += " ["+input_localUser.inputFrame?.toString()+"] wheel "+Math.round(referencePos.x)?.toString()+" "+Math.round(referencePos.y)?.toString()+" "+deltaX?.toString()+" "+deltaY?.toString()+" \{r:"+inputs.readPos?.toString()+" w:"+inputs.writePos?.toString()+"\}";
	}
}
function input_handleSetState(buffer) {
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeUnsignedInt16(19/*SetState*/);
	inputs.writeBuffer(buffer);
}
function input_handleJoin(frame) {
	let inputs = input_localUser.inputs;
	inputs.writeInt32(frame);
	inputs.writeInt16(16/*Join*/);
}
function input_handleNavigate(url) {
	if(core_mode == 0/*None*/ || Platform_mode != 4/*Record*/ || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(20/*Navigate*/);
	inputs.writeString(url);
}
function input_handleLost() {
	if(core_mode < 2/*Local*/ || !lobby_inLobby) {
		return;
	}
	for(let _subject=input_players, i=_subject.length-1; i>=0; --i) { let player = _subject[i]; {
		let internalUser = input_internalUsers.get(player.id);
		if((internalUser != null)) {
			if(player.lostAtFrame && core_frame > player.lostAtFrame + core_targetFps * 3) {
				core_log(("Removing player "+player.id?.toString()+" at frame "+core_frame?.toString()+", player was lost at frame "+player.lostAtFrame?.toString()+" and nobody disagreed")+", isCertain: "+input_isCertain);
				input_players.remove(player);
				input_playersById.set(player.id, null);
				internalUser.active = false;
				input_updatePlayers();
			} else {
				if(core_frame > internalUser.inputFrame + core_targetFps * 8 && core_frame > internalUser.nextLostMessageAtFrame) {
					core_log(("Sending lost message for player "+player.id?.toString()+" at frame "+core_frame?.toString())+", internalUser.inputFrame: "+internalUser.inputFrame?.toString());
					let inputs = input_localUser.inputs;
					inputs.writeInt32(input_localUser.inputFrame);
					inputs.writeInt16(17/*Lost*/);
					inputs.writeInt16(player.id);
					internalUser.nextLostMessageAtFrame = core_frame + core_targetFps * 12;
					setTimeout(() => {
						statistics_saveStatistics();
					}, (7*1000));
				}
			}
		}
	}}
}
function input_handleStillConnected(userId) {
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(18/*StillConnected*/);
	inputs.writeInt16(userId);
}
function input_handleString(id, data) {
	if(!data || core_mode == 0/*None*/ || core_frames > core_frame || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(22/*String*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
function input_handleJson(id, data) {
	if(!data || core_mode == 0/*None*/ || core_frames > core_frame || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(23/*Json*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
function input_handleObject(id, data) {
	if(!data || core_mode == 0/*None*/ || core_frames > core_frame || !(input_localUser != null) || !input_localUser.collectInputs) {
		return;
	}
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(24/*Object*/);
	inputs.writeInt(id);
	inputs.writeString(data);
}
function input_updateGameControllers() {
	let gamepads = navigator.getGamepads();
	if(gamepads == null) {
		return;
	}
	let gp = gamepads[0];
	if(!(gp != null) || gp.axes.length < 2) {
		return;
	}
	let isPlayStation = (gp.id.indexOf("54c") != -1) || (gp.id.indexOf("810") != -1);
	let axes = gp.axes;
	let leftStickX = axes.get(0);
	let leftStickY = axes.get(1);
	let buttons = ((gp.buttons.get(0).pressed ? 1 : 0)) + ((gp.buttons.get(1).pressed ? 2 : 0)) + ((gp.buttons.get(2).pressed ? 4 : 0)) + ((gp.buttons.get(3).pressed ? 8 : 0)) + ((gp.buttons.get(4).pressed ? 16 : 0)) + ((gp.buttons.get(5).pressed ? 32 : 0)) + ((gp.buttons.get(8).pressed ? 64 : 0)) + ((gp.buttons.get(9).pressed ? 128 : 0)) + ((gp.buttons.get(10).pressed ? 256 : 0)) + ((gp.buttons.get(11).pressed ? 512 : 0)) + ((gp.buttons.get(12).pressed ? 1024 : 0)) + ((gp.buttons.get(13).pressed ? 2048 : 0)) + ((gp.buttons.get(14).pressed ? 4096 : 0)) + ((gp.buttons.get(15).pressed ? 8192 : 0)) + ((isPlayStation ? 16384 : 0));
	let inputs = input_localUser.inputs;
	inputs.writeInt32(input_localUser.inputFrame);
	inputs.writeInt16(21/*GameController*/);
	inputs.writeFloat32((Math.abs(leftStickX) > GameController_deadZone ? leftStickX : 0));
	inputs.writeFloat32((Math.abs(leftStickY) > GameController_deadZone ? leftStickY : 0));
	inputs.writeUnsignedInt16(buttons);
}
function input_parseInputs(frame) {
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let internalUser = _subject[i]; {
		if((internalUser != null)) {
			let inputs = internalUser.inputs;
			let userId = internalUser.id;
			let player = input_playersById.get(userId);
			if(core_logging) {
				core_parseLog += " <"+userId?.toString()+">";
			}
			player?.controller.startFrame();
			while(true) {
				let nextFrame = (inputs.canRead() ? inputs.dataView.getInt32(inputs.readPos) : int_maxValue);
				if(core_logging) {
					core_parseLog += " ("+inputs.readPos?.toString()+"/"+inputs.writePos?.toString()+")";
					if(inputs.canRead()) {
						core_parseLog += " *"+nextFrame?.toString();
					}
				}
				if(nextFrame > frame) {
					break;
				}
				inputs.readPos += 4;
				if(!(player != null)) {
					core_log(("#"+frame?.toString()+" Add "+userId?.toString()));
					if(core_logging) {
						core_parseLog += " Add "+userId?.toString();
					}
					input_players.push(player = new Player(userId, input_players.length, null, new Vector2(0.0, 0.0, null), 0));
					input_playersById.set(userId, player);
					if(internalUser.local) {
						input_localPlayer = player;
					}
					internalUser.active = true;
					input_updatePlayers();
				}
				let value = inputs.readUnsignedInt16();
				let inputType = int_modulo_int(value, 32);
				if(inputType >= 1/*TouchDown*/ && inputType <= 4/*Scroll*/) {
					if(!(player != null)) {
						core_log((" ERROR: userId "+userId?.toString()+" not in playersById"));
					}
					let type = int_modulo_int(((value >> 5)), 8);
					let id = int_modulo_int(((value >> 8)), 128);
					let referencePos = new Vector2(inputs.readInt16(), inputs.readInt16(), null);
					let isSmoothPosition = !core_smoothTouchPosition || internalUser.local || frame <= internalUser.smoothFrame;
					if(core_logging) {
						core_parseLog += " " + id;
					}
					if(inputType == 1/*TouchDown*/) {
						let touch = player.touches.find(a => a.id == id);
						if((touch != null)) {
							touch.phase = inputType;
							Vector2_assign_Vector2(touch.referencePosition, referencePos);
							Vector2_assign_Vector2(touch.referenceStartPosition, referencePos);
							touch.type = type;
							touch.isDown = true;
							touch.handled = false;
							if(core_logging) {
								core_parseLog += " down "+id?.toString()+" "+referencePos?.toString()+" "+type;
							}
							if(isSmoothPosition) {
								Vector2_assign_Vector2(touch.smoothPosition, referencePos);
							}
						} else {
							touch = new Touch(id, player, inputType, type, referencePos, referencePos, referencePos, true, false);
							player.touches.push(touch);
							if(core_logging) {
								core_parseLog += " down(new) "+id?.toString()+" "+referencePos?.toString()+" "+type;
							}
						}
						Vector2_assign_Vector2(player.pointerPosition, referencePos);
						internalUser.downTouches.push(touch);
					} else {
						if(inputType == 2/*TouchMove*/) {
							let touch = player.touches.find(a => a.id == id);
							if((touch != null)) {
								touch.phase = inputType;
								Vector2_assign_Vector2(touch.referencePosition, referencePos);
								touch.type = type;
								if(isSmoothPosition) {
									Vector2_assign_Vector2(touch.smoothPosition, referencePos);
								}
								if(core_logging) {
									core_parseLog += " move "+id?.toString()+" "+referencePos?.toString()+" "+type;
								}
							} else {
								touch = new Touch(id, player, inputType, type, referencePos, Vector2_none, referencePos, false, false);
								player.touches.push(touch);
								if(core_logging) {
									core_parseLog += " move(new) "+id?.toString()+" "+referencePos?.toString()+" "+type;
								}
							}
							Vector2_assign_Vector2(player.pointerPosition, referencePos);
							internalUser.movingTouches.push(touch);
							input_cursor = "auto";
						} else {
							if(inputType == 3/*TouchUp*/) {
								let touch = player.touches.find(a => a.id == id);
								if((touch != null)) {
									touch.phase = inputType;
									Vector2_assign_Vector2(touch.referencePosition, referencePos);
									touch.type = type;
									touch.isDown = false;
									if(isSmoothPosition) {
										Vector2_assign_Vector2(touch.smoothPosition, referencePos);
									}
									if(core_logging) {
										core_parseLog += " up "+id?.toString()+" "+referencePos?.toString()+" "+type;
									}
								} else {
									touch = new Touch(id, player, inputType, type, referencePos, Vector2_none, referencePos, false, false);
									player.touches.push(touch);
									if(core_logging) {
										core_parseLog += " up(new) "+id?.toString()+" "+referencePos?.toString()+" "+type;
									}
								}
								Vector2_assign_Vector2(player.pointerPosition, referencePos);
								internalUser.upTouches.push(touch);
							} else {
								if(inputType == 4/*Scroll*/) {
									let delta = new Vector2(inputs.readInt16(), inputs.readInt16(), null);
									internalUser.wheelEvents.push(new ScrollEvent(player.id, delta, referencePos, false));
								}
							}
						}
					}
				} else {
					if(inputType == 7/*TextInput*/) {
						let textInput = inputs.readString();
						player.textInput = textInput;
						internalUser.textInputs.push(textInput);
					} else {
						if(inputType == 5/*KeyDown*/) {
							let key = inputs.readInt32();
							let keyPressed = inputs.readString();
							internalUser.downKeys.push(key);
							player.keysCurrentlyDown.ensure(key);
							if(keyPressed) {
								internalUser.pressedKeys.push(keyPressed);
							}
							let controllerButtonIndex = int_modulo_int(((value >> 5)), 16);
							if(controllerButtonIndex) {
								player.controllerKeyDownFrame.set(controllerButtonIndex - 1, frame);
							}
							if(core_logging) {
								core_parseLog += " KeyDown "+key;
							}
						} else {
							if(inputType == 6/*KeyUp*/) {
								let key = inputs.readInt32();
								internalUser.upKeys.push(key);
								player.keysCurrentlyDown.remove(key);
								let controllerButtonIndex = int_modulo_int(((value >> 5)), 16);
								if(controllerButtonIndex) {
									player.controllerKeyDownFrame.set(controllerButtonIndex - 1, 0);
								}
								if(core_logging) {
									core_parseLog += " KeyUp "+key;
								}
							} else {
								if(inputType == 20/*Navigate*/) {
									internalUser.navigations.push(inputs.readString());
								} else {
									if(inputType == 21/*GameController*/) {
										let c = player.controller;
										c.leftStick.x = inputs.readFloat32();
										c.leftStick.y = inputs.readFloat32();
										let buttons = inputs.readUnsignedInt16();
										c.a.state = ((buttons & 1)) != 0;
										c.b.state = ((buttons & 2)) != 0;
										c.x.state = ((buttons & 4)) != 0;
										c.y.state = ((buttons & 8)) != 0;
										c.type = (((buttons & 16384)) != 0 ? 2/*PlayStation*/ : 1/*Xbox*/);
										if(c.type == 1/*Xbox*/) {
											c.a.name = "A";
											c.b.name = "B";
											c.x.name = "X";
											c.y.name = "Y";
										} else {
											c.a.name = "X";
											c.b.name = "O";
											c.x.name = "SQUARE";
											c.y.name = "TRIANGLE";
										}
									} else {
										if(inputType == 16/*Join*/) {
											core_log(("#"+frame?.toString()+" Join "+userId?.toString())+", isCertain: "+input_isCertain);
											if(core_logging) {
												core_parseLog += " Join "+userId?.toString();
											}
										} else {
											if(inputType == 17/*Lost*/) {
												let lostUserId = inputs.readInt16();
												let lostInternalUser = input_internalUsers.get(lostUserId);
												if((lostInternalUser != null)) {
													let lostPlayer = input_playersById.get(lostUserId);
													if((lostPlayer != null) && lostPlayer.lostAtFrame == 0) {
														lostPlayer.lostAtFrame = frame;
														core_log(("Lost "+lostUserId?.toString()+" by "+userId?.toString()+" -> Set lostAtFrame to "+lostPlayer.lostAtFrame?.toString()));
													}
													if((lostInternalUser.dataChannel != null) && core_frame < lostInternalUser.inputFrame + core_targetFps * 5) {
														core_log(("Lost "+lostUserId?.toString()+" by "+userId?.toString()+" -> We are still connected, sending StillConnected")+", lostInternalUser.dataChannel: "+(object_stringify(lostInternalUser.dataChannel, 3) || "null")+", core.frame: "+core_frame?.toString()+", lostInternalUser.inputFrame: "+lostInternalUser.inputFrame?.toString()+", isCertain: "+input_isCertain);
														input_handleStillConnected(lostUserId);
													} else {
														core_log(("Lost "+lostUserId?.toString()+" by "+userId?.toString()+" -> We also aren't connected")+", lostInternalUser.dataChannel: "+(object_stringify(lostInternalUser.dataChannel, 3) || "null")+", core.frame: "+core_frame?.toString()+", lostInternalUser.inputFrame: "+lostInternalUser.inputFrame?.toString()+", isCertain: "+input_isCertain);
													}
												} else {
													core_log(("Lost "+lostUserId?.toString()+" by "+userId?.toString()+" -> No internal user!"));
												}
											} else {
												if(inputType == 18/*StillConnected*/) {
													let lostUserId = inputs.readInt16();
													core_log(("Still connected to "+lostUserId?.toString()+" by "+userId?.toString()));
													let lostPlayer = input_playersById.get(lostUserId);
													if((lostPlayer != null)) {
														lostPlayer.lostAtFrame = 0;
													}
												} else {
													if(inputType == 19/*SetState*/) {
														if(core_logging) {
															core_parseLog += " setState";
														}
														core_snapshotBuffer.reset();
														inputs.readBuffer(core_snapshotBuffer, 0);
														deserialize_internal(core_snapshotBuffer);
														math_recreateRandomValues();
													} else {
														if(inputType == 22/*String*/) {
															let id = inputs.readInt();
															let valueString = inputs.readString();
															if(core_logging) {
																core_parseLog += " string "+id?.toString()+": "+valueString;
															}
															networkData_call(id, valueString);
															if(Platform_waitingForInitialData > 0) {
																Platform_waitingForInitialData--;
															}
														} else {
															if(inputType == 23/*Json*/) {
																let id = inputs.readInt();
																let valueString = inputs.readString();
																if(core_logging) {
																	core_parseLog += " json "+id?.toString()+": "+valueString;
																}
																let object = JSON.parse(valueString);
																networkData_call(id, object);
																if(Platform_waitingForInitialData > 0) {
																	Platform_waitingForInitialData--;
																}
															} else {
																if(inputType == 24/*Object*/) {
																	let id = inputs.readInt();
																	let valueString = inputs.readString();
																	if(core_logging) {
																		core_parseLog += " object "+id?.toString()+": "+valueString;
																	}
																	let object = JSON.parse(valueString);
																	networkData_call(id, object);
																	if(Platform_waitingForInitialData > 0) {
																		Platform_waitingForInitialData--;
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}}
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		let internalUser = input_internalUsers.get(it.id);
		if(frame <= internalUser.inputFrame) {
			let right = it.controllerKeyDownFrame.get(0);
			let down = it.controllerKeyDownFrame.get(1);
			let left = it.controllerKeyDownFrame.get(2);
			let up = it.controllerKeyDownFrame.get(3);
			if(right || left) {
				it.controller.leftStick.x = (right >= left ? 1 : -1);
			}
			if(down || up) {
				it.controller.leftStick.y = (down >= up ? 1 : -1);
			}
			if(it.controllerKeyDownFrame.get(4)) {
				it.controller.a.state = true;
			}
			if(it.controllerKeyDownFrame.get(5)) {
				it.controller.b.state = true;
			}
			if(it.controllerKeyDownFrame.get(6)) {
				it.controller.x.state = true;
			}
			if(it.controllerKeyDownFrame.get(7)) {
				it.controller.y.state = true;
			}
			it.controller.inMotion = Math.abs(it.controller.leftStick.x) >= GameController_deadZone || Math.abs(it.controller.leftStick.y) >= GameController_deadZone;
		}
	}}
}
function input_updatePlayers() {
	input_players.orderBy(a => a.id);
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.index = i;
		it.color = graphics_defaultColors.get(i);
		input_internalUsers.get(it.id).index = i;
	}}
	if(core_mode == 2/*Local*/ && !core_simulateConnection) {
		if(input_players.length >= 1) {
			let c = input_players.get(0).controller;
			if(c.type == 0/*Keyboard*/) {
				c.right.assign("→", 39/*Right*/);
				c.down.assign("↓", 40/*Down*/);
				c.left.assign("←", 37/*Left*/);
				c.up.assign("↑", 38/*Up*/);
				c.a.assign("SPACE", 32/*Space*/);
				c.b.assign("B", 66/*B*/);
			}
		}
		if(input_players.length >= 2) {
			let c = input_players.get(1).controller;
			if(c.type == 0/*Keyboard*/) {
				c.right.assign("D", 68/*D*/);
				c.down.assign("S", 83/*S*/);
				c.left.assign("A", 65/*A*/);
				c.up.assign("W", 87/*W*/);
				c.a.assign("F", 70/*F*/);
				c.b.assign("G", 71/*G*/);
			}
		}
		if(input_players.length >= 3) {
			let c = input_players.get(2).controller;
			if(c.type == 0/*Keyboard*/) {
				c.right.assign("L", 76/*L*/);
				c.down.assign("K", 75/*K*/);
				c.left.assign("J", 74/*J*/);
				c.up.assign("I", 73/*I*/);
				c.a.assign("O", 79/*O*/);
				c.b.assign("P", 80/*P*/);
			}
		}
		input_controllerButtonMap.clear();
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
			for(let i=0, _subject=player.controller.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				input_controllerButtonMap.set(it.key, new ControllerButtonPlayerAndIndex(player.id, i));
			}}
		}}
	} else {
		input_controllerButtonMap.clear();
		for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			let c = it.controller;
			if(c.type == 0/*Keyboard*/) {
				c.right.assign("→", 39/*Right*/);
				c.down.assign("↓", 40/*Down*/);
				c.left.assign("←", 37/*Left*/);
				c.up.assign("↑", 38/*Up*/);
				c.a.assign("SPACE", 32/*Space*/);
				c.b.assign("B", 66/*B*/);
			}
		}}
		input_controllerButtonMap.clear();
		for(let i=0, _subject=input_localPlayer.controller.buttons, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			input_controllerButtonMap.set(it.key, new ControllerButtonPlayerAndIndex(input_localPlayer.id, i));
		}}
		input_controllerButtonMap.set(68/*D*/, new ControllerButtonPlayerAndIndex(input_localUser.id, 0));
		input_controllerButtonMap.set(83/*S*/, new ControllerButtonPlayerAndIndex(input_localUser.id, 1));
		input_controllerButtonMap.set(65/*A*/, new ControllerButtonPlayerAndIndex(input_localUser.id, 2));
		input_controllerButtonMap.set(87/*W*/, new ControllerButtonPlayerAndIndex(input_localUser.id, 3));
	}
}
function input_log(text, pos) {
	if(core_logging) {
		core_touchLog += " #"+core_frame?.toString()+((input_isCertain ? " c" : ""))+" "+text+" "+pos?.toString();
	}
}
function input_getTargetedPlayers(by) {
	return ((core_mode == 3/*Connected*/ || core_simulateConnection) && (by != null && by?.length != 0)  && by.length > 0 && (by.get(0) != null) ? by : input_players);
}
function input_onTouchDown(by, markAsHandled, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/)) {
				input_log("down", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
	}}
}
function input_onTouchDownWithin(position, size, by, cursor, showTouchArea, markAsHandled, align, valign, $do) {
	let sizeX = size.x;
	let sizeY = size.y || size.x;
	let x = (align == 0/*Left*/ ? position.x : (align == 1/*Center*/ ? position.x - sizeX / 2 : position.x - sizeX));
	let y = (valign == 0/*Top*/ ? position.y : (valign == 1/*Middle*/ ? position.y - sizeY / 2 : position.y - sizeY));
	let poly = [new Vector2(x, y, null).transform(graphics_localMatrix), new Vector2(x + sizeX, y, null).transform(graphics_localMatrix), new Vector2(x + sizeX, y + sizeY, null).transform(graphics_localMatrix), new Vector2(x, y + sizeY, null).transform(graphics_localMatrix)];
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePoygon(poly)) {
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
	}}
	if(cursor != "auto") {
		for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && touch.referencePosition.isInsidePoygon(poly)) {
				input_cursor = cursor;
			}
		}}
	}
}
function input_onTouchDownWithin2(position, size, angle, by, cursor, showTouchArea, markAsHandled, align, valign, $do) {
	let halfSizeX = size.x / 2;
	let halfSizeY = (size.y || size.x) / 2;
	let x = (align == 0/*Left*/ ? position.x + halfSizeX : (align == 1/*Center*/ ? position.x : position.x - halfSizeX));
	let y = (valign == 0/*Top*/ ? position.y + halfSizeY : (valign == 1/*Middle*/ ? position.y : position.y - halfSizeY));
	let poly = [new Vector2(-halfSizeX, -halfSizeY, null).rotate(angle).move2(x, y).transform(graphics_localMatrix), new Vector2(+halfSizeX, -halfSizeY, null).rotate(angle).move2(x, y).transform(graphics_localMatrix), new Vector2(+halfSizeX, +halfSizeY, null).rotate(angle).move2(x, y).transform(graphics_localMatrix), new Vector2(-halfSizeX, +halfSizeY, null).rotate(angle).move2(x, y).transform(graphics_localMatrix)];
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePoygon(poly)) {
				input_log("down", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePoygon(poly)) {
					input_cursor = cursor;
				}
			}}
		}
	}}
}
function input_onTouchDownWithin3(position, radius, by, cursor, showTouchArea, markAsHandled, $do) {
	let referencePosition = position.getTransformed(graphics_localMatrix);
	let referenceRadius = radius * graphics_localMatrix.scaleVector().x;
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && (touch.referencePosition.distanceTo(referencePosition)) <= referenceRadius) {
				input_log("down", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && (touch.referencePosition.distanceTo(position)) <= radius) {
					input_cursor = cursor;
				}
			}}
		}
	}}
}
function input_onTouchDownWithin4(points, position, by, cursor, showTouchArea, markAsHandled, $do) {
	let poly = [];
	for(let i=0, _subject=points, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		poly.push((Vector2_plus_Vector2(position, it)).transform(graphics_localMatrix));
	}}
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (player.enableTouch || touch.type != 3/*Touch*/) && touch.referencePosition.isInsidePoygon(poly)) {
				input_log("down", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePoygon(poly)) {
					input_cursor = cursor;
				}
			}}
		}
	}}
}
function input_onTouchDownAny(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(player.enableTouch || touch.type != 3/*Touch*/) {
				input_log("down", touch.referencePosition);
				$do(touch);
			}
		}}
	}}
}
function input_onTouchOver(position, size, by, cursor, showTouchArea, markAsHandled, $do) {
	let poly = [new Vector2(position.x - size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x - size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix)];
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=player.touches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(touch.referencePosition.isInsidePoygon(poly)) {
				input_log("over", touch.referencePosition);
				$do(touch);
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && touch.referencePosition.isInsidePoygon(poly)) {
					input_cursor = cursor;
				}
			}}
		}
	}}
}
function input_onTouchMove(touch, triggeredOnTouchDown, $do) {
	if(!(touch != null)) {
		return;
	}
	let touchId = touch.id;
	let user = input_internalUsers.get(touch.by.id);
	if((user != null)) {
		if(triggeredOnTouchDown) {
			for(let i=0, _subject=user.downTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
				if(it.id == touchId) {
					input_log("down triggers move", it.referencePosition);
					$do(it);
				}
			}}
		}
		for(let i=0, _subject=user.movingTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.id == touchId) {
				input_log("move", it.referencePosition);
				$do(it);
			}
		}}
	}
}
function input_onTouchMove2(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(it.id).movingTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			input_log("move", it.referencePosition);
			$do(it);
		}}
	}}
}
function input_onTouchUp(touch, markAsHandled, $do) {
	if(!(touch != null)) {
		return;
	}
	let touchId = touch.id;
	let user = input_internalUsers.get(touch.by.id);
	if((user != null)) {
		for(let i=0, _subject=user.upTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it.id == touchId) {
				input_log("up", it.referencePosition);
				$do(it);
				Snapshot_autoSave();
				if(markAsHandled) {
					it.handled = true;
				}
			}
		}}
	}
}
function input_onTouchUp2(by, markAsHandled, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(it.id).upTouches, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(!it.handled) {
				input_log("up", it.referencePosition);
				$do(it);
				Snapshot_autoSave();
			}
		}}
	}}
}
function input_onTouchUpWithin(position, size, by, showTouchArea, markAsHandled, $do) {
	let poly = [new Vector2(position.x - size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x - size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix)];
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).upTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && touch.referencePosition.isInsidePoygon(poly)) {
				input_log("up", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
				Snapshot_autoSave();
			}
		}}
	}}
}
function input_onTouchUpWithin2(position, radius, by, cursor, showTouchArea, markAsHandled, $do) {
	let referencePosition = position.transform(graphics_localMatrix);
	let referenceRadius = radius * graphics_localMatrix.scaleVector().x;
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).upTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
			if(!touch.handled && (touch.referencePosition.distanceTo(referencePosition)) <= referenceRadius) {
				input_log("up", touch.referencePosition);
				$do(touch);
				if(markAsHandled) {
					touch.handled = true;
				}
				Snapshot_autoSave();
			}
		}}
		if(cursor != "auto") {
			for(let i=0, _subject=input_localUser.movingTouches, _len=_subject.length; i<_len; ++i) { let touch = _subject[i]; {
				if(!touch.handled && (touch.referencePosition.distanceTo(position)) <= radius) {
					input_cursor = cursor;
				}
			}}
		}
	}}
}
function input_onScroll(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(it.id).wheelEvents, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			$do(it);
		}}
	}}
}
function input_onScrolllWithin(position, size, by, showTouchArea, markAsHandled, $do) {
	let poly = [new Vector2(position.x - size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y - size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x + size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix), new Vector2(position.x - size.x / 2, position.y + size.y / 2, null).transform(graphics_localMatrix)];
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(it.id).wheelEvents, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(!it.handled && it.referencePosition.isInsidePoygon(poly)) {
				input_log("wheel", it.referencePosition);
				$do(it);
				if(markAsHandled) {
					it.markAsHandled();
				}
			}
		}}
	}}
}
function input_getOrCreateInputField() {
	if(!window._input) {
		window._input = document.createElement("input")
		_input.type = "text"
		_input.style.position = "absolute"
		_input.style.left = "-10000px" 
		_input.style.width = "1px"
		_input.style.height = "1px"
		_input.style.fontSize = "1px"
		_input.style.backgroundColor = "#000000"
		_input.oninput = e => input_handleTextInput(7, _input.value)
		_input.onblur = e => {
			if(input_isTextInputActive) {
				_input.focus()
			}
		}
		document.body.appendChild(_input)
	}
	return _input
}
function input_startTextInput(initalValue, forUser) {
	if(forUser == -1 || input_localUser?.id == forUser) {
		let input = input_getOrCreateInputField()
		if(initalValue != null) { 
			input.value = initalValue
		}
		_input.focus()
		input_isTextInputActive = true
	}
}
function input_stopTextInput() {
	input_isTextInputActive = false
}
function input_setTextInput(value) {
	let input = input_getOrCreateInputField()
	input.value = value
	input_handleTextInput(7, value)
}
function input_updateCursor() {
	
	document.body.style.cursor = input_cursor
}
function input_onTextComposition($do) {
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user != null)) {
			for(let i=0, _subject=user.textCompositions, _len=_subject.length; i<_len; ++i) { let characters = _subject[i]; {
				$do(characters);
			}}
		}
	}}
}
function input_onTextInput(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(it.id).textInputs, _len=_subject.length; i<_len; ++i) { let textInput = _subject[i]; {
			$do(textInput);
		}}
	}}
}
function input_onKeyDown(key, by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downKeys, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
			if(it == key) {
				$do(key, player);
			}
		}}
	}}
}
function input_onKeyDown2(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).downKeys, _len=_subject.length; i<_len; ++i) { let key = _subject[i]; {
			$do(key, player);
		}}
	}}
}
function input_onKeyUp(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).upKeys, _len=_subject.length; i<_len; ++i) { let key = _subject[i]; {
			$do(key, player);
		}}
	}}
}
function input_onType(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).pressedKeys, _len=_subject.length; i<_len; ++i) { let character = _subject[i]; {
			$do(character, player);
		}}
	}}
}
function input_isKeyDown(key, by) {
	if((core_mode == 3/*Connected*/ || core_simulateConnection) && (by != null)) {
		let player = input_playersById.get(by.id);
		if((player != null)) {
			return player.keysCurrentlyDown.includes(key);
		}
	} else {
		return input_players.some(a => a.keysCurrentlyDown.includes(key));
	}
	return false;
}
function input_onNavigate(by, $do) {
	for(let i=0, _subject=input_getTargetedPlayers(by), _len=_subject.length; i<_len; ++i) { let player = _subject[i]; {
		for(let i=0, _subject=input_internalUsers.get(player.id).navigations, _len=_subject.length; i<_len; ++i) { let url = _subject[i]; {
			$do(url);
		}}
	}}
}
function input_serialize_internal(buffer) {
	if(input_players) {
		var index = _objectCacheIndex.get(input_players);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(input_players, index = _objectCache.length);
			_objectCache.push(input_players);
			buffer.writeInt32(-index);
			input_players._objectIndex = index;
			buffer.writeInt32(input_players.length);
			for(let i=0, len=input_players.length; i<len; ++i) {
				let input_players_item = input_players[i]
				if(input_players_item) {
					var index = _objectCacheIndex.get(input_players_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(input_players_item, index = _objectCache.length);
						_objectCache.push(input_players_item);
						buffer.writeInt32(-index);
						input_players_item._objectIndex = index;
						input_players_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	if(input_playersById) {
		var index = _objectCacheIndex.get(input_playersById);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(input_playersById, index = _objectCache.length);
			_objectCache.push(input_playersById);
			buffer.writeInt32(-index);
			input_playersById._objectIndex = index;
			buffer.writeInt32(input_playersById.length);
			for(let i=0, len=input_playersById.length; i<len; ++i) {
				let input_playersById_item = input_playersById[i]
				if(input_playersById_item) {
					var index = _objectCacheIndex.get(input_playersById_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(input_playersById_item, index = _objectCache.length);
						_objectCache.push(input_playersById_item);
						buffer.writeInt32(-index);
						input_playersById_item._objectIndex = index;
						input_playersById_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(input_cursor);
	buffer.writeInt32(input_showPointersMode);
	buffer.writeBool(input_showPointers);
	buffer.writeBool(input_ignoreFirstClick);
	buffer.writeBool(input_isTextInputActive);
}
function input_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		input_players = _objectCache[index];
	} else {
		if(!input_players || input_players._objectIndex != -index) input_players = [];
		_objectCache[-index] = input_players;
		for(let i=0, len = input_players.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					input_players[i] = _objectCache[index];
				} else {
					let input_players_item = input_players[i]
					if(!input_players_item || input_players_item._objectIndex != -index)
						input_players[i] = input_players_item = new _Player();
					(_objectCache[-index] = input_players_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		input_playersById = _objectCache[index];
	} else {
		if(!input_playersById || input_playersById._objectIndex != -index) input_playersById = [];
		_objectCache[-index] = input_playersById;
		for(let i=0, len = input_playersById.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					input_playersById[i] = _objectCache[index];
				} else {
					let input_playersById_item = input_playersById[i]
					if(!input_playersById_item || input_playersById_item._objectIndex != -index)
						input_playersById[i] = input_playersById_item = new _Player();
					(_objectCache[-index] = input_playersById_item).deserialize_internal(buffer);
				}
		}
	}
	input_cursor = buffer.readInt32();
	input_showPointersMode = buffer.readInt32();
	input_showPointers = buffer.readBool();
	input_ignoreFirstClick = buffer.readBool();
	input_isTextInputActive = buffer.readBool();
}
function input_serialize_external(buffer) {
	buffer.writeString("players");
	let input_players_startPos = buffer.reserveSize();
	if(input_players) {
		var index = _objectCacheIndex.get(input_players);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(input_players, index = _objectCache.length);
			_objectCache.push(input_players);
			buffer.writeInt32(-index);
			input_players._objectIndex = index;
			buffer.writeInt32(input_players.length);
			for(let i=0, len=input_players.length; i<len; ++i) {
				let input_players_item = input_players[i]
				if(input_players_item) {
					var index = _objectCacheIndex.get(input_players_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(input_players_item, index = _objectCache.length);
						_objectCache.push(input_players_item);
						buffer.writeInt32(-index);
						input_players_item._objectIndex = index;
						input_players_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(input_players_startPos);
	buffer.writeString("playersById");
	let input_playersById_startPos = buffer.reserveSize();
	if(input_playersById) {
		var index = _objectCacheIndex.get(input_playersById);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(input_playersById, index = _objectCache.length);
			_objectCache.push(input_playersById);
			buffer.writeInt32(-index);
			input_playersById._objectIndex = index;
			buffer.writeInt32(input_playersById.length);
			for(let i=0, len=input_playersById.length; i<len; ++i) {
				let input_playersById_item = input_playersById[i]
				if(input_playersById_item) {
					var index = _objectCacheIndex.get(input_playersById_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(input_playersById_item, index = _objectCache.length);
						_objectCache.push(input_playersById_item);
						buffer.writeInt32(-index);
						input_playersById_item._objectIndex = index;
						input_playersById_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(input_playersById_startPos);
	buffer.writeString("cursor");
	buffer.writeInt32(4);
	buffer.writeInt32(input_cursor);
	buffer.writeString("showPointersMode");
	buffer.writeInt32(4);
	buffer.writeInt32(input_showPointersMode);
	buffer.writeString("showPointers");
	buffer.writeInt32(1);
	buffer.writeBool(input_showPointers);
	buffer.writeString("ignoreFirstClick");
	buffer.writeInt32(1);
	buffer.writeBool(input_ignoreFirstClick);
	buffer.writeString("isTextInputActive");
	buffer.writeInt32(1);
	buffer.writeBool(input_isTextInputActive);
	buffer.writeString("");
}
function input_deserialize_external(buffer) {
	let players_is_set = false, playersById_is_set = false, cursor_is_set = false, showPointersMode_is_set = false, showPointers_is_set = false, ignoreFirstClick_is_set = false, isTextInputActive_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "players":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input_players = _objectCache[index];
				} else {
					if(!input_players || input_players._objectIndex != -index) input_players = [];
					_objectCache[-index] = input_players;
					for(let i=0, len = input_players.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								input_players[i] = _objectCache[index];
							} else {
								let input_players_item = input_players[i]
								if(!input_players_item || input_players_item._objectIndex != -index)
									input_players[i] = input_players_item = new _Player();
								(_objectCache[-index] = input_players_item).deserialize_external(buffer);
							}
					}
				}
				players_is_set = true;
				break;
			case "playersById":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					input_playersById = _objectCache[index];
				} else {
					if(!input_playersById || input_playersById._objectIndex != -index) input_playersById = [];
					_objectCache[-index] = input_playersById;
					for(let i=0, len = input_playersById.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								input_playersById[i] = _objectCache[index];
							} else {
								let input_playersById_item = input_playersById[i]
								if(!input_playersById_item || input_playersById_item._objectIndex != -index)
									input_playersById[i] = input_playersById_item = new _Player();
								(_objectCache[-index] = input_playersById_item).deserialize_external(buffer);
							}
					}
				}
				playersById_is_set = true;
				break;
			case "cursor":
				buffer.readInt32();
				input_cursor = buffer.readInt32();
				cursor_is_set = true;
				break;
			case "showPointersMode":
				buffer.readInt32();
				input_showPointersMode = buffer.readInt32();
				showPointersMode_is_set = true;
				break;
			case "showPointers":
				buffer.readInt32();
				input_showPointers = buffer.readBool();
				showPointers_is_set = true;
				break;
			case "ignoreFirstClick":
				buffer.readInt32();
				input_ignoreFirstClick = buffer.readBool();
				ignoreFirstClick_is_set = true;
				break;
			case "isTextInputActive":
				buffer.readInt32();
				input_isTextInputActive = buffer.readBool();
				isTextInputActive_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!players_is_set) input_players = [];
				if(!playersById_is_set) input_playersById = [];
				if(!cursor_is_set) input_cursor = "pointer";
				if(!showPointersMode_is_set) input_showPointersMode = 2/*Remote*/;
				if(!showPointers_is_set) input_showPointers = true;
				if(!ignoreFirstClick_is_set) input_ignoreFirstClick = false;
				if(!isTextInputActive_is_set) input_isTextInputActive = false;
				return;
		}
	}
}
var networkData_callbacks;
function networkData_init() {
	networkData_callbacks = [];
}
function networkData_call(id, data) {
	networkData_callbacks.get(id).invoke(data);
}
function networkData_addCallback($do) {
	let id = networkData_callbacks.length;
	networkData_callbacks.push($do);
	return id;
}
function networkData_serialize_internal(buffer) {
	if(networkData_callbacks) {
		var index = _objectCacheIndex.get(networkData_callbacks);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(networkData_callbacks, index = _objectCache.length);
			_objectCache.push(networkData_callbacks);
			buffer.writeInt32(-index);
			networkData_callbacks._objectIndex = index;
			buffer.writeInt32(networkData_callbacks.length);
			for(let i=0, len=networkData_callbacks.length; i<len; ++i) {
				let networkData_callbacks_item = networkData_callbacks[i]
				if(networkData_callbacks_item) {
					var index = _objectCacheIndex.get(networkData_callbacks_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(networkData_callbacks_item, index = _objectCache.length);
						_objectCache.push(networkData_callbacks_item);
						buffer.writeInt32(-index);
						buffer.writeInt32(networkData_callbacks_item._id);
						networkData_callbacks_item._objectIndex = index;
						networkData_callbacks_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
function networkData_deserialize_internal(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		networkData_callbacks = _objectCache[index];
	} else {
		if(!networkData_callbacks || networkData_callbacks._objectIndex != -index) networkData_callbacks = [];
		_objectCache[-index] = networkData_callbacks;
		for(let i=0, len = networkData_callbacks.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					networkData_callbacks[i] = _objectCache[index];
				} else {
					let networkData_callbacks_item = networkData_callbacks[i]
					let _id = buffer.readInt32();
					if(!networkData_callbacks_item || networkData_callbacks_item._id != _id || networkData_callbacks_item._objectIndex != -index)
						networkData_callbacks[i] = networkData_callbacks_item = new _lambdaContructors[_id]();
					networkData_callbacks_item._id = _id;
					(_objectCache[-index] = networkData_callbacks_item).deserialize_internal(buffer);
				}
		}
	}
}
function networkData_serialize_external(buffer) {
	buffer.writeString("callbacks");
	let networkData_callbacks_startPos = buffer.reserveSize();
	if(networkData_callbacks) {
		var index = _objectCacheIndex.get(networkData_callbacks);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(networkData_callbacks, index = _objectCache.length);
			_objectCache.push(networkData_callbacks);
			buffer.writeInt32(-index);
			networkData_callbacks._objectIndex = index;
			buffer.writeInt32(networkData_callbacks.length);
			for(let i=0, len=networkData_callbacks.length; i<len; ++i) {
				let networkData_callbacks_item = networkData_callbacks[i]
				if(networkData_callbacks_item) {
					var index = _objectCacheIndex.get(networkData_callbacks_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(networkData_callbacks_item, index = _objectCache.length);
						_objectCache.push(networkData_callbacks_item);
						buffer.writeInt32(-index);
						buffer.writeInt32(networkData_callbacks_item._id);
						networkData_callbacks_item._objectIndex = index;
						networkData_callbacks_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(networkData_callbacks_startPos);
	buffer.writeString("");
}
function networkData_deserialize_external(buffer) {
	let callbacks_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "callbacks":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					networkData_callbacks = _objectCache[index];
				} else {
					if(!networkData_callbacks || networkData_callbacks._objectIndex != -index) networkData_callbacks = [];
					_objectCache[-index] = networkData_callbacks;
					for(let i=0, len = networkData_callbacks.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								networkData_callbacks[i] = _objectCache[index];
							} else {
								let networkData_callbacks_item = networkData_callbacks[i]
								let _id = buffer.readInt32();
								if(!networkData_callbacks_item || networkData_callbacks_item._id != _id || networkData_callbacks_item._objectIndex != -index)
									networkData_callbacks[i] = networkData_callbacks_item = new _lambdaContructors[_id]();
								networkData_callbacks_item._id = _id;
								(_objectCache[-index] = networkData_callbacks_item).deserialize_external(buffer);
							}
					}
				}
				callbacks_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!callbacks_is_set) networkData_callbacks = [];
				return;
		}
	}
}
function localStorage_get(key, $do) {
	let id = networkData_addCallback($do);
	let data = (localStorage.getItem(key) || "");
	input_handleObject(id, data);
}
async function http_get(url, code) {
	let id = networkData_addCallback(code)
	if(core_frame == 0) Platform_waitingForInitialData++
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url)).text()
		log("http.get "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data, 1)
	}
}
async function http_getDirectly(url) {
	return await (await fetch(url)).text()
}
async function http_postDirectly(url, body, code) {
	let data = await (await fetch(url, {method:"POST", body:JSON.stringify(body)})).text()
	code(data)
}
async function http_post(url, code) {
	let id = networkData_addCallback(code)
	if(core_frame == 0) Platform_waitingForInitialData++
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url, {method:"POST"})).text()
		log("http.post "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
async function http_post2(url, body, code) {
	let id = networkData_addCallback(code)
	if(core_frame == 0) Platform_waitingForInitialData++
	if(core_isPremiere && input_isCertain) {
		log("Actually fetching data: POST "+url)
		let data = await (await fetch(url, {method:"POST", body:JSON.stringify(body)})).text()
		log("http.post "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
async function http_post3(url, body) {
	if(core_isPremiere && input_isCertain) {
		(await fetch(url, {method:"POST", body:JSON.stringify(body)})).text()
	}
}
async function http_put(url, code) {
	let id = networkData_addCallback(code)
	if(core_frame == 0) Platform_waitingForInitialData++
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url, {method:"PUT"})).text()
		log("http.put "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
async function http_put2(url, body, code) {
	let id = networkData_addCallback(code)
	if(core_frame == 0) Platform_waitingForInitialData++
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url, {method:"PUT", body:JSON.stringify(body)})).text()
		log("http.put "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
async function http_delete(url, code) {
	let id = networkData_addCallback(code)
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url, {method:"DELETE"})).text()
		log("http.delete "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
async function http_delete2(url, body, code) {
	let id = networkData_addCallback(code)
	if(core_isPremiere && input_isCertain) {
		let data = await (await fetch(url, {method:"DELETE", body:JSON.stringify(body)})).text()
		log("http.delete "+url+" -> "+data?.length+" bytes")
		input_handleObject(id, data)
	}
}
function Signal(receiverId, type, sdp) {
	this.receiverId = receiverId;
	this.type = type;
	this.sdp = sdp;
}
Signal.prototype.clone = function() {
	let clone = new _Signal();
	clone.receiverId = this.receiverId;
	clone.type = this.type;
	clone.sdp = this.sdp;
	return clone;
}
function _Signal() {};
_Signal.prototype = Signal.prototype;
function IceMessage(receiverId, iceCandidate) {
	this.receiverId = receiverId;
	this.iceCandidate = iceCandidate;
}
IceMessage.prototype.clone = function() {
	let clone = new _IceMessage();
	clone.receiverId = this.receiverId;
	clone.iceCandidate = this.iceCandidate;
	return clone;
}
function _IceMessage() {};
_IceMessage.prototype = IceMessage.prototype;
function MediaDeviceInfo(deviceId, groupId, kind, label) {
	this.deviceId = deviceId;
	this.groupId = groupId;
	this.kind = kind;
	this.label = label;
}
MediaDeviceInfo.prototype.clone = function() {
	let clone = new _MediaDeviceInfo();
	clone.deviceId = this.deviceId;
	clone.groupId = this.groupId;
	clone.kind = this.kind;
	clone.label = this.label;
	return clone;
}
function _MediaDeviceInfo() {};
_MediaDeviceInfo.prototype = MediaDeviceInfo.prototype;
MediaDeviceInfo.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.deviceId);
	buffer.writeString(this.groupId);
	buffer.writeString(this.kind);
	buffer.writeString(this.label);
}
MediaDeviceInfo.prototype.deserialize_internal = function(buffer) {
	this.deviceId = buffer.readString();
	this.groupId = buffer.readString();
	this.kind = buffer.readString();
	this.label = buffer.readString();
}
MediaDeviceInfo.prototype.serialize_external = function(buffer) {
	buffer.writeString("deviceId");
	buffer.writeString(this.deviceId);
	buffer.writeString("groupId");
	buffer.writeString(this.groupId);
	buffer.writeString("kind");
	buffer.writeString(this.kind);
	buffer.writeString("label");
	buffer.writeString(this.label);
	buffer.writeString("");
}
MediaDeviceInfo.prototype.deserialize_external = function(buffer) {
	let deviceId_is_set = false, groupId_is_set = false, kind_is_set = false, label_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "deviceId":
				this.deviceId = buffer.readString();
				deviceId_is_set = true;
				break;
			case "groupId":
				this.groupId = buffer.readString();
				groupId_is_set = true;
				break;
			case "kind":
				this.kind = buffer.readString();
				kind_is_set = true;
				break;
			case "label":
				this.label = buffer.readString();
				label_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!deviceId_is_set) this.deviceId = "";
				if(!groupId_is_set) this.groupId = "";
				if(!kind_is_set) this.kind = "";
				if(!label_is_set) this.label = "";
				return;
		}
	}
}
function MediaDevices(audioInput, audioOutput, videoInput) {
	this.audioInput = audioInput;
	this.audioOutput = audioOutput;
	this.videoInput = videoInput;
}
MediaDevices.prototype.clone = function() {
	let clone = new _MediaDevices();
	clone.audioInput = this.audioInput;
	clone.audioOutput = this.audioOutput;
	clone.videoInput = this.videoInput;
	return clone;
}
function _MediaDevices() {};
_MediaDevices.prototype = MediaDevices.prototype;
MediaDevices.prototype.serialize_internal = function(buffer) {
	let audioInput = this.audioInput
	if(audioInput) {
		var index = _objectCacheIndex.get(audioInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioInput, index = _objectCache.length);
			_objectCache.push(audioInput);
			buffer.writeInt32(-index);
			audioInput._objectIndex = index;
			buffer.writeInt32(audioInput.length);
			for(let i=0, len=audioInput.length; i<len; ++i) {
				let audioInput_item = audioInput[i]
				if(audioInput_item) {
					var index = _objectCacheIndex.get(audioInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioInput_item, index = _objectCache.length);
						_objectCache.push(audioInput_item);
						buffer.writeInt32(-index);
						audioInput_item._objectIndex = index;
						audioInput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let audioOutput = this.audioOutput
	if(audioOutput) {
		var index = _objectCacheIndex.get(audioOutput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioOutput, index = _objectCache.length);
			_objectCache.push(audioOutput);
			buffer.writeInt32(-index);
			audioOutput._objectIndex = index;
			buffer.writeInt32(audioOutput.length);
			for(let i=0, len=audioOutput.length; i<len; ++i) {
				let audioOutput_item = audioOutput[i]
				if(audioOutput_item) {
					var index = _objectCacheIndex.get(audioOutput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioOutput_item, index = _objectCache.length);
						_objectCache.push(audioOutput_item);
						buffer.writeInt32(-index);
						audioOutput_item._objectIndex = index;
						audioOutput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let videoInput = this.videoInput
	if(videoInput) {
		var index = _objectCacheIndex.get(videoInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(videoInput, index = _objectCache.length);
			_objectCache.push(videoInput);
			buffer.writeInt32(-index);
			videoInput._objectIndex = index;
			buffer.writeInt32(videoInput.length);
			for(let i=0, len=videoInput.length; i<len; ++i) {
				let videoInput_item = videoInput[i]
				if(videoInput_item) {
					var index = _objectCacheIndex.get(videoInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(videoInput_item, index = _objectCache.length);
						_objectCache.push(videoInput_item);
						buffer.writeInt32(-index);
						videoInput_item._objectIndex = index;
						videoInput_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
}
MediaDevices.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this.audioInput = _objectCache[index];
	} else {
		let audioInput = this.audioInput
		if(!audioInput || audioInput._objectIndex != -index) this.audioInput = audioInput = [];
		_objectCache[-index] = audioInput;
		for(let i=0, len = audioInput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					audioInput[i] = _objectCache[index];
				} else {
					let audioInput_item = audioInput[i]
					if(!audioInput_item || audioInput_item._objectIndex != -index)
						audioInput[i] = audioInput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = audioInput_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.audioOutput = _objectCache[index];
	} else {
		let audioOutput = this.audioOutput
		if(!audioOutput || audioOutput._objectIndex != -index) this.audioOutput = audioOutput = [];
		_objectCache[-index] = audioOutput;
		for(let i=0, len = audioOutput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					audioOutput[i] = _objectCache[index];
				} else {
					let audioOutput_item = audioOutput[i]
					if(!audioOutput_item || audioOutput_item._objectIndex != -index)
						audioOutput[i] = audioOutput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = audioOutput_item).deserialize_internal(buffer);
				}
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.videoInput = _objectCache[index];
	} else {
		let videoInput = this.videoInput
		if(!videoInput || videoInput._objectIndex != -index) this.videoInput = videoInput = [];
		_objectCache[-index] = videoInput;
		for(let i=0, len = videoInput.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					videoInput[i] = _objectCache[index];
				} else {
					let videoInput_item = videoInput[i]
					if(!videoInput_item || videoInput_item._objectIndex != -index)
						videoInput[i] = videoInput_item = new _MediaDeviceInfo();
					(_objectCache[-index] = videoInput_item).deserialize_internal(buffer);
				}
		}
	}
}
MediaDevices.prototype.serialize_external = function(buffer) {
	buffer.writeString("audioInput");
	let audioInput = this.audioInput
	let audioInput_startPos = buffer.reserveSize();
	if(audioInput) {
		var index = _objectCacheIndex.get(audioInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioInput, index = _objectCache.length);
			_objectCache.push(audioInput);
			buffer.writeInt32(-index);
			audioInput._objectIndex = index;
			buffer.writeInt32(audioInput.length);
			for(let i=0, len=audioInput.length; i<len; ++i) {
				let audioInput_item = audioInput[i]
				if(audioInput_item) {
					var index = _objectCacheIndex.get(audioInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioInput_item, index = _objectCache.length);
						_objectCache.push(audioInput_item);
						buffer.writeInt32(-index);
						audioInput_item._objectIndex = index;
						audioInput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(audioInput_startPos);
	buffer.writeString("audioOutput");
	let audioOutput = this.audioOutput
	let audioOutput_startPos = buffer.reserveSize();
	if(audioOutput) {
		var index = _objectCacheIndex.get(audioOutput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioOutput, index = _objectCache.length);
			_objectCache.push(audioOutput);
			buffer.writeInt32(-index);
			audioOutput._objectIndex = index;
			buffer.writeInt32(audioOutput.length);
			for(let i=0, len=audioOutput.length; i<len; ++i) {
				let audioOutput_item = audioOutput[i]
				if(audioOutput_item) {
					var index = _objectCacheIndex.get(audioOutput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(audioOutput_item, index = _objectCache.length);
						_objectCache.push(audioOutput_item);
						buffer.writeInt32(-index);
						audioOutput_item._objectIndex = index;
						audioOutput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(audioOutput_startPos);
	buffer.writeString("videoInput");
	let videoInput = this.videoInput
	let videoInput_startPos = buffer.reserveSize();
	if(videoInput) {
		var index = _objectCacheIndex.get(videoInput);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(videoInput, index = _objectCache.length);
			_objectCache.push(videoInput);
			buffer.writeInt32(-index);
			videoInput._objectIndex = index;
			buffer.writeInt32(videoInput.length);
			for(let i=0, len=videoInput.length; i<len; ++i) {
				let videoInput_item = videoInput[i]
				if(videoInput_item) {
					var index = _objectCacheIndex.get(videoInput_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(videoInput_item, index = _objectCache.length);
						_objectCache.push(videoInput_item);
						buffer.writeInt32(-index);
						videoInput_item._objectIndex = index;
						videoInput_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(videoInput_startPos);
	buffer.writeString("");
}
MediaDevices.prototype.deserialize_external = function(buffer) {
	let audioInput_is_set = false, audioOutput_is_set = false, videoInput_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "audioInput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.audioInput = _objectCache[index];
				} else {
					let audioInput = this.audioInput
					if(!audioInput || audioInput._objectIndex != -index) this.audioInput = audioInput = [];
					_objectCache[-index] = audioInput;
					for(let i=0, len = audioInput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								audioInput[i] = _objectCache[index];
							} else {
								let audioInput_item = audioInput[i]
								if(!audioInput_item || audioInput_item._objectIndex != -index)
									audioInput[i] = audioInput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = audioInput_item).deserialize_external(buffer);
							}
					}
				}
				audioInput_is_set = true;
				break;
			case "audioOutput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.audioOutput = _objectCache[index];
				} else {
					let audioOutput = this.audioOutput
					if(!audioOutput || audioOutput._objectIndex != -index) this.audioOutput = audioOutput = [];
					_objectCache[-index] = audioOutput;
					for(let i=0, len = audioOutput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								audioOutput[i] = _objectCache[index];
							} else {
								let audioOutput_item = audioOutput[i]
								if(!audioOutput_item || audioOutput_item._objectIndex != -index)
									audioOutput[i] = audioOutput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = audioOutput_item).deserialize_external(buffer);
							}
					}
				}
				audioOutput_is_set = true;
				break;
			case "videoInput":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.videoInput = _objectCache[index];
				} else {
					let videoInput = this.videoInput
					if(!videoInput || videoInput._objectIndex != -index) this.videoInput = videoInput = [];
					_objectCache[-index] = videoInput;
					for(let i=0, len = videoInput.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								videoInput[i] = _objectCache[index];
							} else {
								let videoInput_item = videoInput[i]
								if(!videoInput_item || videoInput_item._objectIndex != -index)
									videoInput[i] = videoInput_item = new _MediaDeviceInfo();
								(_objectCache[-index] = videoInput_item).deserialize_external(buffer);
							}
					}
				}
				videoInput_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!audioInput_is_set) this.audioInput = [];
				if(!audioOutput_is_set) this.audioOutput = [];
				if(!videoInput_is_set) this.videoInput = [];
				return;
		}
	}
}
var PeerNetwork_relayMode;
var PeerNetwork_enableVideo;
var PeerNetwork_enableAudio;
var PeerNetwork_error;
var PeerNetwork_sendBuffer;
var PeerNetwork_devices;
var PeerNetwork_videoInputId;
var PeerNetwork_audioInputId;
var PeerNetwork_audioOutputId;
var PeerNetwork_snapshotBuffer;
var PeerNetwork_sendStateQueue;
var PeerNetwork_requestedState;
var PeerNetwork_stateTimeout;
function PeerNetwork_init() {
	PeerNetwork_relayMode = 1/*Auto*/;
	PeerNetwork_enableVideo = true;
	PeerNetwork_enableAudio = true;
	PeerNetwork_error = "";
	PeerNetwork_sendBuffer = new Buffer(null, 1024, 0, 0);
	PeerNetwork_devices = new MediaDevices([], [], []);
	PeerNetwork_videoInputId = "";
	PeerNetwork_audioInputId = "";
	PeerNetwork_audioOutputId = "";
	PeerNetwork_snapshotBuffer = new Buffer(null, 1024, 0, 0);
	PeerNetwork_sendStateQueue = [];
	PeerNetwork_requestedState = false;
	PeerNetwork_stateTimeout = 0;
}
function PeerNetwork_setupPeerConnection(user, offerByMe) {
	let options = {
		
		iceTransportPolicy: PeerNetwork_relayMode == 2 ? "relay" : "all",
		iceServers: [],
		
	}
	if(PeerNetwork_relayMode > 0) {
		
		
		
		
		
		
		
		
		
		
		
		
		
		options.iceServers.push({
			urls: "turn:85.214.133.53:39571",
			username: "play-user-9q2gy75kmlp4qn7tb86pogsmtyp7qqo0n5-strato-v30",
			credential: "8q76nby32odjamuzbexi6eb2f1k9gc3my99o-strato-v30"
		});
		
		
		
		
		
		
	}
	options.iceServers.push({
		urls: [
			"stun:stun1.l.google.com:19302",
			"stun:stun2.l.google.com:19302",
		],
	});
	let peerConnection = new RTCPeerConnection(options);
	let connectionId = user.connectionId
	core_log("<"+user.id+"> setupPeerConnection connectionId:"+connectionId+" relayMode:"+PeerNetwork_relayMode)
	
	
	peerConnection.oniceconnectionstatechange = e => {
		core_log("<"+user.id+"> oniceconnectionstatechange " + peerConnection.iceConnectionState)
		if(peerConnection.iceConnectionState == "disconnected") {
			
			setTimeout(() => statistics_manuallyTriggerSend(-5, /*clear*/false), 7000);
		}
	}
	peerConnection.onicecandidate = async event => {
		if (event.candidate)
			ServerNetwork_sendIce(user.id, JSON.stringify(event.candidate))
		else
			core_log("<"+user.id+"> Final ice candidate");
	}
	user.peerConnection = peerConnection
	user.offerByMe = offerByMe
	return peerConnection
}
function PeerNetwork_stopRecreatingDataChannel(user) {
	if(user.recreateDataChannelInterval) {
		core_log("<"+user.id+"> stopRecreatingDataChannel connectionId:"+user.connectionId)
		clearInterval(user.recreateDataChannelInterval)
		user.recreateDataChannelInterval = null
	}
}
function PeerNetwork_setupDataChannel(user) {
	
	
	core_log("<"+user.id+"> setupDataChannel: Creating data channel")
	let dataChannel = user.peerConnection.createDataChannel("channel")
	dataChannel.binaryType = "arraybuffer"
	dataChannel.onopen = e => {
		user.dataChannel = dataChannel
		core_log("<"+user.id+"> setupDataChannel: Open data channel")
		PeerNetwork_stopRecreatingDataChannel(user)
		PeerNetwork_logConnectionType(user)
		if(!PeerNetwork_requestedState) {
			PeerNetwork_requestState(user)
			PeerNetwork_requestedState = true
		}
	}
	dataChannel.onclosing = e => core_log("<"+user.id+"> Data channel closing")
	dataChannel.onclose = e => {
		core_log("<"+user.id+"> setupDataChannel: Close data channel, recreateInterval:"+user.recreateDataChannelInterval)
		user.dataChannel = null
		if(!user.recreateDataChannelInterval) {
			core_log("<"+user.id+"> setupDataChannel: Start recreating interval")
			user.recreateDataChannelInterval = setInterval(() => PeerNetwork_setupDataChannel(user), 2000)
		}
		
		setTimeout(() => statistics_manuallyTriggerSend(-4, /*clear*/false), 7000);
	}
	dataChannel.onerror = e => core_log("<"+user.id+"> DataChannel "+user.id+"error "+e)
	dataChannel.onmessage = e => PeerNetwork_onMessage(user, new Buffer(e.data, 0, 0, 0))
}
async function PeerNetwork_createOffer(user) {
	try {
		PeerNetwork_setupPeerConnection(user, /*offerByMe*/true)
		PeerNetwork_setupRemoteMedia(user)
		PeerNetwork_stopRecreatingDataChannel(user)
		PeerNetwork_setupDataChannel(user)
		
		
		let peerConnection = user.peerConnection
		let offer = await peerConnection.createOffer();
		await peerConnection.setLocalDescription(offer);
		ServerNetwork_sendSignal(user.id, "offer", peerConnection.localDescription.sdp)
		user.receivedAnswer = false
		core_log("<"+user.id+"> Sent offer to "+user.id+", waiting for answer.");
	}
	catch(e) {
		console.error(e);
		core_log(e.stack);
	}
}
async function PeerNetwork_setBitrate(user, scaleResolutionDownBy, maxBitrate) {
	let senderList = user.peerConnection.getSenders();
	for(let sender of senderList) {
		const params = sender.getParameters();
		console.log(params);
		if (!params.encodings) {
			params.encodings = [{ }];
		}
		params.encodings[0].scaleResolutionDownBy = scaleResolutionDownBy;
		params.encodings[0].maxBitrate = maxBitrate;
		
		await sender.setParameters(params);
	}
}
async function PeerNetwork_onReceivedOffer(user, sdp) {
	try {
		core_log("<"+user.id+"> Received offer, senting answer");
		PeerNetwork_setupPeerConnection(user, /*offerByMe*/false)
		PeerNetwork_setupRemoteMedia(user)
		
		
		
		PeerNetwork_stopRecreatingDataChannel(user)
		
		
		user.peerConnection.addEventListener("datachannel", e => {
			core_log("<"+user.id+"> Data channel received")
			let dataChannel = e.channel
			dataChannel.binaryType = "arraybuffer"
			user.dataChannel = dataChannel
			dataChannel.onopen = e => {
				core_log("<"+user.id+"> Data channel opened")
				user.dataChannel = dataChannel
				PeerNetwork_logConnectionType(user)
			}
			dataChannel.onclosing = e => {
				core_log("<"+user.id+"> Data channel closing")
				user.dataChannel = null
			}
			dataChannel.onclose = e => core_log("<"+user.id+"> Data channel close "+e)
			dataChannel.onerror = e => core_log("<"+user.id+"> Data channel error "+e)
			dataChannel.onmessage = e => PeerNetwork_onMessage(user, new Buffer(e.data, 0, 0, 0))
		})
					
		
		let peerConnection = user.peerConnection
		await peerConnection.setRemoteDescription(new RTCSessionDescription({type: "offer", sdp}));
		let answer = await peerConnection.createAnswer();
		await peerConnection.setLocalDescription(answer);
		ServerNetwork_sendSignal(user.id, "answer", peerConnection.localDescription.sdp)
	}
	catch(e) {
		console.error(e)
		core_log(e.stack);
	}
}
function PeerNetwork_sendInputs(inputFrame) {
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user?.dataChannel != null)) {
			let inputs = input_localUser.inputs;
			let length = inputs.writePos - user.inputsSentPos;
			PeerNetwork_sendBuffer.reset();
			PeerNetwork_sendBuffer.writeInt8(6/*Tick*/);
			PeerNetwork_sendBuffer.writeInt(inputFrame);
			PeerNetwork_sendBuffer.writeInt(user.inputsSentPos);
			PeerNetwork_sendBuffer.writeBuffer2(inputs, user.inputsSentPos, length);
			PeerNetwork_sendBuffer.writeInt(core_lastChecksumFrame);
			PeerNetwork_sendBuffer.writeFloat64(core_checksums.get(core_lastChecksumFrame) || 0);
			core_tickMessageSize = PeerNetwork_send(user, PeerNetwork_sendBuffer);
			user.inputsSentPos = inputs.writePos;
			if(core_logging) {
				core_sentLog += " <"+user.id?.toString()+"> #"+inputFrame?.toString()+" "+user.inputsSentPos?.toString()+"->"+inputs.writePos?.toString()+" "+inputs.toRangeString(user.inputsSentPos, inputs.writePos)+" ("+core_tickMessageSize?.toString()+" bytes)";
			}
		}
	}}
}
function PeerNetwork_send(user, buffer) {
	try {
		let data = buffer.toByteArray()
		user.dataChannel.send(data)
		return data.byteLength
	} catch(e) {
		console.error(e)
		core_log(e.stack)
		return 0
	}
}
function PeerNetwork_onMessage(user, buffer) {
	let type = buffer.readInt8();
	if(type == 6/*Tick*/) {
		PeerNetwork_onTick(user, buffer);
	} else {
		if(type == 9/*RequestState*/) {
			PeerNetwork_onRequestState(user, buffer);
		} else {
			if(type == 10/*State*/) {
				PeerNetwork_onState(user, buffer);
			} else {
				if(type == 2/*Ping*/) {
					PeerNetwork_onPing(user, buffer);
				} else {
					if(type == 3/*Pong*/) {
						PeerNetwork_onPong(user, buffer);
					}
				}
			}
		}
	}
}
function PeerNetwork_onTick(sender, buffer) {
	let inputFrame = buffer.readInt();
	if(inputFrame >= sender.inputFrame) {
		sender.inputFrame = inputFrame;
		let prevWritePos = buffer.readInt();
		buffer.readBuffer(sender.inputs, prevWritePos);
		let checksumFor = buffer.readInt();
		let checksum = buffer.readFloat64();
		if(core_logging) {
			core_checksumLog += " <"+sender.id?.toString()+"> #"+checksumFor?.toString()+" "+checksum?.toString();
		}
		let myChecksum = core_checksums.get(checksumFor);
		if(!myChecksum) {
			core_checksums.set(checksumFor, checksum);
		} else {
			if(!(Math.abs(myChecksum - checksum) < 0.00001)) {
				core_onWrongChecksum(checksumFor, myChecksum, checksum);
			}
		}
		if(core_logging) {
			core_receivedLog += " ["+Date.now()?.toString()+"] <"+sender.id?.toString()+"> #"+inputFrame?.toString()+" "+prevWritePos?.toString()+"->"+sender.inputs.writePos?.toString()+" "+sender.inputs.toRangeString(prevWritePos, sender.inputs.writePos);
		}
	} else {
		if(core_logging) {
			core_receivedLog += " ["+Date.now()?.toString()+"] <"+sender.id?.toString()+"> (ignoring #"+inputFrame?.toString()+")";
		}
	}
}
async function PeerNetwork_onReceivedAnswer(user, sdp) {
	await user.peerConnection.setRemoteDescription(new RTCSessionDescription({type: "answer", sdp}));
	user.receivedAnswer = true
	core_log("<"+user.id+"> Received answer from "+user.id+".");
}
async function PeerNetwork_onIce(user, candidate) {
	try {
		await user.peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(candidate)));
	} catch(e) {
		core_log("<"+user.id+"> onIce failed " + e.message)
		core_log(e.stack);
	}
}
async function PeerNetwork_logConnectionType(user) {
	setTimeout(async () => {
		let stats = await user.peerConnection.getStats()
		let candidatePairs = [...stats.values()].filter(s => s.type == "candidate-pair" && s.state == "succeeded")
		let candidatePair = candidatePairs.find(a => a.selected) || candidatePairs[0]
		if(candidatePair) {
			let candidate = stats.get(candidatePair.localCandidateId);
			let ip = candidate.ip || candidate.address
			user.connectionType = candidate.candidateType + " " + ip
			core_log("<"+user.id+"> #################### connection to "+user.id+": "+user.connectionType)
		} else {
			core_log("<"+user.id+"> #################### connection: no candidate pair for "+user.id)
			window.stats = [...stats.values()]
			console.log(window.stats)
			try { core_log(JSON.stringify(window.stats)) }
			catch{ }
		}
	}, 10000)
}
function PeerNetwork_ping() {
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user?.dataChannel != null)) {
			PeerNetwork_sendBuffer.reset();
			PeerNetwork_sendBuffer.writeInt8(2/*Ping*/);
			PeerNetwork_sendBuffer.writeFloat64(Date.now());
			PeerNetwork_send(user, PeerNetwork_sendBuffer);
		}
	}}
}
function PeerNetwork_onPing(user, buffer) {
	let pingTime = buffer.readFloat64();
	PeerNetwork_sendBuffer.reset();
	PeerNetwork_sendBuffer.writeInt8(3/*Pong*/);
	PeerNetwork_sendBuffer.writeFloat64(pingTime);
	PeerNetwork_send(user, PeerNetwork_sendBuffer);
}
function PeerNetwork_onPong(user, buffer) {
	let now = Date.now();
	let pingTime = buffer.readFloat64();
	let pingPongTime = now - pingTime;
	let player = input_players.find(a => a.id == user.id);
	if((player != null)) {
		statistics_add2(player.index, pingPongTime, player.color, 2);
	}
}
function PeerNetwork_sendChecksum(checksumFor, checksum) {
	PeerNetwork_sendBuffer.reset();
	PeerNetwork_sendBuffer.writeInt8(11/*Checksum*/);
	PeerNetwork_sendBuffer.writeInt(checksumFor);
	PeerNetwork_sendBuffer.writeFloat64(checksum);
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let user = _subject[i]; {
		if((user?.dataChannel != null)) {
			PeerNetwork_send(user, PeerNetwork_sendBuffer);
		}
	}}
}
function PeerNetwork_onChecksum(user, buffer) {
	let checksumFor = buffer.readInt();
	let checksum = buffer.readFloat64();
	if(core_logging) {
		core_checksumLog += " <"+user.id?.toString()+"> #"+checksumFor?.toString()+" "+checksum?.toString();
	}
	let myChecksum = core_checksums.get(checksumFor);
	if(!myChecksum) {
		core_checksums.set(checksumFor, checksum);
	} else {
		if(!(Math.abs(myChecksum - checksum) < 0.00001)) {
			core_onWrongChecksum(checksumFor, myChecksum, checksum);
		}
	}
}
async function PeerNetwork_setupLocalMedia(enableVideo, enableAudio) {
	core_log("setupLocalMedia: start")
	PeerNetwork_enableVideo = enableVideo
	PeerNetwork_enableAudio = enableAudio
	if(!enableVideo && !enableAudio) return
		
	try {
		
		input_localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
			video: {width: 500, height: 375},
			audio: enableAudio
		});
		core_log("setupLocalMedia: getUserMedia done")
		
		
		let devices = await navigator.mediaDevices.enumerateDevices();
		core_log("setupLocalMedia: enumerateDevices done")
		
		for(let device of devices) {
			switch(device.kind) {
				case "videoinput": PeerNetwork_devices.videoInput.push(device); break;
				case "audioinput": PeerNetwork_devices.audioInput.push(device); break;
				case "audiooutput": PeerNetwork_devices.audioOutput.push(device); break;
			}
		}
		PeerNetwork_videoInputId = input_localUser.mediaStream.getVideoTracks()[0]?.getSettings().deviceId || PeerNetwork_devices.videoInput[0]?.deviceId
		PeerNetwork_audioInputId = input_localUser.mediaStream.getAudioTracks()[0]?.getSettings().deviceId || PeerNetwork_devices.audioInput[0]?.deviceId
		PeerNetwork_audioOutputId = PeerNetwork_devices.audioInput[0]?.deviceId
		core_log("setupLocalMedia: success")
		
	} catch(error) {
		core_log(error.message)
		if(error.name == "NotAllowedError") {
			PeerNetwork_error = "To play with friends over a video call, you need to allow access to your webcam."
		} else {
			PeerNetwork_error = "Can't access webcam. Please make sure it's not used by another application."
		}
		core_errorMessage = error.message
		throw error
	}
}
async function PeerNetwork_setVideoInput(videoInputId) {
	if(PeerNetwork_videoInputId == videoInputId) return;
	PeerNetwork_videoInputId = videoInputId;
	
	
	input_localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
		audio: {deviceId: PeerNetwork_audioInputId},
		video: {deviceId: PeerNetwork_videoInputId},
	});
	
	
	for(let el of input_localUser.videoElements) {
		el.srcObject = input_localUser.mediaStream;
	}
	const [videoTrack] = input_localUser.mediaStream.getVideoTracks();
	for(let user of input_internalUsers) {
		if(user?.peerConnection) {
			const sender = user.peerConnection.getSenders().find((s) => s.track.kind === videoTrack.kind);
			sender.replaceTrack(videoTrack);
		}
	}
}
async function PeerNetwork_setAudioInput(audioInputId) {
	if(PeerNetwork_audioInputId == audioInputId) return;
	PeerNetwork_audioInputId = audioInputId;
	
	
	input_localUser.mediaStream = await navigator.mediaDevices.getUserMedia({
		audio: {deviceId: PeerNetwork_audioInputId},
		video: {deviceId: PeerNetwork_videoInputId},
	});
	
	
	const [audioTrack] = input_localUser.mediaStream.getAudioTracks();
	for(let user of input_internalUsers) {
		if(user?.peerConnection) {
			const sender = user.peerConnection.getSenders().find((s) => s.track.kind === audioTrack.kind);
			sender.replaceTrack(audioTrack);
		}
	}
}
function PeerNetwork_setAudioOutput(audioOutputId) {
	PeerNetwork_audioOutputId = audioOutputId;
	
	
	for(let user of input_internalUsers) {
		if(user?.audioElement && user.audioElement.setSinkId) {
			user.audioElement.setSinkId(PeerNetwork_audioOutputId);
		}
	}
	audio_reload();
}
function PeerNetwork_setupRemoteMedia(user) {
	
	for(let videoElement of user.videoElements)
		videoElement.remove()
	user.videoElements.length = 0
	
	if(!PeerNetwork_enableVideo && !PeerNetwork_enableAudio) return
		
	
	for(let track of input_localUser.mediaStream.getTracks())
		user.peerConnection.addTrack(track, input_localUser.mediaStream);
	
	
	user.mediaStream = new MediaStream();
	
	
	let audioElement = user.audioElement = document.createElement("audio")
	audioElement.srcObject = user.mediaStream
	if(audioElement.setSinkId) audioElement.setSinkId(PeerNetwork_audioOutputId);
	document.body.appendChild(audioElement);
	
	
	user.peerConnection.addEventListener("track", event => {
		event.streams[0].getTracks().forEach(track => {
			user.mediaStream.addTrack(track);
		});
	});
}
function PeerNetwork_createVideoElement(stream, local) {
	let el = document.createElement("video")
	el.style = "border-radius: 500px; object-fit: cover; position:absolute; top:0px; left:0px; z-index:10000; visibility:hidden; "+(local ? "transform: scaleX(-1)" : "")
	el.autoplay = true
	el.playsinline = true
	el.controls = false
	el.muted = true
	el.srcObject = stream
	document.body.appendChild(el)
	return el
}
function PeerNetwork_removeVideoElement(videoElement) {
	videoElement.remove()
}
function PeerNetwork_updateVideoElement(videoElement, x, y, sizeX, sizeY, radius) {
	videoElement.style.left = (x-sizeX/2)+"px"
	videoElement.style.top = (y-sizeY/2)+"px"
	videoElement.style.width = sizeX+"px"
	videoElement.style.height = sizeY+"px"
	videoElement.style.visibility = "visible"
	videoElement.style.borderRadius = radius+"px"
}
function PeerNetwork_setAudioMuted(audioElement, muted) {
	if(audioElement) audioElement.muted = muted
}
function PeerNetwork_makePrimiaryUserIfStateIsNotReceived() {
	PeerNetwork_requestedState = false;
	PeerNetwork_stateTimeout = setTimeout(() => {
		if(input_internalUsers.some(a => a.receivedAnswer)) {
			core_log("No state after 25s, but we received answers -> Alert the user to make sure WebRTC connections aren't blocked.");
			alert("Could not connect. Please make sure WebRTC connections aren't block by your router, firewall or a browser extension. If you have a VPN browser extension installed, please check your settings and make sure WebRTC connections aren't blocked.");
		} else {
			core_log("No state after 25s -> Make primary user");
			PeerNetwork_makePrimaryUser();
		}
	}, (25*1000));
}
function PeerNetwork_makePrimaryUser() {
	let frame = Math.floor((Date.now() - core_startTime) / core_targetFrameTime) + 3;
	core_startConnected(frame);
}
function PeerNetwork_requestState(from) {
	PeerNetwork_sendBuffer.reset();
	PeerNetwork_sendBuffer.writeInt8(9/*RequestState*/);
	PeerNetwork_send(from, PeerNetwork_sendBuffer);
}
function PeerNetwork_onRequestState(sender, buffer) {
	core_log(("Received state request from "+sender.id?.toString()));
	PeerNetwork_sendStateQueue.push(sender.id);
	if(core_mode == 3/*Connected*/) {
		PeerNetwork_processSendStateQueue();
	}
}
function PeerNetwork_processSendStateQueue() {
	if(PeerNetwork_sendStateQueue.length > 0) {
		PeerNetwork_snapshotBuffer.reset();
		serialize_internal(PeerNetwork_snapshotBuffer);
		for(let _subject=PeerNetwork_sendStateQueue, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
			let user = input_internalUsers.get(it);
			if((user?.dataChannel != null)) {
				PeerNetwork_sendState(user, PeerNetwork_snapshotBuffer);
				PeerNetwork_sendStateQueue.splice(i, 1);
			}
		}}
	}
}
function PeerNetwork_sendState(to, buffer) {
	core_log(("Sending state to "+to.id?.toString()));
	let localUser = input_localUser;
	PeerNetwork_sendBuffer.reset();
	PeerNetwork_sendBuffer.writeInt8(10/*State*/);
	PeerNetwork_sendBuffer.writeInt32(core_frame - 1);
	let userCount = input_internalUsers.count(a => a != null);
	PeerNetwork_sendBuffer.writeInt32(userCount);
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			PeerNetwork_sendBuffer.writeInt32(it.id);
			PeerNetwork_sendBuffer.writeInt32(it.inputs.readPos);
			PeerNetwork_sendBuffer.writeBool(it.active);
		}
	}}
	to.inputsSentPos = localUser.inputs.readPos;
	PeerNetwork_sendBuffer.writeBuffer(buffer);
	PeerNetwork_send(to, PeerNetwork_sendBuffer);
}
function PeerNetwork_onState(c, buffer) {
	clearTimeout(PeerNetwork_stateTimeout);
	if(core_mode == 3/*Connected*/) {
		core_log(("Ignoring received state from "+c.id?.toString()+" because we are already connected"));
		return;
	}
	core_log(("Received state from "+c.id?.toString()));
	let frame = buffer.readInt32();
	let userCount = buffer.readInt32();
	for(let i=0; i<userCount; ++i) {
		let id = buffer.readInt32();
		let readPos = buffer.readInt32();
		let active = buffer.readBool();
		let user = input_internalUsers.get(id);
		if((user != null)) {
			user.inputFrame = frame;
			user.inputs.readPos = user.inputs.writePos = readPos;
			user.active = active;
		}
	}
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null)) {
			it.inputsSentPos = input_localUser.inputs.writePos;
		}
	}}
	PeerNetwork_snapshotBuffer.reset();
	buffer.readBuffer(PeerNetwork_snapshotBuffer, 0);
	deserialize_internal(PeerNetwork_snapshotBuffer);
	math_recreateRandomValues();
	core_startConnected(frame + 1);
}
var Physics_world;
var Physics_scale;
function Physics_init() {
	Physics_world = null;
	Physics_scale = 100;
}
function Physics_start() {
	if(window.world) _b2World_Delete(world)
	window.world = new b2World(new b2Vec2(0, 10))
}
function Physics_step() {
	if(window.world) window.world.Step(1/core_targetFps, 8, 3)
}
function Physics_destroy(body) {
	world.DestroyBody(body.body)
}
function Physics_createCircle(pos, radius, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics_scale, pos.y/Physics_scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2CircleShape
	shape.radius = radius/Physics_scale
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
function Physics_createRectangle(pos, size, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics_scale, pos.y/Physics_scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2PolygonShape
	shape.SetAsBoxXY(size.x/Physics_scale/2, size.y/Physics_scale/2)
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
function Physics_createPolygon(pos, vertices, closed, type) {
	let bodyDef = new b2BodyDef()
	bodyDef.type = type
	bodyDef.position = new b2Vec2(pos.x/Physics_scale, pos.y/Physics_scale)
	let body = window.world.CreateBody(bodyDef)
	let shape = new b2ChainShape();
	for(let v of vertices)
		shape.vertices.push(new b2Vec2(v.x/Physics_scale, v.y/Physics_scale));
	if(closed) shape.CreateLoop();
	body.CreateFixtureFromShape(shape, type == 2 ? 1 : 0)
	return new PhysicsBody(body)
}
function PhysicsBody(body) {
	this.body = body;
}
PhysicsBody.prototype.position = function() {
	let pos = this.body.GetPosition()
	return new Vector2(pos.x*Physics_scale, pos.y*Physics_scale, null)
}
PhysicsBody.prototype.clone = function() {
	let clone = new _PhysicsBody();
	clone.body = this.body;
	return clone;
}
function _PhysicsBody() {};
_PhysicsBody.prototype = PhysicsBody.prototype;
var ServerNetwork_socket;
var ServerNetwork_sendBuffer;
var ServerNetwork_nextConnectionId;
var ServerNetwork_nextPingTime;
var ServerNetwork_fastestPingPongTime;
var ServerNetwork_lastPingPongTime;
var ServerNetwork_pongCount;
var ServerNetwork_calculatedStartTimes;
var ServerNetwork_referenceStartTime;
var ServerNetwork_pingPongTimes;
var ServerNetwork_inputsSentPos;
function ServerNetwork_init() {
	ServerNetwork_socket = null;
	ServerNetwork_sendBuffer = new Buffer(null, 1024, 0, 0);
	ServerNetwork_nextConnectionId = 1;
	ServerNetwork_nextPingTime = 0.0;
	ServerNetwork_fastestPingPongTime = int_maxValue;
	ServerNetwork_lastPingPongTime = 0.0;
	ServerNetwork_pongCount = 0;
	ServerNetwork_calculatedStartTimes = [];
	ServerNetwork_referenceStartTime = 0.0;
	ServerNetwork_pingPongTimes = [];
	ServerNetwork_inputsSentPos = 0;
}
function ServerNetwork_setup() {
	let startTime = Date.now()
	let socket
	if(location.href.indexOf("localhost") != -1) socket = new WebSocket("ws://localhost:3112");
	else socket = new WebSocket("wss://"+location.host+":3112");
	socket.binaryType = "arraybuffer";
	socket.onopen = function() {
		core_log("Websocket open");
		ServerNetwork_socket = socket
		ServerNetwork_onConnectedToServer();
	}
	socket.onmessage = function(event) {
		ServerNetwork_onMessageFromServer(new Buffer(event.data, 0, 0, 0));
	}
	socket.onclose = function(ev) {
		core_log("Websocket closed "+ev.code+" "+ev.reason)
		ServerNetwork_socket = null
		if(Date.now() - startTime < 30000) {
			location.href = "/{core_gameId}/{core_roomId}"
		}
	}
	socket.onerror = error => {
		core_error = "Can't connect to server."
		core_errorMessage = error.message
		core_log(error.message)
	}
}
function ServerNetwork_getOrCreateUser(id) {
	return input_internalUsers.get(id) || (input_internalUsers.set(id, new InternalUser(id, false, 0, 0, true, false, -1, 0, [], new Buffer(null, 1024, 0, 0), null, [], null, 0, null, null, null, "", false, false, 0)));
}
function ServerNetwork_onConnectedToServer() {
	if(input_localUser.id == -1 && !Platform_isStaging) {
		let roomInfo = Platform_getLocalStorageObject("room" + core_roomId);
		input_localUser.id = ((roomInfo != null) && roomInfo.time > Date.now() - 3600000 * 6 ? roomInfo.userId : -1);
		core_log("roomInfo: "+(object_stringify(roomInfo, 3) || "null")+", input.localUser.id: "+input_localUser.id?.toString());
	}
	core_log(("onConnectedToServer as "+input_localUser.id?.toString()+" "+core_roomId?.toString()));
	ServerNetwork_sendJoinMessage(core_roomString, input_localUser.id, version);
}
function ServerNetwork_bufferedAmount() {
	return ServerNetwork_socket.bufferedAmount 
}
function ServerNetwork_send(buffer) {
	try {
		let data = buffer.toByteArray()
		ServerNetwork_socket.send(data)
		return data.byteLength
	} catch(e) { 
		core_log(e)
		return 0
	}
}
function ServerNetwork_onMessageFromServer(buffer) {
	let type = buffer.readInt8();
	if(type == 1/*JoinResponse*/) {
		ServerNetwork_onJoinResponse(buffer);
	} else {
		if(type == 3/*Pong*/) {
			ServerNetwork_onPong(buffer);
		} else {
			if(type == 4/*Signal*/) {
				ServerNetwork_onSignal(buffer);
			} else {
				if(type == 5/*Ice*/) {
					ServerNetwork_onIce(buffer);
				} else {
					if(type == 6/*Tick*/) {
						ServerNetwork_onTick(buffer);
					} else {
						if(type == 7/*Switch*/) {
							ServerNetwork_onSwitch(buffer);
						} else {
							if(type == 8/*Reload*/) {
								ServerNetwork_onReload(buffer);
							}
						}
					}
				}
			}
		}
	}
}
function ServerNetwork_sendJoinMessage(roomId, userId, version) {
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(0/*Join*/);
	ServerNetwork_sendBuffer.writeString(roomId);
	ServerNetwork_sendBuffer.writeInt16(userId);
	ServerNetwork_sendBuffer.writeInt16(version);
	ServerNetwork_send(ServerNetwork_sendBuffer);
}
function ServerNetwork_onJoinResponse(buffer) {
	let roomId = buffer.readInt32();
	let userId = buffer.readInt32();
	let version = buffer.readInt32();
	let seed = buffer.readString();
	let serverStartTime = buffer.readFloat64();
	let userCount = buffer.readInt16();
	for(let i=0; i<userCount; ++i) {
		let id = buffer.readInt32();
		let user = null;
		if(id == userId) {
			user = input_localUser;
		} else {
			user = new InternalUser(0, false, ServerNetwork_nextConnectionId++, 0, false, false, -1, 0, [], new Buffer(null, 1024, 0, 0), null, [], null, 0, null, null, null, "", true, false, 0);
		}
		user.id = id;
		input_internalUsers.set(id, user);
		buffer.readBuffer(user.inputs, 0);
	}
	if(roomId != core_roomId) {
		core_log(("Received room id "+roomId?.toString()));
		if(core_isPremiere) history.pushState(null, "", "/"+core_gameId+"/"+roomId?.toString());;
		core_roomId = roomId;
	}
	if(version != version) {
		alert("You are using an old version of this application. Please refresh your browser.");
	}
	ServerNetwork_inputsSentPos = input_localUser.inputs.writePos;
	input_localUser.id = userId;
	math_setRandomSeed(seed);
	core_serverStartTime = serverStartTime;
	core_mode = 1/*Ping*/;
	for(let i=0, _subject=input_internalUsers, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		if((it != null) && !it.local) {
			PeerNetwork_createOffer(it);
		}
	}}
	core_storeUserId();
	if(userCount <= 1) {
		core_log("We are the only user so far -> Make primary user");
		PeerNetwork_makePrimaryUser();
	} else {
		PeerNetwork_makePrimiaryUserIfStateIsNotReceived();
	}
	core_log(("Joining room "+roomId?.toString()+" as user "+userId?.toString()));
	if(userCount <= 1 && !Platform_isStaging) {
		http_getDirectly(""+Platform_protocolAndHost()+":3114/sendGamedayNotification/"+core_gameId+"/"+core_roomId?.toString()+"/hasStarted");
	}
}
function ServerNetwork_ping() {
	let now = Date.now();
	if((core_mode == 1/*Ping*/ || core_mode == 3/*Connected*/) && now >= ServerNetwork_nextPingTime) {
		ServerNetwork_sendBuffer.reset();
		ServerNetwork_sendBuffer.writeInt8(2/*Ping*/);
		ServerNetwork_sendBuffer.writeFloat64(now);
		ServerNetwork_send(ServerNetwork_sendBuffer);
		ServerNetwork_nextPingTime = now + ((core_mode == 1/*Ping*/ ? 200 : (ServerNetwork_pongCount < 20 ? 1000 : 5000)));
	}
}
function ServerNetwork_onPong(buffer) {
	let now = Date.now();
	let timeSinceStart = buffer.readFloat64();
	let pingTime = buffer.readFloat64();
	let pingPongTime = now - pingTime;
	let calculatedStartTime = now - pingPongTime / 2 - timeSinceStart;
	let deltaFromAverage = Math.round(calculatedStartTime - core_startTime);
	statistics_serverPings.push(pingPongTime);
	ServerNetwork_pongCount++;
	ServerNetwork_lastPingPongTime = pingPongTime;
	ServerNetwork_pingPongTimes.push(pingPongTime)
	if(ServerNetwork_pingPongTimes.length > 30) ServerNetwork_pingPongTimes.splice(0, 1);
	let pingPongTimesAverage = ServerNetwork_pingPongTimes.average();
	if(pingPongTime > 400 || (ServerNetwork_pingPongTimes.length >= 15 && pingPongTime > pingPongTimesAverage * 2)) {
		core_log("ignoring ping-pong"+", pingPongTimes.length: "+ServerNetwork_pingPongTimes.length?.toString()+", pingPongTimesAverage: "+pingPongTimesAverage?.toString());
		return;
	}
	statistics_addInfo("from average", deltaFromAverage);
	if(pingPongTime < ServerNetwork_fastestPingPongTime) {
		ServerNetwork_fastestPingPongTime = pingPongTime;
		ServerNetwork_referenceStartTime = calculatedStartTime;
		core_startTime = ServerNetwork_referenceStartTime;
		core_log("New fastest pingPongTime"+", pongCount: "+ServerNetwork_pongCount?.toString()+", now: "+now?.toString()+", pingPongTime: "+pingPongTime?.toString()+", timeSinceStart: "+timeSinceStart?.toString()+", core.startTime: "+core_startTime?.toString()+", referenceStartTime: "+ServerNetwork_referenceStartTime?.toString());
	}
}
function ServerNetwork_sendSignal(receiverId, type, sdp) {
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(4/*Signal*/);
	ServerNetwork_sendBuffer.writeInt32(receiverId);
	ServerNetwork_sendBuffer.writeInt32(input_localUser.id);
	ServerNetwork_sendBuffer.writeString(type);
	ServerNetwork_sendBuffer.writeString(sdp);
	ServerNetwork_send(ServerNetwork_sendBuffer);
}
function ServerNetwork_onSignal(buffer) {
	let receiverId = buffer.readInt32();
	let senderId = buffer.readInt32();
	let type = buffer.readString();
	let sdp = buffer.readString();
	let sender = ServerNetwork_getOrCreateUser(senderId);
	if(type == "offer") {
		sender.connectionId = ServerNetwork_nextConnectionId++;
		PeerNetwork_onReceivedOffer(sender, sdp);
	} else {
		if(type == "answer") {
			PeerNetwork_onReceivedAnswer(sender, sdp);
		}
	}
}
function ServerNetwork_sendIce(receiverId, candidate) {
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(5/*Ice*/);
	ServerNetwork_sendBuffer.writeInt32(receiverId);
	ServerNetwork_sendBuffer.writeInt32(input_localUser.id);
	ServerNetwork_sendBuffer.writeString(candidate);
	ServerNetwork_send(ServerNetwork_sendBuffer);
}
function ServerNetwork_onIce(buffer) {
	let receiverId = buffer.readInt32();
	let senderId = buffer.readInt32();
	let candidate = buffer.readString();
	let sender = ServerNetwork_getOrCreateUser(senderId);
	PeerNetwork_onIce(sender, candidate);
}
function ServerNetwork_sendInputs(inputFrame) {
	let inputs = input_localUser.inputs;
	let length = inputs.writePos - ServerNetwork_inputsSentPos;
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(6/*Tick*/);
	ServerNetwork_sendBuffer.writeInt32(input_localUser.id);
	ServerNetwork_sendBuffer.writeInt32(inputFrame);
	ServerNetwork_sendBuffer.writeBuffer2(inputs, ServerNetwork_inputsSentPos, length);
	ServerNetwork_sendBuffer.writeInt(core_lastChecksumFrame);
	ServerNetwork_sendBuffer.writeFloat64(core_checksums.get(core_lastChecksumFrame) || 0);
	ServerNetwork_send(ServerNetwork_sendBuffer);
	if(core_logging) {
		core_sentLog += " #"+inputFrame?.toString()+" "+ServerNetwork_inputsSentPos?.toString()+"->"+inputs.writePos?.toString()+" "+inputs.toRangeString(ServerNetwork_inputsSentPos, inputs.writePos);
	}
	ServerNetwork_inputsSentPos = inputs.writePos;
	core_tickMessageSize = ServerNetwork_sendBuffer.writePos;
}
function ServerNetwork_onTick(buffer) {
	let senderId = buffer.readInt32();
	let sender = ServerNetwork_getOrCreateUser(senderId);
	let prevWritePos = sender.inputs.writePos;
	sender.inputFrame = buffer.readInt32();
	buffer.readBuffer(sender.inputs, prevWritePos);
	if(core_logging) {
		core_receivedLog += " ["+Date.now()?.toString()+"] <"+senderId?.toString()+"> #"+sender.inputFrame?.toString()+" "+prevWritePos?.toString()+"->"+sender.inputs.writePos?.toString()+" "+sender.inputs.toRangeString(prevWritePos, sender.inputs.writePos);
	}
}
function ServerNetwork_sendSwitch(mode, sendInterval) {
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(7/*Switch*/);
	ServerNetwork_sendBuffer.writeInt32(mode);
	ServerNetwork_sendBuffer.writeInt32(sendInterval);
	ServerNetwork_send(ServerNetwork_sendBuffer);
}
function ServerNetwork_onSwitch(buffer) {
	let mode = buffer.readInt32();
	core_sendInterval = buffer.readInt32();
	if(mode != core_sendInputsMode) {
		core_sendInputsMode = mode;
	}
}
function ServerNetwork_sendReload(newRoom, newUserId, keepMaster) {
	let url = "/"+core_gameId+"/"+((newRoom ? core_roomId + ((core_roomId < 0 ? -1 : 1)) : core_roomId))?.toString();
	ServerNetwork_sendBuffer.reset();
	ServerNetwork_sendBuffer.writeInt8(8/*Reload*/);
	ServerNetwork_sendBuffer.writeBool(keepMaster);
	ServerNetwork_sendBuffer.writeBool(newUserId);
	ServerNetwork_sendBuffer.writeString(url);
	ServerNetwork_send(ServerNetwork_sendBuffer);
}
function ServerNetwork_onReload(buffer) {
	let keepMaster = buffer.readBool();
	let newUserId = buffer.readBool();
	let url = buffer.readString();
	if(!newUserId) {
		url += "u"+input_localUser.id?.toString();
	}
	location.href = url;
}
function snapshot_itou(i) {
	i += 32;
	if (i > 33 && i < 39) {
		i++;
	} else if (i > 38 && i < 44) {
		i += 2;
	} else if (i > 43 && i < 127) {
		i += 3;
	} else if (i > 126 && i < 55258) {
		i += 37; 
	} else if (i > 55295) {
		i += 8485; 
	}
	return String.fromCharCode(i);
}
function snapshot_utoi(i) {
	return i - (i > 63743 ? 8517 :
		i > 159 ? 69 :
			i > 46 && i < 130 ? 35 :
				i > 40 && i < 46 ? 34 :
					i > 34 && i < 40 ? 33 :
						32);
}
function snapshot_compress(input) {
	var _node = function(val) { return {v: val, d: {} }; }
	function itou(i) {
		i += 32;
		if (i > 33 && i < 39) {
			i++;
		} else if (i > 38 && i < 44) {
			i += 2;
		} else if (i > 43 && i < 127) {
			i += 3;
		} else if (i > 126 && i < 55258) {
			i += 37; 
		} else if (i > 55295) {
			i += 8485; 
		}
		return String.fromCharCode(i);
	}
	if (input === null) return "";
	let i = 0,
		j = 0,
		value = 0,
		dictionary = { d: {} },
		freshNode = true,
		c = 0,
		node = _node(2), 
		nextNode,
		enlargeIn = 2,
		dictSize = 3,
		numBits = 2,
		data = [],
		data_val = 0,
		data_position = 0;
	
	if (input.length) {
		
		
		value = input.length;
		data.push(itou(value / 40000000 & 0x7FFF));
		data.push(itou((value >>> 15) & 0x7FFF));
		data.push(itou(value & 0x7FFF));
		
		
		
		
		
		
		
		c = input[0];
		
		
		
		
		for (i = 0; i < numBits; i++) {
			
			data_val <<= 1;
			if (++data_position === 15) {
				data_position = 0;
				data.push(itou(data_val));
				data_val = 0;
			}
		}
		
		for (i = 0; i < 8; i++) {
			
			data_val = c >> i & 1 | data_val << 1;
			if (++data_position === 15) {
				data_position = 0;
				data.push(itou(data_val));
				data_val = 0;
			}
		}
		
		
		dictionary[c] = node;
		
		for (j = 1; j < input.length; j++) {
			c = input[j];
			
			nextNode = node.d[c];
			if (nextNode) {
				
				node = nextNode;
			} else {
				
				
				
				
				
				
				
				if (freshNode) {
					
					
					freshNode = false;
				} else {
					
					value = node.v;
					for (i = 0; i < numBits; i++) {
						
						data_val = value >> i & 1 | data_val << 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
				}
				
				
				
				if (dictionary[c] === undefined) {
					
					if (--enlargeIn === 0) {
						enlargeIn = 1 << numBits++;
					}
					
					
					for (i = 0; i < numBits; i++) {
						data_val <<= 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
					for (i = 0; i < 8; i++) {
						data_val = c >> i & 1 | data_val << 1;
						if (++data_position === 15) {
							data_position = 0;
							data.push(itou(data_val));
							data_val = 0;
						}
					}
					dictionary[c] = _node(dictSize++);
					
					
					freshNode = true;
				}
				
				node.d[c] = _node(dictSize++);
				
				if (--enlargeIn === 0) {
					enlargeIn = 1 << numBits++;
				}
				
				node = dictionary[c];
			}
		}
		
		
		if (freshNode) {
			
			freshNode = false;
		} else {
			
			value = node.v;
			for (i = 0; i < numBits; i++) {
				
				data_val = value >> i & 1 | data_val << 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
		}
		
		
		if (dictionary[c] === undefined) {
			
			if (--enlargeIn === 0) {
				enlargeIn = 1 << numBits++;
			}
			for (i = 0; i < numBits; i++) {
				data_val <<= 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
			for (i = 0; i < 8; i++) {
				data_val = c >> i & 1 | data_val << 1;
				if (++data_position === 15) {
					data_position = 0;
					data.push(itou(data_val));
					data_val = 0;
				}
			}
		}
		
		if (--enlargeIn === 0) {
			enlargeIn = 1 << numBits++;
		}
	}
	
	
	for (i = 0; i < numBits; i++) {
		
		data_val = 1 >> i | data_val << 1;
		if (++data_position === 15) {
			data_position = 0;
			data.push(itou(data_val));
			data_val = 0;
		}
	}
	
	
	data_val <<= 15 - data_position;
	data.push(itou(data_val));
	
	data.push(" ");
	return data.join("");
}
function snapshot_decompress(compressed) {
	function utoi(i) {
		return i - (i > 63743 ? 8517 :
			i > 159 ? 69 :
				i > 46 && i < 130 ? 35 :
					i > 40 && i < 46 ? 34 :
						i > 34 && i < 40 ? 33 :
							32);
	}
	if (compressed === null || compressed.length < 4) return null;
	
	let length = compressed.length,
		getNextValue = function (index) { return utoi(compressed.charCodeAt(index)); };
	let dictionary = [0, 1],
		enlargeIn = 1,
		dictSize = 3,
		numBits = 2,
		bytes = null,
		bytes_concat = null,
		result = new Uint8Array(
			getNextValue(0) * 0x40000000 +
			(getNextValue(1) << 15) +
			getNextValue(2)),
		result_index = 0,
		bits = 0,
		maxPower = 2,
		power = 0,
		data_val = getNextValue(3),
		data_position = 15,
		data_index = 4;
	
	
	
	while (power < maxPower) {
		
		bits += (data_val >> --data_position & 1) << power++;
		if (data_position === 0) {
			data_position = 15;
			data_val = getNextValue(data_index++);
		}
	}
	
	if (bits === 1) {
		return null;
	}
	
	
	bits = power = 0;
	while (power < 8) {
		
		bits += (data_val >> --data_position & 1) << power++;
		if (data_position === 0) {
			data_position = 15;
			data_val = getNextValue(data_index++);
		}
	}
	bytes = [bits];
	dictionary[2] = bytes;
	result[result_index++] = bits;
	
	
	while (data_index <= length) {
		
		maxPower = numBits;
		bits = power = 0;
		while (power < maxPower) {
			
			bits += (data_val >> --data_position & 1) << power++;
			if (data_position === 0) {
				data_position = 15;
				data_val = getNextValue(data_index++);
			}
		}
		
		
		if (!bits) {
			bits = power = 0;
			while (power < 8) {
				
				bits += (data_val >> --data_position & 1) << power++;
				if (data_position === 0) {
					data_position = 15;
					data_val = getNextValue(data_index++);
				}
			}
			dictionary[dictSize] = [bits];
			bits = dictSize++;
			if (--enlargeIn === 0) {
				enlargeIn = 1 << numBits++;
			}
		} else if (bits === 1) {
			
			return result;
		}
		
		if (bits > dictionary.length) {
			return null;
		}
		bytes_concat = bits < dictionary.length ? dictionary[bits] : bytes.concat(bytes[0]);
		for (let i = 0; i < bytes_concat.length; i++) {
			result[result_index++] = bytes_concat[i];
		}
		dictionary[dictSize++] = bytes.concat(bytes_concat[0]);
		bytes = bytes_concat;
		
		if (--enlargeIn === 0) {
			enlargeIn = 1 << numBits++;
		}
	
	}
	return null;
}
function snapshot_testCompression() {
	console.log("Testing utoi/itou functions");
	let utoiMismatches = [];
	for (let i = 0; i < 1 << 15; i++) {
		let j = LZ.utoi(LZ.itou(i).charCodeAt(0));
		if (i !== j) {
			utoiMismatches.push({itou: i, utio: j});
		}
	}
	
	if (utoiMismatches.length) {
		console.log("Errors in itou/utoi conversion detected:", utoiMismatches);
	} else {
		console.log("No errors in itou/utoi conversion detected");
	}
	
	let input = new Uint16Array(1 << 15);
	for (let i = 0; i < input.length; i++) {
		input[i] = i>>4;
	}
	let inputUint8 = new Uint8Array(input.buffer);
	let compressed = LZ.compress(inputUint8);
	let decompressed = new Uint16Array(LZ.decompress(compressed).buffer);
	let mismatches = [];
	for (let i = 0; i < input.length; i++) {
		if (input[i] !== decompressed[i]) {
			mismatches.push({index: i, input: input[i], decompressed: decompressed[i]});
		}
	}
	console.log({
		compressed,
		mismatches,
		length: compressed.length,
		inputLength: input.length,
	});
}
function Sound(file, fadeVolume, audioElement) {
	this.file = file;
	this.fadeVolume = fadeVolume;
	this.audioElement = audioElement;
	audio_sounds.push(this);
}
Sound.prototype.open = function() {
	return new Promise((resolve, reject) => {
		this.nextAudioElement = new Audio();
		this.nextAudioElement.oncanplaythrough = () => resolve();
		this.nextAudioElement.onerror = () => reject();
		this.nextAudioElement.src = _basePath+this.file; 
	})
}
Sound.prototype.volume = function(value) {
	this.fadeVolume = value
	if(this.audioElement) this.audioElement.volume = this.fadeVolume * audio_volume
}
Sound.prototype.updateVolume = function() {
	if(this.audioElement) this.audioElement.volume = this.fadeVolume * audio_volume
}
Sound.prototype.stop = function() {
	if(this.audioElement) this.audioElement.pause()
}
Sound.prototype.play = function(needsToBeCertain) {
	if(needsToBeCertain && !input_isCertain) {
		return;
	}
	let playingSound = audio_playingSounds.find(a => a.sound == this && a.frame == core_frame);
	if(!(playingSound != null)) {
		audio_playingSounds.push(playingSound = new PlayingSound(this, core_frame, true));
		if(core_isPremiere) {
			this.doPlay(playingSound);
		}
	} else {
		playingSound.isConfirmed = true;
	}
}
Sound.prototype.currentTime = function(value) {
	if(this.audioElement) this.audioElement.currentTime = value
}
Sound.prototype.doPlay = function(ps) {
	
	if(!this.nextAudioElement) this.preloadForNextPlayback();
		
	
	this.fadeVolume = 1;
	this.audioElement = this.nextAudioElement;
	this.audioElement.volume = audio_volume;
	this.audioElement.onended = () => audio_playingSounds.remove(ps);
	this.audioElement.play();
	this.preloadForNextPlayback()
}
Sound.prototype.preloadForNextPlayback = async function() {
	this.nextAudioElement = new Audio();
	if(PeerNetwork_audioOutputId && this.nextAudioElement.setSinkId) 
		await this.nextAudioElement.setSinkId(PeerNetwork_audioOutputId);
	this.nextAudioElement.src = _basePath+this.file;
}
Sound.prototype.isPlaying = function() {
	return audio_playingSounds.some(a => a.sound == this && a.frame < core_frame);
}
Sound.prototype.fadeOut = function(duration, delay) {
	return this;
}
Sound.prototype.clone = function() {
	let clone = new _Sound();
	clone.file = this.file;
	clone.fadeVolume = this.fadeVolume;
	clone.audioElement = this.audioElement;
	return clone;
}
function _Sound() {};
_Sound.prototype = Sound.prototype;
Sound.prototype.serialize_internal = function(buffer) {
	buffer.writeString(this.file);
	buffer.writeFloat64(this.fadeVolume);
}
Sound.prototype.deserialize_internal = function(buffer) {
	this.file = buffer.readString();
	this.fadeVolume = buffer.readFloat64();
}
Sound.prototype.serialize_external = function(buffer) {
	buffer.writeString("file");
	buffer.writeString(this.file);
	buffer.writeString("fadeVolume");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.fadeVolume);
	buffer.writeString("");
}
Sound.prototype.deserialize_external = function(buffer) {
	let file_is_set = false, fadeVolume_is_set = false;
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "file":
				this.file = buffer.readString();
				file_is_set = true;
				break;
			case "fadeVolume":
				buffer.readInt32();
				this.fadeVolume = buffer.readFloat64();
				fadeVolume_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!file_is_set) this.file = "";
				if(!fadeVolume_is_set) this.fadeVolume = 1;
				return;
		}
	}
}
function PlayingSound(sound, frame, isConfirmed) {
	this.sound = sound;
	this.frame = frame;
	this.isConfirmed = isConfirmed;
}
PlayingSound.prototype.clone = function() {
	let clone = new _PlayingSound();
	clone.sound = this.sound;
	clone.frame = this.frame;
	clone.isConfirmed = this.isConfirmed;
	return clone;
}
function _PlayingSound() {};
_PlayingSound.prototype = PlayingSound.prototype;
var Time_now;
function Time_init() {
	Time_now = 0.0;
}
function Time() {
}
function Time_fromTimeString(timeString) {
	let value = 0;
	let colon1 = timeString.indexOf(":");
	if(colon1 == -1) {
		value += (parseInt(timeString) * 3600000);
	} else {
		value += (parseInt(timeString.substring(0, colon1)) * 3600000);
		let colon2 = timeString.indexOf(":", colon1 + 1);
		if(colon2 == -1) {
			value += (parseInt(timeString.substring(colon1 + 1)) * 60000);
		} else {
			value += (parseInt(timeString.substring(colon1 + 1, colon2)) * 60000);
			value += (parseInt(timeString.substring(colon2 + 1)) * 1000);
		}
	}
	return value;
}
function Time_measure($do) {
	let startTime = performance.now();
	$do();
	return performance.now() - startTime;
}
function Time_startTimer() {
	window._timerStart = performance.now()
}
function Time_printTimer(text) {
	log(text+": "+(performance.now()-window._timerStart))
}
function _Time() {};
_Time.prototype = Time.prototype;
var Date_dayStrings;
var Date_shortDayStrings;
function Date_init() {
	Date_dayStrings = [["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]];
	Date_shortDayStrings = [["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]];
}
function Date_toTwoDigitString(value) {
	return (value < 10 ? "0" + value.toString() : value.toString());
}
Date.prototype.dayMonthString = function(language) {
	return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"."
}
Date.prototype.dayMonthYearString = function(language) {
	return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"."+this.getFullYear()
}
Date.prototype.dayLongMonthNameYearString = function(language) {
	return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+" "+this.toLocaleString("en-US", {month: "long"})+" "+this.getFullYear()
}
Date.prototype.dayShortMonthNameYearString = function(language) {
	return this.getDate()+" "+this.toLocaleString("en-US", {month: "short"})+" "+this.getFullYear()
}
Date.prototype.weekdayString = function(language) {
	return Date_dayStrings.get(language).get(this.getDay());
}
Date.prototype.shortWeekdayString = function(language) {
	return Date_shortDayStrings.get(language).get(this.getDay());
}
Date.prototype.hourMinuteString = function(language) {
	if(language == 0/*English*/) {
		let h = this.getHours();
		return "" + (int_modulo_int((h - 1), 12) + 1) + ":" + Date_toTwoDigitString(this.getMinutes()) + ((h < 12 ? " am" : " pm"));
	} else {
		return "" + this.getHours() + ":" + Date_toTwoDigitString(this.getMinutes());
	}
}
Date.prototype.hourMinuteSecondString = function(language) {
	if(language == 0/*English*/) {
		let h = this.getHours();
		return "" + (int_modulo_int((h - 1), 12) + 1) + ":" + Date_toTwoDigitString(this.getMinutes()) + ":" + Date_toTwoDigitString(this.getSeconds()) + ((h < 12 ? " am" : " pm"));
	} else {
		return "" + this.getHours() + ":" + Date_toTwoDigitString(this.getMinutes()) + ":" + Date_toTwoDigitString(this.getSeconds());
	}
}
Date.prototype.dayMonthYearHourMinuteString = function(language) {
	if(language == 1000) return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+this.getFullYear()+" "+this.getHours().toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+this.getMinutes().toLocaleString("en-US", {minimumIntegerDigits:2})
	else return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"."+this.getFullYear()+" "+this.getHours().toLocaleString("en-US", {minimumIntegerDigits:2})+":"+this.getMinutes().toLocaleString("en-US", {minimumIntegerDigits:2})
}
Date.prototype.dayMonthYearHourMinuteSecondString = function(language) {
	return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"."+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"."+this.getFullYear()+" "+this.getHours().toLocaleString("en-US", {minimumIntegerDigits:2})+":"+this.getMinutes().toLocaleString("en-US", {minimumIntegerDigits:2})+":"+this.getSeconds().toLocaleString("en-US", {minimumIntegerDigits:2})
}
Date.prototype.invariantDayMonthYearHourMinuteSecondString = function(language) {
	return this.getDate().toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+(this.getMonth()+1).toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+this.getFullYear()+" "+this.getHours().toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+this.getMinutes().toLocaleString("en-US", {minimumIntegerDigits:2})+"-"+this.getSeconds().toLocaleString("en-US", {minimumIntegerDigits:2})
}
Date.prototype.isoString = function() {
	let tzo = -this.getTimezoneOffset()
	let dif = tzo >= 0 ? "+" : "-"
	
	function pad (num) {
		return (num < 10 ? "0" : "") + num;
	}
	
	return this.getFullYear() +
		"-" + pad(this.getMonth() + 1) +
		"-" + pad(this.getDate()) +
		"T" + pad(this.getHours()) +
		":" + pad(this.getMinutes()) +
		":" + pad(this.getSeconds()) +
		dif + pad(Math.floor(Math.abs(tzo) / 60)) +
		":" + pad(Math.abs(tzo) % 60);
}
function FadeAnimation(startTime, duration, object, startValue, delta, removeWhenDone) {
	Animation.call(this, startTime, duration, object);
	this.type = "FadeAnimation";
	this.startValue = startValue;
	this.delta = delta;
	this.removeWhenDone = removeWhenDone;
}
function __FadeAnimationPrototype() { this.constructor = FadeAnimation; }
__FadeAnimationPrototype.prototype = Animation.prototype;
FadeAnimation.prototype = new __FadeAnimationPrototype();
FadeAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	this.object.alpha = this.startValue + this.delta * f;
	if(f >= 1 && this.removeWhenDone) {
		Framework_objects.remove(this.object);
	}
}
FadeAnimation.prototype.clone = function() {
	let clone = new _FadeAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue;
	clone.delta = this.delta;
	clone.removeWhenDone = this.removeWhenDone;
	return clone;
}
function _FadeAnimation() {};
_FadeAnimation.prototype = FadeAnimation.prototype;
FadeAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	buffer.writeFloat64(this.startValue);
	buffer.writeFloat64(this.delta);
	buffer.writeBool(this.removeWhenDone);
}
FadeAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	this.startValue = buffer.readFloat64();
	this.delta = buffer.readFloat64();
	this.removeWhenDone = buffer.readBool();
}
FadeAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startValue);
	buffer.writeString("delta");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.delta);
	buffer.writeString("removeWhenDone");
	buffer.writeInt32(1);
	buffer.writeBool(this.removeWhenDone);
	buffer.writeString("");
}
FadeAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false, removeWhenDone_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				this.startValue = buffer.readFloat64();
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				this.delta = buffer.readFloat64();
				delta_is_set = true;
				break;
			case "removeWhenDone":
				buffer.readInt32();
				this.removeWhenDone = buffer.readBool();
				removeWhenDone_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = 0.0;
				if(!delta_is_set) this.delta = 0.0;
				if(!removeWhenDone_is_set) this.removeWhenDone = false;
				return;
		}
	}
}
function MoveAnimation(startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "MoveAnimation";
	this.startValue = startValue?.clone();
	this.delta = delta?.clone();
}
function __MoveAnimationPrototype() { this.constructor = MoveAnimation; }
__MoveAnimationPrototype.prototype = Animation.prototype;
MoveAnimation.prototype = new __MoveAnimationPrototype();
MoveAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	Vector2_assign_Vector2(this.object.position, Vector2_plus_Vector2(this.startValue, Vector2_multiply_float(this.delta, f)));
}
MoveAnimation.prototype.clone = function() {
	let clone = new _MoveAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue.clone();
	clone.delta = this.delta.clone();
	return clone;
}
function _MoveAnimation() {};
_MoveAnimation.prototype = MoveAnimation.prototype;
MoveAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	(this.startValue || new _Vector2()).serialize_internal(buffer);
	(this.delta || new _Vector2()).serialize_internal(buffer);
}
MoveAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	(this.startValue || (this.startValue = new _Vector2())).deserialize_internal(buffer);
	(this.delta || (this.delta = new _Vector2())).deserialize_internal(buffer);
}
MoveAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	let startValue_startPos = buffer.reserveSize();
	(this.startValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(startValue_startPos);
	buffer.writeString("delta");
	let delta_startPos = buffer.reserveSize();
	(this.delta || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(delta_startPos);
	buffer.writeString("");
}
MoveAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				(this.startValue || (this.startValue = new _Vector2())).deserialize_external(buffer);
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				(this.delta || (this.delta = new _Vector2())).deserialize_external(buffer);
				delta_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = new Vector2(0.0, 0.0, null);
				if(!delta_is_set) this.delta = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function ScaleAnimation(startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "ScaleAnimation";
	this.startValue = startValue?.clone();
	this.delta = delta?.clone();
}
function __ScaleAnimationPrototype() { this.constructor = ScaleAnimation; }
__ScaleAnimationPrototype.prototype = Animation.prototype;
ScaleAnimation.prototype = new __ScaleAnimationPrototype();
ScaleAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	Vector2_assign_Vector2(this.object.size, Vector2_plus_Vector2(this.startValue, Vector2_multiply_float(this.delta, f)));
}
ScaleAnimation.prototype.clone = function() {
	let clone = new _ScaleAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue.clone();
	clone.delta = this.delta.clone();
	return clone;
}
function _ScaleAnimation() {};
_ScaleAnimation.prototype = ScaleAnimation.prototype;
ScaleAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	(this.startValue || new _Vector2()).serialize_internal(buffer);
	(this.delta || new _Vector2()).serialize_internal(buffer);
}
ScaleAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	(this.startValue || (this.startValue = new _Vector2())).deserialize_internal(buffer);
	(this.delta || (this.delta = new _Vector2())).deserialize_internal(buffer);
}
ScaleAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	let startValue_startPos = buffer.reserveSize();
	(this.startValue || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(startValue_startPos);
	buffer.writeString("delta");
	let delta_startPos = buffer.reserveSize();
	(this.delta || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(delta_startPos);
	buffer.writeString("");
}
ScaleAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				(this.startValue || (this.startValue = new _Vector2())).deserialize_external(buffer);
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				(this.delta || (this.delta = new _Vector2())).deserialize_external(buffer);
				delta_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = new Vector2(0.0, 0.0, null);
				if(!delta_is_set) this.delta = new Vector2(0.0, 0.0, null);
				return;
		}
	}
}
function FadeSoundAnimation(sound, startTime, duration, object, startValue, delta) {
	Animation.call(this, startTime, duration, object);
	this.type = "FadeSoundAnimation";
	this.startValue = startValue;
	this.delta = delta;
	this.audioElement = null;
	this.audioElement = sound.audioElement;
}
function __FadeSoundAnimationPrototype() { this.constructor = FadeSoundAnimation; }
__FadeSoundAnimationPrototype.prototype = Animation.prototype;
FadeSoundAnimation.prototype = new __FadeSoundAnimationPrototype();
FadeSoundAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	if(this.audioElement == null) {
		return;
	}
	this.audioElement.volume = (this.startValue + this.delta * f) * audio_volume;
	if(f >= 1) {
		this.audioElement.pause;
	}
}
FadeSoundAnimation.prototype.clone = function() {
	let clone = new _FadeSoundAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.startValue = this.startValue;
	clone.delta = this.delta;
	clone.audioElement = this.audioElement;
	return clone;
}
function _FadeSoundAnimation() {};
_FadeSoundAnimation.prototype = FadeSoundAnimation.prototype;
FadeSoundAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	buffer.writeFloat64(this.startValue);
	buffer.writeFloat64(this.delta);
	let audioElement = this.audioElement
	if(audioElement) {
		var index = _objectCacheIndex.get(audioElement);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioElement, index = _objectCache.length);
			_objectCache.push(audioElement);
			buffer.writeInt32(-index);
			audioElement._objectIndex = index;
			audioElement.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
FadeSoundAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	this.startValue = buffer.readFloat64();
	this.delta = buffer.readFloat64();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.audioElement = _objectCache[index];
	} else {
		let audioElement = this.audioElement
		if(!audioElement || audioElement._objectIndex != -index)
			this.audioElement = audioElement = new _dynamic();
		(_objectCache[-index] = audioElement).deserialize_internal(buffer);
	}
}
FadeSoundAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("startValue");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.startValue);
	buffer.writeString("delta");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.delta);
	buffer.writeString("audioElement");
	let audioElement_startPos = buffer.reserveSize();
	let audioElement = this.audioElement
	if(audioElement) {
		var index = _objectCacheIndex.get(audioElement);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(audioElement, index = _objectCache.length);
			_objectCache.push(audioElement);
			buffer.writeInt32(-index);
			audioElement._objectIndex = index;
			audioElement.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(audioElement_startPos);
	buffer.writeString("");
}
FadeSoundAnimation.prototype.deserialize_external = function(buffer) {
	let startValue_is_set = false, delta_is_set = false, audioElement_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "startValue":
				buffer.readInt32();
				this.startValue = buffer.readFloat64();
				startValue_is_set = true;
				break;
			case "delta":
				buffer.readInt32();
				this.delta = buffer.readFloat64();
				delta_is_set = true;
				break;
			case "audioElement":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.audioElement = _objectCache[index];
				} else {
					let audioElement = this.audioElement
					if(!audioElement || audioElement._objectIndex != -index)
						this.audioElement = audioElement = new _dynamic();
					(_objectCache[-index] = audioElement).deserialize_external(buffer);
				}
				audioElement_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!startValue_is_set) this.startValue = 0.0;
				if(!delta_is_set) this.delta = 0.0;
				if(!audioElement_is_set) this.audioElement = null;
				return;
		}
	}
}
function PlaySoundAnimation(startTime, duration, object, sound) {
	Animation.call(this, startTime, duration, object);
	this.type = "PlaySoundAnimation";
	this.sound = sound;
}
function __PlaySoundAnimationPrototype() { this.constructor = PlaySoundAnimation; }
__PlaySoundAnimationPrototype.prototype = Animation.prototype;
PlaySoundAnimation.prototype = new __PlaySoundAnimationPrototype();
PlaySoundAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	this.sound.play(false);
}
PlaySoundAnimation.prototype.clone = function() {
	let clone = new _PlaySoundAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.sound = this.sound;
	return clone;
}
function _PlaySoundAnimation() {};
_PlaySoundAnimation.prototype = PlaySoundAnimation.prototype;
PlaySoundAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
PlaySoundAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.sound = _objectCache[index];
	} else {
		let sound = this.sound
		if(!sound || sound._objectIndex != -index)
			this.sound = sound = new _Sound();
		(_objectCache[-index] = sound).deserialize_internal(buffer);
	}
}
PlaySoundAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("sound");
	let sound_startPos = buffer.reserveSize();
	let sound = this.sound
	if(sound) {
		var index = _objectCacheIndex.get(sound);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(sound, index = _objectCache.length);
			_objectCache.push(sound);
			buffer.writeInt32(-index);
			sound._objectIndex = index;
			sound.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(sound_startPos);
	buffer.writeString("");
}
PlaySoundAnimation.prototype.deserialize_external = function(buffer) {
	let sound_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "sound":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.sound = _objectCache[index];
				} else {
					let sound = this.sound
					if(!sound || sound._objectIndex != -index)
						this.sound = sound = new _Sound();
					(_objectCache[-index] = sound).deserialize_external(buffer);
				}
				sound_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!sound_is_set) this.sound = null;
				return;
		}
	}
}
function DelayAnimation(startTime, duration, object, $do) {
	Animation.call(this, startTime, duration, object);
	this.type = "DelayAnimation";
	this.do = $do;
}
function __DelayAnimationPrototype() { this.constructor = DelayAnimation; }
__DelayAnimationPrototype.prototype = Animation.prototype;
DelayAnimation.prototype = new __DelayAnimationPrototype();
DelayAnimation.prototype.tick = function(f) {
	Animation.prototype.tick.call(this, f);
	this.do.invoke();
}
DelayAnimation.prototype.clone = function() {
	let clone = new _DelayAnimation();
	clone.type = this.type;
	clone.startTime = this.startTime;
	clone.duration = this.duration;
	clone.object = this.object;
	clone.do = this.do;
	return clone;
}
function _DelayAnimation() {};
_DelayAnimation.prototype = DelayAnimation.prototype;
DelayAnimation.prototype.serialize_internal = function(buffer) {
	Animation.prototype.serialize_internal.call(this, buffer);
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
DelayAnimation.prototype.deserialize_internal = function(buffer) {
	Animation.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.do = _objectCache[index];
	} else {
		let $do = this.do
		let _id = buffer.readInt32();
		if(!$do || $do._id != _id || $do._objectIndex != -index)
			this.do = $do = new _lambdaContructors[_id]();
		$do._id = _id;
		(_objectCache[-index] = $do).deserialize_internal(buffer);
	}
}
DelayAnimation.prototype.serialize_external = function(buffer) {
	Animation.prototype.serialize_external.call(this, buffer);
	buffer.writeString("do");
	let $do_startPos = buffer.reserveSize();
	let $do = this.do
	if($do) {
		var index = _objectCacheIndex.get($do);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set($do, index = _objectCache.length);
			_objectCache.push($do);
			buffer.writeInt32(-index);
			buffer.writeInt32($do._id);
			$do._objectIndex = index;
			$do.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize($do_startPos);
	buffer.writeString("");
}
DelayAnimation.prototype.deserialize_external = function(buffer) {
	let do_is_set = false;
	Animation.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "do":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.do = _objectCache[index];
				} else {
					let $do = this.do
					let _id = buffer.readInt32();
					if(!$do || $do._id != _id || $do._objectIndex != -index)
						this.do = $do = new _lambdaContructors[_id]();
					$do._id = _id;
					(_objectCache[-index] = $do).deserialize_external(buffer);
				}
				do_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!do_is_set) this.do = null;
				return;
		}
	}
}
function DisplayImage(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, htmlImage, sx, sy, sw, sh, color) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayImage";
	this.htmlImage = htmlImage;
	this.sx = sx;
	this.sy = sy;
	this.sw = sw;
	this.sh = sh;
	this.color = color;
}
function __DisplayImagePrototype() { this.constructor = DisplayImage; }
__DisplayImagePrototype.prototype = DisplayItem.prototype;
DisplayImage.prototype = new __DisplayImagePrototype();
DisplayImage.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	if(this.color.hex == "#ffffff") {
		try{ graphics_context.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, this.x, this.y, this.w, this.h) }
		catch(e) { log("DisplayImage: "+e.message) }
	} else {
		
		let offscreenCanvas = document.createElement("canvas");
		offscreenCanvas.width = this.sw;
		offscreenCanvas.height = this.sh;
		let offscreenContext = offscreenCanvas.getContext("2d");
		
		
		offscreenContext.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, 0, 0, this.sw, this.sh)
		
		
		offscreenContext.fillStyle = this.color.hex;
		offscreenContext.globalCompositeOperation = "multiply";
		offscreenContext.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
		
		
		offscreenContext.globalAlpha = 1;
		offscreenContext.globalCompositeOperation = "destination-in";
		offscreenContext.drawImage(this.htmlImage, this.sx, this.sy, this.sw, this.sh, 0, 0, this.sw, this.sh)
			
		
		graphics_context.drawImage(offscreenCanvas, this.x, this.y, this.w, this.h); 
	}
	
	if(this.clippingPath) this.endClipping()
}
DisplayImage.prototype.clone = function() {
	let clone = new _DisplayImage();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.htmlImage = this.htmlImage;
	clone.sx = this.sx;
	clone.sy = this.sy;
	clone.sw = this.sw;
	clone.sh = this.sh;
	clone.color = this.color;
	return clone;
}
function _DisplayImage() {};
_DisplayImage.prototype = DisplayImage.prototype;
function DisplayText(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, fillStyle, outlineColor, outlineWidth, offsetY, font) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayText";
	this.fillStyle = fillStyle;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
	this.offsetY = offsetY;
	this.font = font;
}
function __DisplayTextPrototype() { this.constructor = DisplayText; }
__DisplayTextPrototype.prototype = DisplayItem.prototype;
DisplayText.prototype = new __DisplayTextPrototype();
DisplayText.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	graphics_context.font = this.font
	if(this.outlineColor) {
		graphics_context.lineWidth = this.outlineWidth
		graphics_context.strokeStyle = this.outlineColor
		graphics_context.strokeText(this.name, this.x, this.y)
	}
	graphics_context.fillStyle = this.fillStyle
	graphics_context.fillText(this.name, this.x, this.y - this.offsetY)
	
	if(this.clippingPath) this.endClipping()
}
DisplayText.prototype.clone = function() {
	let clone = new _DisplayText();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.fillStyle = this.fillStyle;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	clone.offsetY = this.offsetY;
	clone.font = this.font;
	return clone;
}
function _DisplayText() {};
_DisplayText.prototype = DisplayText.prototype;
function DisplayRectangle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayRectangle";
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayRectanglePrototype() { this.constructor = DisplayRectangle; }
__DisplayRectanglePrototype.prototype = DisplayItem.prototype;
DisplayRectangle.prototype = new __DisplayRectanglePrototype();
DisplayRectangle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	if(this.color == "clear") {
		graphics_context.clearRect(this.x, this.y, this.w, this.h)
	}
	else
	if(this.color) {
		graphics_context.fillStyle = this.color
		graphics_context.fillRect(this.x, this.y, this.w, this.h)
	}
	if(this.outlineColor) {
		graphics_context.lineWidth = this.outlineWidth
		graphics_context.strokeStyle = this.outlineColor
		graphics_context.strokeRect(this.x, this.y, this.w, this.h)
	}
	if(this.clippingPath) this.endClipping()
}
DisplayRectangle.prototype.clone = function() {
	let clone = new _DisplayRectangle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayRectangle() {};
_DisplayRectangle.prototype = DisplayRectangle.prototype;
function DisplayRoundedRectangle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, radius, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayRoundedRectangle";
	this.radius = radius;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayRoundedRectanglePrototype() { this.constructor = DisplayRoundedRectangle; }
__DisplayRoundedRectanglePrototype.prototype = DisplayItem.prototype;
DisplayRoundedRectangle.prototype = new __DisplayRoundedRectanglePrototype();
DisplayRoundedRectangle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	let sizeX = this.w, sizeY = this.h, x = this.x, y = this.y, radius = this.radius
	
	
	graphics_context.beginPath();
	graphics_context.moveTo(x + radius, y);
	graphics_context.lineTo(x + sizeX - radius, y);
	graphics_context.arcTo(x + sizeX, y, x + sizeX, y + radius, radius);
	graphics_context.lineTo(x + sizeX, y + sizeY - radius);
	graphics_context.arcTo(x + sizeX, y + sizeY, x + sizeX - radius, y + sizeY, radius);
	graphics_context.lineTo(x + radius, y + sizeY);
	graphics_context.arcTo(x, y + sizeY, x, y + sizeY - radius, radius);
	graphics_context.lineTo(x, y + radius);
	graphics_context.arcTo(x, y, x + radius, y, radius);
	graphics_context.closePath();
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	if(this.color) {
		graphics_context.fillStyle = this.color
		graphics_context.fill()
	}
	if(this.outlineColor) {
		graphics_context.lineWidth = this.outlineWidth
		graphics_context.strokeStyle = this.outlineColor
		graphics_context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayRoundedRectangle.prototype.clone = function() {
	let clone = new _DisplayRoundedRectangle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.radius = this.radius;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayRoundedRectangle() {};
_DisplayRoundedRectangle.prototype = DisplayRoundedRectangle.prototype;
function DisplayPolygon(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, points, color, outlineColor, outlineWidth, smooth, close) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayPolygon";
	this.points = points;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
	this.smooth = smooth;
	this.close = close;
}
function __DisplayPolygonPrototype() { this.constructor = DisplayPolygon; }
__DisplayPolygonPrototype.prototype = DisplayItem.prototype;
DisplayPolygon.prototype = new __DisplayPolygonPrototype();
DisplayPolygon.prototype.draw = function() {
	if(this.points.length < 2 || this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	let x = this.x, y = this.y
	let points = this.points, startPoint = points[0]
	
	graphics_context.beginPath();
	graphics_context.moveTo(x + startPoint.x, y + startPoint.y)
	
	if(!this.smooth || points.length < 3) {
		for(let i=1, len = points.length; i<len; ++i) {
			let p = points[i]
			graphics_context.lineTo(x + p.x, y + p.y)
		}
	} else {
		for(var i = 1, len = points.length - 2; i<len; i++)
		{
			let p1 = points[i], p2 = points[i + 1]
			graphics_context.quadraticCurveTo(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
		}
		let p1 = points[i], p2 = points[i + 1]
		graphics_context.quadraticCurveTo(p1.x, p1.y, p2.x,p2.y);
	}
	if(this.close || this.color) {
		graphics_context.closePath()
	}
	if(this.color) {
		
		graphics_context.fillStyle = this.color
		graphics_context.fill()
	}
	if(this.outlineColor) {
		
		graphics_context.lineWidth = this.outlineWidth
		graphics_context.strokeStyle = this.outlineColor
		graphics_context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayPolygon.prototype.clone = function() {
	let clone = new _DisplayPolygon();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.points = this.points;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	clone.smooth = this.smooth;
	clone.close = this.close;
	return clone;
}
function _DisplayPolygon() {};
_DisplayPolygon.prototype = DisplayPolygon.prototype;
function DisplayCircle(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, startAngle, angle, direction, color, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayCircle";
	this.startAngle = startAngle;
	this.angle = angle;
	this.direction = direction;
	this.color = color;
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayCirclePrototype() { this.constructor = DisplayCircle; }
__DisplayCirclePrototype.prototype = DisplayItem.prototype;
DisplayCircle.prototype = new __DisplayCirclePrototype();
DisplayCircle.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
		
	graphics_context.beginPath();
	if(this.w == this.h) {
		let radius = this.w/2
		if(this.angle == 1) {
			graphics_context.arc(this.x+radius, this.y+radius, radius, 0, math_TwoPI, this.direction);
		} else {
			graphics_context.arc(this.x+radius, this.y+radius, radius, this.startAngle*math_TwoPI, (this.startAngle+this.angle)*math_TwoPI, this.direction);
		}
	} else {
		let radiusX = this.w/2
		let radiusY = this.h/2
		graphics_context.ellipse(this.x+radiusX, this.y+radiusY, radiusX, radiusY, 0, math_TwoPI, this.direction);
	}
	if(this.color) {
		graphics_context.fillStyle = this.color
		graphics_context.fill()
	}
	if(this.outlineColor) {
		graphics_context.lineWidth = this.outlineWidth
		graphics_context.strokeStyle = this.outlineColor
		graphics_context.stroke()
	}
	if(this.clippingPath) this.endClipping()
}
DisplayCircle.prototype.clone = function() {
	let clone = new _DisplayCircle();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.startAngle = this.startAngle;
	clone.angle = this.angle;
	clone.direction = this.direction;
	clone.color = this.color;
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayCircle() {};
_DisplayCircle.prototype = DisplayCircle.prototype;
function DisplayLine(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, end, outlineColor, outlineWidth) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayLine";
	this.end = end?.clone();
	this.outlineColor = outlineColor;
	this.outlineWidth = outlineWidth;
}
function __DisplayLinePrototype() { this.constructor = DisplayLine; }
__DisplayLinePrototype.prototype = DisplayItem.prototype;
DisplayLine.prototype = new __DisplayLinePrototype();
DisplayLine.prototype.draw = function() {
	if(this.alpha == 0) return
	graphics_context.setTransform(this.m0, this.m1, this.m2, this.m3, this.m4, this.m5)
	graphics_context.globalAlpha = this.alpha
	if(this.clippingPath) this.startClipping()
	
	graphics_context.beginPath();
	graphics_context.moveTo(this.x,this.y)
	graphics_context.lineTo(this.end.x, this.end.y)
	graphics_context.lineWidth = this.outlineWidth
	graphics_context.strokeStyle = this.outlineColor
	graphics_context.stroke()
	
	if(this.clippingPath) this.endClipping()
}
DisplayLine.prototype.clone = function() {
	let clone = new _DisplayLine();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.end = this.end.clone();
	clone.outlineColor = this.outlineColor;
	clone.outlineWidth = this.outlineWidth;
	return clone;
}
function _DisplayLine() {};
_DisplayLine.prototype = DisplayLine.prototype;
function DisplayVideo(m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation, userId, shape) {
	DisplayItem.call(this, m, x, y, w, h, layer, alpha, clippingPath, name, location, positionLocation, sizeLocation);
	this.type = "DisplayVideo";
	this.userId = userId;
	this.shape = shape;
}
function __DisplayVideoPrototype() { this.constructor = DisplayVideo; }
__DisplayVideoPrototype.prototype = DisplayItem.prototype;
DisplayVideo.prototype = new __DisplayVideoPrototype();
DisplayVideo.prototype.draw = function() {
	DisplayItem.prototype.draw.call(this);
	let user = input_internalUsers.get(this.userId);
	if((user != null)) {
		let videoElement = user.videoElements.get(user.videoElementIndex) || (user.videoElements.set(user.videoElementIndex, PeerNetwork_createVideoElement(user.mediaStream, user.local)));
		let px = (this.m0 * this.x + this.m2 * this.y + this.m4) / graphics_pixelRatio;
		let py = (this.m1 * this.x + this.m3 * this.y + this.m5) / graphics_pixelRatio;
		let sizeX = this.w * this.m0 / graphics_pixelRatio;
		let sizeY = this.h * this.m3 / graphics_pixelRatio;
		PeerNetwork_updateVideoElement(videoElement, px, py, sizeX, sizeY, (this.shape == 2/*Circle*/ ? 10000 : 0));
		user.videoElementIndex++;
	}
}
DisplayVideo.prototype.clone = function() {
	let clone = new _DisplayVideo();
	clone.type = this.type;
	clone.x = this.x;
	clone.y = this.y;
	clone.w = this.w;
	clone.h = this.h;
	clone.layer = this.layer;
	clone.alpha = this.alpha;
	clone.clippingPath = this.clippingPath;
	clone.name = this.name;
	clone.location = this.location;
	clone.positionLocation = this.positionLocation;
	clone.sizeLocation = this.sizeLocation;
	clone.m0 = this.m0;
	clone.m1 = this.m1;
	clone.m2 = this.m2;
	clone.m3 = this.m3;
	clone.m4 = this.m4;
	clone.m5 = this.m5;
	clone.poly = this.poly;
	clone.userId = this.userId;
	clone.shape = this.shape;
	return clone;
}
function _DisplayVideo() {};
_DisplayVideo.prototype = DisplayVideo.prototype;
function RectangleObject(position, size, alpha, visibleFor, layer, locked, location, color) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "RectangleObject";
	this.color = color;
}
function __RectangleObjectPrototype() { this.constructor = RectangleObject; }
__RectangleObjectPrototype.prototype = $Object.prototype;
RectangleObject.prototype = new __RectangleObjectPrototype();
RectangleObject.prototype.tick = function() {
	graphics_drawRectangle(this.position, this.size, this.color, null, 0, this.visibleFor, this.layer, this.alpha, 1/*Center*/, 1/*Middle*/, null);
}
RectangleObject.prototype.clone = function() {
	let clone = new _RectangleObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.color = this.color;
	return clone;
}
function _RectangleObject() {};
_RectangleObject.prototype = RectangleObject.prototype;
RectangleObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
RectangleObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
RectangleObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
RectangleObject.prototype.deserialize_external = function(buffer) {
	let color_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!color_is_set) this.color = Color_White;
				return;
		}
	}
}
function CircleObject(position, size, alpha, visibleFor, layer, locked, location, color) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "CircleObject";
	this.color = color;
}
function __CircleObjectPrototype() { this.constructor = CircleObject; }
__CircleObjectPrototype.prototype = $Object.prototype;
CircleObject.prototype = new __CircleObjectPrototype();
CircleObject.prototype.tick = function() {
	graphics_drawCircle(this.position, this.size, this.color, null, 0, (-.25), 1.0, 0/*Clockwise*/, this.visibleFor, this.layer, 1.0, null);
}
CircleObject.prototype.clone = function() {
	let clone = new _CircleObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.color = this.color;
	return clone;
}
function _CircleObject() {};
_CircleObject.prototype = CircleObject.prototype;
CircleObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
CircleObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
}
CircleObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("");
}
CircleObject.prototype.deserialize_external = function(buffer) {
	let color_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!color_is_set) this.color = Color_White;
				return;
		}
	}
}
function TextObject(position, size, alpha, visibleFor, layer, locked, location, text, font, color, align, valign) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "TextObject";
	this.text = text;
	this.font = font;
	this.color = color;
	this.align = align;
	this.valign = valign;
}
function __TextObjectPrototype() { this.constructor = TextObject; }
__TextObjectPrototype.prototype = $Object.prototype;
TextObject.prototype = new __TextObjectPrototype();
TextObject.prototype.tick = function() {
	graphics_drawText(this.text, this.position, this.size, this.color, this.align, this.valign, 0/*Normal*/, this.font, null, 0, this.visibleFor, this.layer, this.alpha, null);
}
TextObject.prototype.clone = function() {
	let clone = new _TextObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.text = this.text;
	clone.font = this.font;
	clone.color = this.color;
	clone.align = this.align;
	clone.valign = this.valign;
	return clone;
}
function _TextObject() {};
_TextObject.prototype = TextObject.prototype;
TextObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	buffer.writeString(this.text);
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.align);
	buffer.writeInt32(this.valign);
}
TextObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.font = _objectCache[index];
	} else {
		let font = this.font
		if(!font || font._objectIndex != -index)
			this.font = font = new _Font();
		(_objectCache[-index] = font).deserialize_internal(buffer);
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.color = _objectCache[index];
	} else {
		let color = this.color
		if(!color || color._objectIndex != -index)
			this.color = color = new _Color();
		(_objectCache[-index] = color).deserialize_internal(buffer);
	}
	this.align = buffer.readInt32();
	this.valign = buffer.readInt32();
}
TextObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("font");
	let font_startPos = buffer.reserveSize();
	let font = this.font
	if(font) {
		var index = _objectCacheIndex.get(font);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(font, index = _objectCache.length);
			_objectCache.push(font);
			buffer.writeInt32(-index);
			font._objectIndex = index;
			font.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(font_startPos);
	buffer.writeString("color");
	let color_startPos = buffer.reserveSize();
	let color = this.color
	if(color) {
		var index = _objectCacheIndex.get(color);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(color, index = _objectCache.length);
			_objectCache.push(color);
			buffer.writeInt32(-index);
			color._objectIndex = index;
			color.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(color_startPos);
	buffer.writeString("align");
	buffer.writeInt32(4);
	buffer.writeInt32(this.align);
	buffer.writeString("valign");
	buffer.writeInt32(4);
	buffer.writeInt32(this.valign);
	buffer.writeString("");
}
TextObject.prototype.deserialize_external = function(buffer) {
	let text_is_set = false, font_is_set = false, color_is_set = false, align_is_set = false, valign_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "font":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.font = _objectCache[index];
				} else {
					let font = this.font
					if(!font || font._objectIndex != -index)
						this.font = font = new _Font();
					(_objectCache[-index] = font).deserialize_external(buffer);
				}
				font_is_set = true;
				break;
			case "color":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.color = _objectCache[index];
				} else {
					let color = this.color
					if(!color || color._objectIndex != -index)
						this.color = color = new _Color();
					(_objectCache[-index] = color).deserialize_external(buffer);
				}
				color_is_set = true;
				break;
			case "align":
				buffer.readInt32();
				this.align = buffer.readInt32();
				align_is_set = true;
				break;
			case "valign":
				buffer.readInt32();
				this.valign = buffer.readInt32();
				valign_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!text_is_set) this.text = "";
				if(!font_is_set) this.font = null;
				if(!color_is_set) this.color = Color_White;
				if(!align_is_set) this.align = 1/*Center*/;
				if(!valign_is_set) this.valign = 1/*Middle*/;
				return;
		}
	}
}
function ImageObject(position, size, alpha, visibleFor, layer, locked, location, image, angle) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "ImageObject";
	this.image = image;
	this.angle = angle;
	if(this.size.x == 0 && this.size.y == 0) {
		this.size = this.image.size?.clone();
	}
}
function __ImageObjectPrototype() { this.constructor = ImageObject; }
__ImageObjectPrototype.prototype = $Object.prototype;
ImageObject.prototype = new __ImageObjectPrototype();
ImageObject.prototype.tick = function() {
	graphics_drawImage2(this.image, this.position, this.size, this.visibleFor, 0, this.layer, this.alpha, Color_White, this.angle, false, false, null);
}
ImageObject.prototype.clone = function() {
	let clone = new _ImageObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	clone.angle = this.angle;
	return clone;
}
function _ImageObject() {};
_ImageObject.prototype = ImageObject.prototype;
ImageObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.angle);
}
ImageObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.angle = buffer.readFloat64();
}
ImageObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("angle");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.angle);
	buffer.writeString("");
}
ImageObject.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, angle_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "angle":
				buffer.readInt32();
				this.angle = buffer.readFloat64();
				angle_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!angle_is_set) this.angle = 0.0;
				return;
		}
	}
}
function Effect(position, size, alpha, visibleFor, layer, locked, location, image, framesPerSecond) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "Effect";
	this.image = image;
	this.framesPerSecond = framesPerSecond;
	this.startFrame = core_frame;
	if(this.size.x == 0 && this.size.y == 0) {
		this.size = this.image.size?.clone();
	}
}
function __EffectPrototype() { this.constructor = Effect; }
__EffectPrototype.prototype = $Object.prototype;
Effect.prototype = new __EffectPrototype();
Effect.prototype.tick = function() {
	let frame = Math.floor((core_frame - this.startFrame) * Math.max(this.framesPerSecond, 0) / core_targetFps);
	if(frame < this.image.frames.length) {
		graphics_drawImage(this.image, this.position, this.size, this.visibleFor, frame, this.layer, this.alpha, Color_White, 1/*Center*/, 1/*Middle*/, this.location);
	} else {
		Framework_objects.remove(this);
	}
}
Effect.prototype.clone = function() {
	let clone = new _Effect();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	clone.framesPerSecond = this.framesPerSecond;
	clone.startFrame = this.startFrame;
	return clone;
}
function _Effect() {};
_Effect.prototype = Effect.prototype;
Effect.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.framesPerSecond);
	buffer.writeInt32(this.startFrame);
}
Effect.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.framesPerSecond = buffer.readInt32();
	this.startFrame = buffer.readInt32();
}
Effect.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("framesPerSecond");
	buffer.writeInt32(4);
	buffer.writeInt32(this.framesPerSecond);
	buffer.writeString("startFrame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.startFrame);
	buffer.writeString("");
}
Effect.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, framesPerSecond_is_set = false, startFrame_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "framesPerSecond":
				buffer.readInt32();
				this.framesPerSecond = buffer.readInt32();
				framesPerSecond_is_set = true;
				break;
			case "startFrame":
				buffer.readInt32();
				this.startFrame = buffer.readInt32();
				startFrame_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!framesPerSecond_is_set) this.framesPerSecond = 15;
				if(!startFrame_is_set) this.startFrame = core_frame;
				return;
		}
	}
}
function VideoObject(position, size, alpha, visibleFor, layer, locked, location, player, shape) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "VideoObject";
	this.player = player;
	this.shape = shape;
}
function __VideoObjectPrototype() { this.constructor = VideoObject; }
__VideoObjectPrototype.prototype = $Object.prototype;
VideoObject.prototype = new __VideoObjectPrototype();
VideoObject.prototype.tick = function() {
	graphics_drawVideo(this.player, this.position, this.size, this.shape, null, null);
}
VideoObject.prototype.clone = function() {
	let clone = new _VideoObject();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.player = this.player;
	clone.shape = this.shape;
	return clone;
}
function _VideoObject() {};
_VideoObject.prototype = VideoObject.prototype;
VideoObject.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.shape);
}
VideoObject.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.player = _objectCache[index];
	} else {
		let player = this.player
		if(!player || player._objectIndex != -index)
			this.player = player = new _Player();
		(_objectCache[-index] = player).deserialize_internal(buffer);
	}
	this.shape = buffer.readInt32();
}
VideoObject.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("player");
	let player_startPos = buffer.reserveSize();
	let player = this.player
	if(player) {
		var index = _objectCacheIndex.get(player);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(player, index = _objectCache.length);
			_objectCache.push(player);
			buffer.writeInt32(-index);
			player._objectIndex = index;
			player.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(player_startPos);
	buffer.writeString("shape");
	buffer.writeInt32(4);
	buffer.writeInt32(this.shape);
	buffer.writeString("");
}
VideoObject.prototype.deserialize_external = function(buffer) {
	let player_is_set = false, shape_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "player":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.player = _objectCache[index];
				} else {
					let player = this.player
					if(!player || player._objectIndex != -index)
						this.player = player = new _Player();
					(_objectCache[-index] = player).deserialize_external(buffer);
				}
				player_is_set = true;
				break;
			case "shape":
				buffer.readInt32();
				this.shape = buffer.readInt32();
				shape_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!player_is_set) this.player = null;
				if(!shape_is_set) this.shape = 0/*Rectangle*/;
				return;
		}
	}
}
function Button(position, size, alpha, visibleFor, layer, locked, location, image, text, textColor, frame, fontSize, touchMargin, textOffset, showTouchArea, clickableBy, enabled, alphaWhenDisabled, hotkey, onClick) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "Button";
	this.image = image;
	this.text = text;
	this.textColor = textColor;
	this.frame = frame;
	this.fontSize = fontSize;
	this.touchMargin = touchMargin?.clone();
	this.textOffset = textOffset?.clone();
	this.showTouchArea = showTouchArea;
	this.clickableBy = clickableBy;
	this.enabled = enabled;
	this.alphaWhenDisabled = alphaWhenDisabled;
	this.hotkey = hotkey;
	this.onClick = onClick;
}
function __ButtonPrototype() { this.constructor = Button; }
__ButtonPrototype.prototype = $Object.prototype;
Button.prototype = new __ButtonPrototype();
Button.prototype.tick = function() {
	graphics_drawButton(this.image, this.text, this.position, this.size, this.frame, this.textColor, this.fontSize, this.textOffset, this.touchMargin, this.showTouchArea, this.visibleFor, this.clickableBy, this.hotkey, this.layer, this.alpha, this.enabled, this.alphaWhenDisabled, touch => {
		this.onClick.invoke(touch);
	}, null);
}
Button.prototype.clone = function() {
	let clone = new _Button();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.image = this.image;
	clone.text = this.text;
	clone.textColor = this.textColor;
	clone.frame = this.frame;
	clone.fontSize = this.fontSize;
	clone.touchMargin = this.touchMargin.clone();
	clone.textOffset = this.textOffset.clone();
	clone.showTouchArea = this.showTouchArea;
	clone.clickableBy = this.clickableBy;
	clone.enabled = this.enabled;
	clone.alphaWhenDisabled = this.alphaWhenDisabled;
	clone.hotkey = this.hotkey;
	clone.onClick = this.onClick;
	return clone;
}
function _Button() {};
_Button.prototype = Button.prototype;
Button.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeString(this.text);
	let textColor = this.textColor
	if(textColor) {
		var index = _objectCacheIndex.get(textColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(textColor, index = _objectCache.length);
			_objectCache.push(textColor);
			buffer.writeInt32(-index);
			textColor._objectIndex = index;
			textColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.frame);
	buffer.writeInt32(this.fontSize);
	(this.touchMargin || new _Vector2()).serialize_internal(buffer);
	(this.textOffset || new _Vector2()).serialize_internal(buffer);
	buffer.writeBool(this.showTouchArea);
	let clickableBy = this.clickableBy
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.enabled);
	buffer.writeFloat64(this.alphaWhenDisabled);
	buffer.writeInt32(this.hotkey);
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Button.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.text = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.textColor = _objectCache[index];
	} else {
		let textColor = this.textColor
		if(!textColor || textColor._objectIndex != -index)
			this.textColor = textColor = new _Color();
		(_objectCache[-index] = textColor).deserialize_internal(buffer);
	}
	this.frame = buffer.readInt32();
	this.fontSize = buffer.readInt32();
	(this.touchMargin || (this.touchMargin = new _Vector2())).deserialize_internal(buffer);
	(this.textOffset || (this.textOffset = new _Vector2())).deserialize_internal(buffer);
	this.showTouchArea = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.clickableBy = _objectCache[index];
	} else {
		let clickableBy = this.clickableBy
		if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
		_objectCache[-index] = clickableBy;
		for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					clickableBy[i] = _objectCache[index];
				} else {
					let clickableBy_item = clickableBy[i]
					if(!clickableBy_item || clickableBy_item._objectIndex != -index)
						clickableBy[i] = clickableBy_item = new _Player();
					(_objectCache[-index] = clickableBy_item).deserialize_internal(buffer);
				}
		}
	}
	this.enabled = buffer.readBool();
	this.alphaWhenDisabled = buffer.readFloat64();
	this.hotkey = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onClick = _objectCache[index];
	} else {
		let onClick = this.onClick
		let _id = buffer.readInt32();
		if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
			this.onClick = onClick = new _lambdaContructors[_id]();
		onClick._id = _id;
		(_objectCache[-index] = onClick).deserialize_internal(buffer);
	}
}
Button.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("text");
	buffer.writeString(this.text);
	buffer.writeString("textColor");
	let textColor_startPos = buffer.reserveSize();
	let textColor = this.textColor
	if(textColor) {
		var index = _objectCacheIndex.get(textColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(textColor, index = _objectCache.length);
			_objectCache.push(textColor);
			buffer.writeInt32(-index);
			textColor._objectIndex = index;
			textColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(textColor_startPos);
	buffer.writeString("frame");
	buffer.writeInt32(4);
	buffer.writeInt32(this.frame);
	buffer.writeString("fontSize");
	buffer.writeInt32(4);
	buffer.writeInt32(this.fontSize);
	buffer.writeString("touchMargin");
	let touchMargin_startPos = buffer.reserveSize();
	(this.touchMargin || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(touchMargin_startPos);
	buffer.writeString("textOffset");
	let textOffset_startPos = buffer.reserveSize();
	(this.textOffset || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(textOffset_startPos);
	buffer.writeString("showTouchArea");
	buffer.writeInt32(1);
	buffer.writeBool(this.showTouchArea);
	buffer.writeString("clickableBy");
	let clickableBy = this.clickableBy
	let clickableBy_startPos = buffer.reserveSize();
	if(clickableBy) {
		var index = _objectCacheIndex.get(clickableBy);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(clickableBy, index = _objectCache.length);
			_objectCache.push(clickableBy);
			buffer.writeInt32(-index);
			clickableBy._objectIndex = index;
			buffer.writeInt32(clickableBy.length);
			for(let i=0, len=clickableBy.length; i<len; ++i) {
				let clickableBy_item = clickableBy[i]
				if(clickableBy_item) {
					var index = _objectCacheIndex.get(clickableBy_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(clickableBy_item, index = _objectCache.length);
						_objectCache.push(clickableBy_item);
						buffer.writeInt32(-index);
						clickableBy_item._objectIndex = index;
						clickableBy_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(clickableBy_startPos);
	buffer.writeString("enabled");
	buffer.writeInt32(1);
	buffer.writeBool(this.enabled);
	buffer.writeString("alphaWhenDisabled");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.alphaWhenDisabled);
	buffer.writeString("hotkey");
	buffer.writeInt32(4);
	buffer.writeInt32(this.hotkey);
	buffer.writeString("onClick");
	let onClick_startPos = buffer.reserveSize();
	let onClick = this.onClick
	if(onClick) {
		var index = _objectCacheIndex.get(onClick);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onClick, index = _objectCache.length);
			_objectCache.push(onClick);
			buffer.writeInt32(-index);
			buffer.writeInt32(onClick._id);
			onClick._objectIndex = index;
			onClick.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onClick_startPos);
	buffer.writeString("");
}
Button.prototype.deserialize_external = function(buffer) {
	let image_is_set = false, text_is_set = false, textColor_is_set = false, frame_is_set = false, fontSize_is_set = false, touchMargin_is_set = false, textOffset_is_set = false, showTouchArea_is_set = false, clickableBy_is_set = false, enabled_is_set = false, alphaWhenDisabled_is_set = false, hotkey_is_set = false, onClick_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "text":
				this.text = buffer.readString();
				text_is_set = true;
				break;
			case "textColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.textColor = _objectCache[index];
				} else {
					let textColor = this.textColor
					if(!textColor || textColor._objectIndex != -index)
						this.textColor = textColor = new _Color();
					(_objectCache[-index] = textColor).deserialize_external(buffer);
				}
				textColor_is_set = true;
				break;
			case "frame":
				buffer.readInt32();
				this.frame = buffer.readInt32();
				frame_is_set = true;
				break;
			case "fontSize":
				buffer.readInt32();
				this.fontSize = buffer.readInt32();
				fontSize_is_set = true;
				break;
			case "touchMargin":
				buffer.readInt32();
				(this.touchMargin || (this.touchMargin = new _Vector2())).deserialize_external(buffer);
				touchMargin_is_set = true;
				break;
			case "textOffset":
				buffer.readInt32();
				(this.textOffset || (this.textOffset = new _Vector2())).deserialize_external(buffer);
				textOffset_is_set = true;
				break;
			case "showTouchArea":
				buffer.readInt32();
				this.showTouchArea = buffer.readBool();
				showTouchArea_is_set = true;
				break;
			case "clickableBy":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.clickableBy = _objectCache[index];
				} else {
					let clickableBy = this.clickableBy
					if(!clickableBy || clickableBy._objectIndex != -index) this.clickableBy = clickableBy = [];
					_objectCache[-index] = clickableBy;
					for(let i=0, len = clickableBy.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								clickableBy[i] = _objectCache[index];
							} else {
								let clickableBy_item = clickableBy[i]
								if(!clickableBy_item || clickableBy_item._objectIndex != -index)
									clickableBy[i] = clickableBy_item = new _Player();
								(_objectCache[-index] = clickableBy_item).deserialize_external(buffer);
							}
					}
				}
				clickableBy_is_set = true;
				break;
			case "enabled":
				buffer.readInt32();
				this.enabled = buffer.readBool();
				enabled_is_set = true;
				break;
			case "alphaWhenDisabled":
				buffer.readInt32();
				this.alphaWhenDisabled = buffer.readFloat64();
				alphaWhenDisabled_is_set = true;
				break;
			case "hotkey":
				buffer.readInt32();
				this.hotkey = buffer.readInt32();
				hotkey_is_set = true;
				break;
			case "onClick":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onClick = _objectCache[index];
				} else {
					let onClick = this.onClick
					let _id = buffer.readInt32();
					if(!onClick || onClick._id != _id || onClick._objectIndex != -index)
						this.onClick = onClick = new _lambdaContructors[_id]();
					onClick._id = _id;
					(_objectCache[-index] = onClick).deserialize_external(buffer);
				}
				onClick_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!image_is_set) this.image = null;
				if(!text_is_set) this.text = "";
				if(!textColor_is_set) this.textColor = Color_White;
				if(!frame_is_set) this.frame = 0;
				if(!fontSize_is_set) this.fontSize = 18;
				if(!touchMargin_is_set) this.touchMargin = new Vector2(16, 16);
				if(!textOffset_is_set) this.textOffset = new Vector2(0, 0);
				if(!showTouchArea_is_set) this.showTouchArea = false;
				if(!clickableBy_is_set) this.clickableBy = null;
				if(!enabled_is_set) this.enabled = true;
				if(!alphaWhenDisabled_is_set) this.alphaWhenDisabled = .5;
				if(!hotkey_is_set) this.hotkey = 0/*None*/;
				if(!onClick_is_set) this.onClick = null;
				return;
		}
	}
}
function ParticleSystem(position, size, alpha, visibleFor, layer, locked, location, image, minSpeed, maxSpeed, particlesPerBurst, burstInterval, nextBurst, bursts, gravity, maxRotationSpeed, mode) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "ParticleSystem";
	this.particles = [];
	this.image = image;
	this.minSpeed = minSpeed;
	this.maxSpeed = maxSpeed;
	this.particlesPerBurst = particlesPerBurst;
	this.burstInterval = burstInterval;
	this.nextBurst = nextBurst;
	this.bursts = bursts;
	this.gravity = gravity;
	this.maxRotationSpeed = maxRotationSpeed;
	this.mode = mode;
	this.burst = 0;
}
function __ParticleSystemPrototype() { this.constructor = ParticleSystem; }
__ParticleSystemPrototype.prototype = $Object.prototype;
ParticleSystem.prototype = new __ParticleSystemPrototype();
ParticleSystem.prototype.debugString = function() {
	$Object.prototype.debugString.call(this);
	return "(ParticleSystem "+this.position.x?.toString()+" "+this.position.y?.toString()+" "+this.particles.length?.toString()+")";
}
ParticleSystem.prototype.tick = function() {
	if(Time_now>this.nextBurst) {
		if(this.mode == 1/*OneParticlePerImageFrame*/) {
			for(let i=0; i<this.image.frames.length; ++i) {
				let angle = -math_randomFloat2(.5);
				let speedFactor = math_randomFloat(this.minSpeed, this.maxSpeed);
				this.particles.push(new Particle(this.position, math_getVectorForAngle(angle, speedFactor), 0, math_randomFloat(-this.maxRotationSpeed, this.maxRotationSpeed), i));
			}
			this.nextBurst = Number.MAX_VALUE;
		} else {
			for(let i=0; i<this.particlesPerBurst; ++i) {
				let angle = -math_randomFloat2(1.0);
				let speedFactor = math_randomFloat(this.minSpeed, this.maxSpeed);
				this.particles.push(new Particle(this.position, math_getVectorForAngle(angle, speedFactor), angle, math_randomFloat(-this.maxRotationSpeed, this.maxRotationSpeed), math_randomInteger2(this.image.frames.length)));
			}
			this.nextBurst = (++this.burst < this.bursts ? Time_now+this.burstInterval : Number.MAX_VALUE);
		}
	}
	for(let _subject=this.particles, i=_subject.length-1; i>=0; --i) { let it = _subject[i]; {
		graphics_move(it.pos, () => {
			graphics_rotate(it.angle, () => {
				graphics_drawImage(this.image, new Vector2(0.0, 0.0, null), new Vector2(0.0, 0.0, null), null, it.frame, 0, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
			});
		});
		Vector2_plusAssign_Vector2(it.pos, it.speed);
		it.speed.y += this.gravity;
		it.angle += it.rotationSpeed;
		if(it.pos.y > graphics_size.y / 2) {
			this.particles.splice(i, 1);
		}
	}}
	if(this.particles.length == 0) {
		this.removeImmediately();
	}
}
ParticleSystem.prototype.clone = function() {
	let clone = new _ParticleSystem();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.particles = this.particles;
	clone.image = this.image;
	clone.minSpeed = this.minSpeed;
	clone.maxSpeed = this.maxSpeed;
	clone.particlesPerBurst = this.particlesPerBurst;
	clone.burstInterval = this.burstInterval;
	clone.nextBurst = this.nextBurst;
	clone.bursts = this.bursts;
	clone.gravity = this.gravity;
	clone.maxRotationSpeed = this.maxRotationSpeed;
	clone.mode = this.mode;
	clone.burst = this.burst;
	return clone;
}
function _ParticleSystem() {};
_ParticleSystem.prototype = ParticleSystem.prototype;
ParticleSystem.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	let particles = this.particles
	if(particles) {
		var index = _objectCacheIndex.get(particles);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particles, index = _objectCache.length);
			_objectCache.push(particles);
			buffer.writeInt32(-index);
			particles._objectIndex = index;
			buffer.writeInt32(particles.length);
			for(let i=0, len=particles.length; i<len; ++i) {
				(particles[i] || new _Particle()).serialize_internal(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeFloat64(this.minSpeed);
	buffer.writeFloat64(this.maxSpeed);
	buffer.writeInt32(this.particlesPerBurst);
	buffer.writeInt32(this.burstInterval);
	buffer.writeFloat64(this.nextBurst);
	buffer.writeInt32(this.bursts);
	buffer.writeFloat64(this.gravity);
	buffer.writeFloat64(this.maxRotationSpeed);
	buffer.writeInt32(this.mode);
	buffer.writeInt32(this.burst);
}
ParticleSystem.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.particles = _objectCache[index];
	} else {
		let particles = this.particles
		if(!particles || particles._objectIndex != -index) this.particles = particles = [];
		_objectCache[-index] = particles;
		for(let i=0, len = particles.length = buffer.readInt32(); i<len; ++i) {
				(particles[i] || (particles[i] = new _Particle())).deserialize_internal(buffer);
		}
	}
	var index = buffer.readInt32();
	if(index >= 0) {
		this.image = _objectCache[index];
	} else {
		let image = this.image
		if(!image || image._objectIndex != -index)
			this.image = image = new _Image();
		(_objectCache[-index] = image).deserialize_internal(buffer);
	}
	this.minSpeed = buffer.readFloat64();
	this.maxSpeed = buffer.readFloat64();
	this.particlesPerBurst = buffer.readInt32();
	this.burstInterval = buffer.readInt32();
	this.nextBurst = buffer.readFloat64();
	this.bursts = buffer.readInt32();
	this.gravity = buffer.readFloat64();
	this.maxRotationSpeed = buffer.readFloat64();
	this.mode = buffer.readInt32();
	this.burst = buffer.readInt32();
}
ParticleSystem.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("particles");
	let particles = this.particles
	let particles_startPos = buffer.reserveSize();
	if(particles) {
		var index = _objectCacheIndex.get(particles);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(particles, index = _objectCache.length);
			_objectCache.push(particles);
			buffer.writeInt32(-index);
			particles._objectIndex = index;
			buffer.writeInt32(particles.length);
			for(let i=0, len=particles.length; i<len; ++i) {
				(particles[i] || new _Particle()).serialize_external(buffer);
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(particles_startPos);
	buffer.writeString("image");
	let image_startPos = buffer.reserveSize();
	let image = this.image
	if(image) {
		var index = _objectCacheIndex.get(image);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(image, index = _objectCache.length);
			_objectCache.push(image);
			buffer.writeInt32(-index);
			image._objectIndex = index;
			image.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(image_startPos);
	buffer.writeString("minSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.minSpeed);
	buffer.writeString("maxSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.maxSpeed);
	buffer.writeString("particlesPerBurst");
	buffer.writeInt32(4);
	buffer.writeInt32(this.particlesPerBurst);
	buffer.writeString("burstInterval");
	buffer.writeInt32(4);
	buffer.writeInt32(this.burstInterval);
	buffer.writeString("nextBurst");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.nextBurst);
	buffer.writeString("bursts");
	buffer.writeInt32(4);
	buffer.writeInt32(this.bursts);
	buffer.writeString("gravity");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.gravity);
	buffer.writeString("maxRotationSpeed");
	buffer.writeInt32(8);
	buffer.writeFloat64(this.maxRotationSpeed);
	buffer.writeString("mode");
	buffer.writeInt32(4);
	buffer.writeInt32(this.mode);
	buffer.writeString("burst");
	buffer.writeInt32(4);
	buffer.writeInt32(this.burst);
	buffer.writeString("");
}
ParticleSystem.prototype.deserialize_external = function(buffer) {
	let particles_is_set = false, image_is_set = false, minSpeed_is_set = false, maxSpeed_is_set = false, particlesPerBurst_is_set = false, burstInterval_is_set = false, nextBurst_is_set = false, bursts_is_set = false, gravity_is_set = false, maxRotationSpeed_is_set = false, mode_is_set = false, burst_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "particles":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.particles = _objectCache[index];
				} else {
					let particles = this.particles
					if(!particles || particles._objectIndex != -index) this.particles = particles = [];
					_objectCache[-index] = particles;
					for(let i=0, len = particles.length = buffer.readInt32(); i<len; ++i) {
							(particles[i] || (particles[i] = new _Particle())).deserialize_external(buffer);
					}
				}
				particles_is_set = true;
				break;
			case "image":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.image = _objectCache[index];
				} else {
					let image = this.image
					if(!image || image._objectIndex != -index)
						this.image = image = new _Image();
					(_objectCache[-index] = image).deserialize_external(buffer);
				}
				image_is_set = true;
				break;
			case "minSpeed":
				buffer.readInt32();
				this.minSpeed = buffer.readFloat64();
				minSpeed_is_set = true;
				break;
			case "maxSpeed":
				buffer.readInt32();
				this.maxSpeed = buffer.readFloat64();
				maxSpeed_is_set = true;
				break;
			case "particlesPerBurst":
				buffer.readInt32();
				this.particlesPerBurst = buffer.readInt32();
				particlesPerBurst_is_set = true;
				break;
			case "burstInterval":
				buffer.readInt32();
				this.burstInterval = buffer.readInt32();
				burstInterval_is_set = true;
				break;
			case "nextBurst":
				buffer.readInt32();
				this.nextBurst = buffer.readFloat64();
				nextBurst_is_set = true;
				break;
			case "bursts":
				buffer.readInt32();
				this.bursts = buffer.readInt32();
				bursts_is_set = true;
				break;
			case "gravity":
				buffer.readInt32();
				this.gravity = buffer.readFloat64();
				gravity_is_set = true;
				break;
			case "maxRotationSpeed":
				buffer.readInt32();
				this.maxRotationSpeed = buffer.readFloat64();
				maxRotationSpeed_is_set = true;
				break;
			case "mode":
				buffer.readInt32();
				this.mode = buffer.readInt32();
				mode_is_set = true;
				break;
			case "burst":
				buffer.readInt32();
				this.burst = buffer.readInt32();
				burst_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!particles_is_set) this.particles = [];
				if(!image_is_set) this.image = Image_starParticle;
				if(!minSpeed_is_set) this.minSpeed = 10.0;
				if(!maxSpeed_is_set) this.maxSpeed = 25.0;
				if(!particlesPerBurst_is_set) this.particlesPerBurst = 30;
				if(!burstInterval_is_set) this.burstInterval = 500;
				if(!nextBurst_is_set) this.nextBurst = (-1);
				if(!bursts_is_set) this.bursts = 10;
				if(!gravity_is_set) this.gravity = 1.0;
				if(!maxRotationSpeed_is_set) this.maxRotationSpeed = .05;
				if(!mode_is_set) this.mode = 0/*Burst*/;
				if(!burst_is_set) this.burst = 0;
				return;
		}
	}
}
function Lambda3() {
	this._id = 3;
}
Lambda3.prototype.invoke = function(value, touch) {
	core_restart();
}
Lambda3.prototype.serialize_internal = function(buffer) {
}
Lambda3.prototype.deserialize_internal = function(buffer) {
}
Lambda3.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda3.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda3() {
	this._id = 3;
};
_Lambda3.prototype = Lambda3.prototype;
function Lambda4() {
	this._id = 4;
}
Lambda4.prototype.invoke = function(value, touch) {
	core_saveEventStreamAndLogs();
}
Lambda4.prototype.serialize_internal = function(buffer) {
}
Lambda4.prototype.deserialize_internal = function(buffer) {
}
Lambda4.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda4.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda4() {
	this._id = 4;
};
_Lambda4.prototype = Lambda4.prototype;
function Lambda5() {
	this._id = 5;
}
Lambda5.prototype.invoke = function(value, touch) {
	if(!Platform_isStaging && !Platform_isDebug && (touch.by == null || input_localUser?.id == touch.by.id)) {
		try {
			if(false) {
				document.body.requestFullscreen()
			} else {
				document.exitFullscreen()
			}
		} catch {
		}
	} ;
}
Lambda5.prototype.serialize_internal = function(buffer) {
}
Lambda5.prototype.deserialize_internal = function(buffer) {
}
Lambda5.prototype.serialize_external = function(buffer) {
	buffer.writeString("");
}
Lambda5.prototype.deserialize_external = function(buffer) {
	for(;;) {
		switch(buffer.readString()) {
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function _Lambda5() {
	this._id = 5;
};
_Lambda5.prototype = Lambda5.prototype;
function Menu(position, size, alpha, visibleFor, layer, locked, location, popupPosition, items, includeDefaultItems, overlayColor) {
	$Object.call(this, position, size, alpha, visibleFor, layer, locked, location);
	this.type = "Menu";
	this.popupPosition = popupPosition?.clone();
	this.items = items;
	this.includeDefaultItems = includeDefaultItems;
	this.overlayColor = overlayColor;
	this.active = false;
	if(this.includeDefaultItems) {
		this.items.splice(0, 0, new MenuItem(Image_New, "New Game", false, 0/*Button*/, new Lambda3()));
		this.items.push(new MenuItem(Image_Save, "Save Game", false, 0/*Button*/, new Lambda4()));
		this.items.push(new MenuItem(Image_Quit, "Exit Fullscreen", false, 0/*Button*/, new Lambda5()));
	}
}
function __MenuPrototype() { this.constructor = Menu; }
__MenuPrototype.prototype = $Object.prototype;
Menu.prototype = new __MenuPrototype();
Menu.prototype.tick = function() {
	let doNotClose = false;
	if(this.active) {
		for(let i=0, _subject=this.items, _center = this.popupPosition, _delta = new Vector2(0, 60, null), _len=_subject.length, _x = _center.x-(_len-1)*_delta.x/2, _y=_center.y-(_len-1)*_delta.y/2; i<_len; ++i, _x += _delta.x, _y += _delta.y) { let item = _subject[i], pos = new Vector2(_x, _y, _center.location || _delta.location ? new SourceCodeLocation(null, 0, 0, _center.location, _delta.location) : null); {
			graphics_drawText(item.label, Vector2_plus_Vector2(pos, new Vector2(-60, 0.0, null)), new Vector2(30, 0, null), null, 0/*Left*/, 1/*Middle*/, 0/*Normal*/, null, null, 0, null, int_maxValue, 1.0, null);
			if(item.type == 0/*Button*/) {
				if((item.image != null)) {
					graphics_drawImage(item.image, Vector2_plus_Vector2(pos, new Vector2(-120, 0.0, null)), new Vector2(0.0, 0.0, null), null, 0, int_maxValue, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
				}
				input_onTouchDownWithin(pos, new Vector2(500, 60, null), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
					item.onClick.invoke(true, touch);
				});
			} else {
				if(item.type == 1/*Check*/) {
					graphics_drawImage(item.image || Image_Checkbox, Vector2_plus_Vector2(pos, new Vector2(-120, 0.0, null)), new Vector2(0.0, 0.0, null), null, (item.value ? 1 : 0), int_maxValue, 1.0, Color_White, 1/*Center*/, 1/*Middle*/, null);
					input_onTouchDownWithin(pos, new Vector2(500, 60, null), null, "auto", false, true, 1/*Center*/, 1/*Middle*/, touch => {
						item.value = !item.value;
						item.onClick.invoke(item.value, touch);
						doNotClose = true;
					});
				}
			}
		}}
		graphics_drawRectangle(this.popupPosition, new Vector2(500, 60 + this.items.length * 60, null), Color_Black, Color_White, 3, null, int_maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
		graphics_drawRectangle(new Vector2(0.0, 0.0, null), new Vector2(1920, 1080, null), this.overlayColor, null, 0, null, int_maxValue, 1.0, 1/*Center*/, 1/*Middle*/, null);
		if(!doNotClose) {
			input_onTouchDownAny(null, touch => {
				this.active = false;
			});
		}
	}
	graphics_drawImage5(Image_Menu, this.position, new Vector2(0.0, 0.0, null), null, null, 0, 0, 1.0, Color_White, 0.0, new Vector2(16, 16, null), false, 0/*None*/, touch => {
		this.active = true;
	}, this.location);
}
Menu.prototype.clone = function() {
	let clone = new _Menu();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.alpha = this.alpha;
	clone.visibleFor = this.visibleFor;
	clone.layer = this.layer;
	clone.locked = this.locked;
	clone.location = this.location;
	clone.popupPosition = this.popupPosition.clone();
	clone.items = this.items;
	clone.includeDefaultItems = this.includeDefaultItems;
	clone.overlayColor = this.overlayColor;
	clone.active = this.active;
	return clone;
}
function _Menu() {};
_Menu.prototype = Menu.prototype;
Menu.prototype.serialize_internal = function(buffer) {
	$Object.prototype.serialize_internal.call(this, buffer);
	(this.popupPosition || new _Vector2()).serialize_internal(buffer);
	let items = this.items
	if(items) {
		var index = _objectCacheIndex.get(items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(items, index = _objectCache.length);
			_objectCache.push(items);
			buffer.writeInt32(-index);
			items._objectIndex = index;
			buffer.writeInt32(items.length);
			for(let i=0, len=items.length; i<len; ++i) {
				let items_item = items[i]
				if(items_item) {
					var index = _objectCacheIndex.get(items_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(items_item, index = _objectCache.length);
						_objectCache.push(items_item);
						buffer.writeInt32(-index);
						items_item._objectIndex = index;
						items_item.serialize_internal(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.includeDefaultItems);
	let overlayColor = this.overlayColor
	if(overlayColor) {
		var index = _objectCacheIndex.get(overlayColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(overlayColor, index = _objectCache.length);
			_objectCache.push(overlayColor);
			buffer.writeInt32(-index);
			overlayColor._objectIndex = index;
			overlayColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeBool(this.active);
}
Menu.prototype.deserialize_internal = function(buffer) {
	$Object.prototype.deserialize_internal.call(this, buffer);
	(this.popupPosition || (this.popupPosition = new _Vector2())).deserialize_internal(buffer);
	var index = buffer.readInt32();
	if(index >= 0) {
		this.items = _objectCache[index];
	} else {
		let items = this.items
		if(!items || items._objectIndex != -index) this.items = items = [];
		_objectCache[-index] = items;
		for(let i=0, len = items.length = buffer.readInt32(); i<len; ++i) {
				var index = buffer.readInt32();
				if(index >= 0) {
					items[i] = _objectCache[index];
				} else {
					let items_item = items[i]
					if(!items_item || items_item._objectIndex != -index)
						items[i] = items_item = new _MenuItem();
					(_objectCache[-index] = items_item).deserialize_internal(buffer);
				}
		}
	}
	this.includeDefaultItems = buffer.readBool();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.overlayColor = _objectCache[index];
	} else {
		let overlayColor = this.overlayColor
		if(!overlayColor || overlayColor._objectIndex != -index)
			this.overlayColor = overlayColor = new _Color();
		(_objectCache[-index] = overlayColor).deserialize_internal(buffer);
	}
	this.active = buffer.readBool();
}
Menu.prototype.serialize_external = function(buffer) {
	$Object.prototype.serialize_external.call(this, buffer);
	buffer.writeString("popupPosition");
	let popupPosition_startPos = buffer.reserveSize();
	(this.popupPosition || new _Vector2()).serialize_external(buffer);
	buffer.writeSize(popupPosition_startPos);
	buffer.writeString("items");
	let items = this.items
	let items_startPos = buffer.reserveSize();
	if(items) {
		var index = _objectCacheIndex.get(items);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(items, index = _objectCache.length);
			_objectCache.push(items);
			buffer.writeInt32(-index);
			items._objectIndex = index;
			buffer.writeInt32(items.length);
			for(let i=0, len=items.length; i<len; ++i) {
				let items_item = items[i]
				if(items_item) {
					var index = _objectCacheIndex.get(items_item);
					if(index) {
						buffer.writeInt32(index);
					} else {
						_objectCacheIndex.set(items_item, index = _objectCache.length);
						_objectCache.push(items_item);
						buffer.writeInt32(-index);
						items_item._objectIndex = index;
						items_item.serialize_external(buffer);
					}
				} else {
					buffer.writeInt32(0);
				}
			}
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(items_startPos);
	buffer.writeString("includeDefaultItems");
	buffer.writeInt32(1);
	buffer.writeBool(this.includeDefaultItems);
	buffer.writeString("overlayColor");
	let overlayColor_startPos = buffer.reserveSize();
	let overlayColor = this.overlayColor
	if(overlayColor) {
		var index = _objectCacheIndex.get(overlayColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(overlayColor, index = _objectCache.length);
			_objectCache.push(overlayColor);
			buffer.writeInt32(-index);
			overlayColor._objectIndex = index;
			overlayColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(overlayColor_startPos);
	buffer.writeString("active");
	buffer.writeInt32(1);
	buffer.writeBool(this.active);
	buffer.writeString("");
}
Menu.prototype.deserialize_external = function(buffer) {
	let popupPosition_is_set = false, items_is_set = false, includeDefaultItems_is_set = false, overlayColor_is_set = false, active_is_set = false;
	$Object.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "popupPosition":
				buffer.readInt32();
				(this.popupPosition || (this.popupPosition = new _Vector2())).deserialize_external(buffer);
				popupPosition_is_set = true;
				break;
			case "items":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.items = _objectCache[index];
				} else {
					let items = this.items
					if(!items || items._objectIndex != -index) this.items = items = [];
					_objectCache[-index] = items;
					for(let i=0, len = items.length = buffer.readInt32(); i<len; ++i) {
							var index = buffer.readInt32();
							if(index >= 0) {
								items[i] = _objectCache[index];
							} else {
								let items_item = items[i]
								if(!items_item || items_item._objectIndex != -index)
									items[i] = items_item = new _MenuItem();
								(_objectCache[-index] = items_item).deserialize_external(buffer);
							}
					}
				}
				items_is_set = true;
				break;
			case "includeDefaultItems":
				buffer.readInt32();
				this.includeDefaultItems = buffer.readBool();
				includeDefaultItems_is_set = true;
				break;
			case "overlayColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.overlayColor = _objectCache[index];
				} else {
					let overlayColor = this.overlayColor
					if(!overlayColor || overlayColor._objectIndex != -index)
						this.overlayColor = overlayColor = new _Color();
					(_objectCache[-index] = overlayColor).deserialize_external(buffer);
				}
				overlayColor_is_set = true;
				break;
			case "active":
				buffer.readInt32();
				this.active = buffer.readBool();
				active_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!popupPosition_is_set) this.popupPosition = new Vector2(0.0, 0.0, null);
				if(!items_is_set) this.items = [];
				if(!includeDefaultItems_is_set) this.includeDefaultItems = true;
				if(!overlayColor_is_set) this.overlayColor = new Color("#000000b0");
				if(!active_is_set) this.active = false;
				return;
		}
	}
}
function Lambda6(_this) {
	this._id = 6;
	this._this = _this;
}
Lambda6.prototype.invoke = function(data) {
	this._this.value = data;
	if(!core_isPremiere) {
		this._this.element.value = data;
	}
}
Lambda6.prototype.serialize_internal = function(buffer) {
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda6.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this._this = _objectCache[index];
	} else {
		let _this = this._this
		let type = buffer.readString();
		if(!_this || _this._objectIndex != -index)
			this._this = _this = new_HTMLElement_of_type(type);
		_this.type = type;
		(_objectCache[-index] = _this).deserialize_internal(buffer);
	}
}
Lambda6.prototype.serialize_external = function(buffer) {
	buffer.writeString("_this");
	let _this_startPos = buffer.reserveSize();
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_this_startPos);
	buffer.writeString("");
}
Lambda6.prototype.deserialize_external = function(buffer) {
	let _this_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "_this":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this._this = _objectCache[index];
				} else {
					let _this = this._this
					let type = buffer.readString();
					if(!_this || _this._objectIndex != -index)
						this._this = _this = new_HTMLElement_of_type(type);
					_this.type = type;
					(_objectCache[-index] = _this).deserialize_external(buffer);
				}
				_this_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!_this_is_set) this._this = null;
				return;
		}
	}
}
function _Lambda6() {
	this._id = 6;
};
_Lambda6.prototype = Lambda6.prototype;
function Lambda7(_this) {
	this._id = 7;
	this._this = _this;
}
Lambda7.prototype.invoke = function(data) {
	this._this.value = data;
	this._this.onEnterKey.invoke(data);
}
Lambda7.prototype.serialize_internal = function(buffer) {
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
}
Lambda7.prototype.deserialize_internal = function(buffer) {
	var index = buffer.readInt32();
	if(index >= 0) {
		this._this = _objectCache[index];
	} else {
		let _this = this._this
		let type = buffer.readString();
		if(!_this || _this._objectIndex != -index)
			this._this = _this = new_HTMLElement_of_type(type);
		_this.type = type;
		(_objectCache[-index] = _this).deserialize_internal(buffer);
	}
}
Lambda7.prototype.serialize_external = function(buffer) {
	buffer.writeString("_this");
	let _this_startPos = buffer.reserveSize();
	let _this = this._this
	if(_this) {
		var index = _objectCacheIndex.get(_this);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(_this, index = _objectCache.length);
			_objectCache.push(_this);
			buffer.writeInt32(-index);
			buffer.writeString(_this.type);
			_this._objectIndex = index;
			_this.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(_this_startPos);
	buffer.writeString("");
}
Lambda7.prototype.deserialize_external = function(buffer) {
	let _this_is_set = false;
	for(;;) {
		switch(buffer.readString()) {
			case "_this":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this._this = _objectCache[index];
				} else {
					let _this = this._this
					let type = buffer.readString();
					if(!_this || _this._objectIndex != -index)
						this._this = _this = new_HTMLElement_of_type(type);
					_this.type = type;
					(_objectCache[-index] = _this).deserialize_external(buffer);
				}
				_this_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				if(!_this_is_set) this._this = null;
				return;
		}
	}
}
function _Lambda7() {
	this._id = 7;
};
_Lambda7.prototype = Lambda7.prototype;
function HTMLInput(position, size, color, fontSize, borderColor, align, onEnterKey) {
	HTMLElement.call(this, position, size, color);
	this.type = "HTMLInput";
	this.fontSize = fontSize;
	this.borderColor = borderColor;
	this.align = align;
	this.value = "";
	this.onEnterKey = onEnterKey;
	this.changeCallbackId = 0;
	this.enterCallbackId = 0;
	this.changeCallbackId = networkData_addCallback(new Lambda6(this));
	this.enterCallbackId = networkData_addCallback(new Lambda7(this));
	this.ensureElement();
	this.focus();
}
function __HTMLInputPrototype() { this.constructor = HTMLInput; }
__HTMLInputPrototype.prototype = HTMLElement.prototype;
HTMLInput.prototype = new __HTMLInputPrototype();
HTMLInput.prototype.ensureElement = function() {
	if(this.element) return
	let alignString = this.align == 0 ? "left" : this.align == 1 ? "center" : "right";
	this.element = document.createElement("input")
	this.element.type = "text"
	this.element.style = "margin:0;padding:0 12px 0 12px;position:absolute;border:1px solid "+this.borderColor.hex+";text-align:"+alignString+";outline:none;background-color:#00000000"
	this.element.value = this.value
	let prevValue = this.value
	this.element.onkeyup = e => {
		let value = this.element.value
		if(value != prevValue) {
			input_handleString(this.changeCallbackId, value);
			prevValue = value;
		}
		if(e.keyCode == 13) {
			input_handleString(this.enterCallbackId, value);
		}
	}
	document.body.appendChild(this.element)
}
HTMLInput.prototype.remove = function() {
	this.element?.remove()
}
HTMLInput.prototype.focus = function() {
	this.element?.focus()
}
HTMLInput.prototype.tick = function() {
	HTMLElement.prototype.tick.call(this);
}
HTMLInput.prototype.clone = function() {
	let clone = new _HTMLInput();
	clone.type = this.type;
	clone.position = this.position.clone();
	clone.size = this.size.clone();
	clone.color = this.color;
	clone.element = this.element;
	clone.fontSize = this.fontSize;
	clone.borderColor = this.borderColor;
	clone.align = this.align;
	clone.value = this.value;
	clone.onEnterKey = this.onEnterKey;
	clone.changeCallbackId = this.changeCallbackId;
	clone.enterCallbackId = this.enterCallbackId;
	return clone;
}
function _HTMLInput() {};
_HTMLInput.prototype = HTMLInput.prototype;
HTMLInput.prototype.serialize_internal = function(buffer) {
	HTMLElement.prototype.serialize_internal.call(this, buffer);
	buffer.writeInt32(this.fontSize);
	let borderColor = this.borderColor
	if(borderColor) {
		var index = _objectCacheIndex.get(borderColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(borderColor, index = _objectCache.length);
			_objectCache.push(borderColor);
			buffer.writeInt32(-index);
			borderColor._objectIndex = index;
			borderColor.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.align);
	buffer.writeString(this.value);
	let onEnterKey = this.onEnterKey
	if(onEnterKey) {
		var index = _objectCacheIndex.get(onEnterKey);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onEnterKey, index = _objectCache.length);
			_objectCache.push(onEnterKey);
			buffer.writeInt32(-index);
			buffer.writeInt32(onEnterKey._id);
			onEnterKey._objectIndex = index;
			onEnterKey.serialize_internal(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeInt32(this.changeCallbackId);
	buffer.writeInt32(this.enterCallbackId);
}
HTMLInput.prototype.deserialize_internal = function(buffer) {
	HTMLElement.prototype.deserialize_internal.call(this, buffer);
	this.fontSize = buffer.readInt32();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.borderColor = _objectCache[index];
	} else {
		let borderColor = this.borderColor
		if(!borderColor || borderColor._objectIndex != -index)
			this.borderColor = borderColor = new _Color();
		(_objectCache[-index] = borderColor).deserialize_internal(buffer);
	}
	this.align = buffer.readInt32();
	this.value = buffer.readString();
	var index = buffer.readInt32();
	if(index >= 0) {
		this.onEnterKey = _objectCache[index];
	} else {
		let onEnterKey = this.onEnterKey
		let _id = buffer.readInt32();
		if(!onEnterKey || onEnterKey._id != _id || onEnterKey._objectIndex != -index)
			this.onEnterKey = onEnterKey = new _lambdaContructors[_id]();
		onEnterKey._id = _id;
		(_objectCache[-index] = onEnterKey).deserialize_internal(buffer);
	}
	this.changeCallbackId = buffer.readInt32();
	this.enterCallbackId = buffer.readInt32();
}
HTMLInput.prototype.serialize_external = function(buffer) {
	HTMLElement.prototype.serialize_external.call(this, buffer);
	buffer.writeString("fontSize");
	buffer.writeInt32(4);
	buffer.writeInt32(this.fontSize);
	buffer.writeString("borderColor");
	let borderColor_startPos = buffer.reserveSize();
	let borderColor = this.borderColor
	if(borderColor) {
		var index = _objectCacheIndex.get(borderColor);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(borderColor, index = _objectCache.length);
			_objectCache.push(borderColor);
			buffer.writeInt32(-index);
			borderColor._objectIndex = index;
			borderColor.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(borderColor_startPos);
	buffer.writeString("align");
	buffer.writeInt32(4);
	buffer.writeInt32(this.align);
	buffer.writeString("value");
	buffer.writeString(this.value);
	buffer.writeString("onEnterKey");
	let onEnterKey_startPos = buffer.reserveSize();
	let onEnterKey = this.onEnterKey
	if(onEnterKey) {
		var index = _objectCacheIndex.get(onEnterKey);
		if(index) {
			buffer.writeInt32(index);
		} else {
			_objectCacheIndex.set(onEnterKey, index = _objectCache.length);
			_objectCache.push(onEnterKey);
			buffer.writeInt32(-index);
			buffer.writeInt32(onEnterKey._id);
			onEnterKey._objectIndex = index;
			onEnterKey.serialize_external(buffer);
		}
	} else {
		buffer.writeInt32(0);
	}
	buffer.writeSize(onEnterKey_startPos);
	buffer.writeString("changeCallbackId");
	buffer.writeInt32(4);
	buffer.writeInt32(this.changeCallbackId);
	buffer.writeString("enterCallbackId");
	buffer.writeInt32(4);
	buffer.writeInt32(this.enterCallbackId);
	buffer.writeString("");
}
HTMLInput.prototype.deserialize_external = function(buffer) {
	let fontSize_is_set = false, borderColor_is_set = false, align_is_set = false, value_is_set = false, onEnterKey_is_set = false, changeCallbackId_is_set = false, enterCallbackId_is_set = false;
	HTMLElement.prototype.deserialize_external.call(this, buffer);
	for(;;) {
		let _memberName = buffer.readString();
		switch(_memberName) {
			case "fontSize":
				buffer.readInt32();
				this.fontSize = buffer.readInt32();
				fontSize_is_set = true;
				break;
			case "borderColor":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.borderColor = _objectCache[index];
				} else {
					let borderColor = this.borderColor
					if(!borderColor || borderColor._objectIndex != -index)
						this.borderColor = borderColor = new _Color();
					(_objectCache[-index] = borderColor).deserialize_external(buffer);
				}
				borderColor_is_set = true;
				break;
			case "align":
				buffer.readInt32();
				this.align = buffer.readInt32();
				align_is_set = true;
				break;
			case "value":
				this.value = buffer.readString();
				value_is_set = true;
				break;
			case "onEnterKey":
				buffer.readInt32();
				var index = buffer.readInt32();
				if(index >= 0) {
					this.onEnterKey = _objectCache[index];
				} else {
					let onEnterKey = this.onEnterKey
					let _id = buffer.readInt32();
					if(!onEnterKey || onEnterKey._id != _id || onEnterKey._objectIndex != -index)
						this.onEnterKey = onEnterKey = new _lambdaContructors[_id]();
					onEnterKey._id = _id;
					(_objectCache[-index] = onEnterKey).deserialize_external(buffer);
				}
				onEnterKey_is_set = true;
				break;
			case "changeCallbackId":
				buffer.readInt32();
				this.changeCallbackId = buffer.readInt32();
				changeCallbackId_is_set = true;
				break;
			case "enterCallbackId":
				buffer.readInt32();
				this.enterCallbackId = buffer.readInt32();
				enterCallbackId_is_set = true;
				break;
			default:
				buffer.skip(buffer.readInt32());
				if(_memberName.charCodeAt(0)==0) throw new Error("Serialization Error: Invalid member name");
				break;
			case "":
				if(!fontSize_is_set) this.fontSize = 50;
				if(!borderColor_is_set) this.borderColor = new Color("ffffff00", "");
				if(!align_is_set) this.align = 1/*Center*/;
				if(!value_is_set) this.value = "";
				if(!onEnterKey_is_set) this.onEnterKey = null;
				if(!changeCallbackId_is_set) this.changeCallbackId = 0;
				if(!enterCallbackId_is_set) this.enterCallbackId = 0;
				return;
		}
	}
}
function app_start() {
	new Menu(new Vector2(920, -500, null), new Vector2(0.0, 0.0, null), 1, null, 0, true, null, new Vector2(0.0, 0.0, null), [], true, new Color("#000000b0"));
}
function app_tick() {
	for(let i=0, _subject=input_players, _len=_subject.length; i<_len; ++i) { let it = _subject[i]; {
		it.tick();
	}}
}
var _objectCache = []
var _objectCacheIndex = new Map();
var _lambdaContructors = [_Lambda0, _Lambda1, _Lambda2, _Lambda3, _Lambda4, _Lambda5, _Lambda6, _Lambda7];
function setup_serialize() {
	_objectCache.length = 0;
	_objectCache.push(null);
	_objectCacheIndex.clear();
}
function setup_deserialize() {
	_objectCache.length = 0;
	_objectCache.push(null);
}
function serialize_internal(buffer) {
	setup_serialize();
	buffer.reset();
	Image_serialize_internal(buffer);
	EaseFunction_serialize_internal(buffer);
	math_serialize_internal(buffer);
	Loca_serialize_internal(buffer);
	fx_serialize_internal(buffer);
	Vector2_serialize_internal(buffer);
	IntVector2_serialize_internal(buffer);
	Direction_serialize_internal(buffer);
	Color_serialize_internal(buffer);
	gizmo_serialize_internal(buffer);
	lobby_serialize_internal(buffer);
	Framework_serialize_internal(buffer);
	networkVisualizer_serialize_internal(buffer);
	HTMLElement_serialize_internal(buffer);
	game_serialize_internal(buffer);
	GameController_serialize_internal(buffer);
	input_serialize_internal(buffer);
	networkData_serialize_internal(buffer);
}
function deserialize_internal(buffer) {
	setup_deserialize();
	buffer.readPos = 0;
	Image_deserialize_internal(buffer);
	EaseFunction_deserialize_internal(buffer);
	math_deserialize_internal(buffer);
	Loca_deserialize_internal(buffer);
	fx_deserialize_internal(buffer);
	Vector2_deserialize_internal(buffer);
	IntVector2_deserialize_internal(buffer);
	Direction_deserialize_internal(buffer);
	Color_deserialize_internal(buffer);
	gizmo_deserialize_internal(buffer);
	lobby_deserialize_internal(buffer);
	Framework_deserialize_internal(buffer);
	networkVisualizer_deserialize_internal(buffer);
	HTMLElement_deserialize_internal(buffer);
	game_deserialize_internal(buffer);
	GameController_deserialize_internal(buffer);
	input_deserialize_internal(buffer);
	networkData_deserialize_internal(buffer);
}
function serialize_external(buffer) {
	setup_serialize();
	buffer.reset();
	buffer.writeString("Image");
	var Image_startPos = buffer.reserveSize();
	Image_serialize_external(buffer);
	buffer.writeSize(Image_startPos);
	buffer.writeString("EaseFunction");
	var EaseFunction_startPos = buffer.reserveSize();
	EaseFunction_serialize_external(buffer);
	buffer.writeSize(EaseFunction_startPos);
	buffer.writeString("math");
	var math_startPos = buffer.reserveSize();
	math_serialize_external(buffer);
	buffer.writeSize(math_startPos);
	buffer.writeString("Loca");
	var Loca_startPos = buffer.reserveSize();
	Loca_serialize_external(buffer);
	buffer.writeSize(Loca_startPos);
	buffer.writeString("fx");
	var fx_startPos = buffer.reserveSize();
	fx_serialize_external(buffer);
	buffer.writeSize(fx_startPos);
	buffer.writeString("Vector2");
	var Vector2_startPos = buffer.reserveSize();
	Vector2_serialize_external(buffer);
	buffer.writeSize(Vector2_startPos);
	buffer.writeString("IntVector2");
	var IntVector2_startPos = buffer.reserveSize();
	IntVector2_serialize_external(buffer);
	buffer.writeSize(IntVector2_startPos);
	buffer.writeString("Direction");
	var Direction_startPos = buffer.reserveSize();
	Direction_serialize_external(buffer);
	buffer.writeSize(Direction_startPos);
	buffer.writeString("Color");
	var Color_startPos = buffer.reserveSize();
	Color_serialize_external(buffer);
	buffer.writeSize(Color_startPos);
	buffer.writeString("gizmo");
	var gizmo_startPos = buffer.reserveSize();
	gizmo_serialize_external(buffer);
	buffer.writeSize(gizmo_startPos);
	buffer.writeString("lobby");
	var lobby_startPos = buffer.reserveSize();
	lobby_serialize_external(buffer);
	buffer.writeSize(lobby_startPos);
	buffer.writeString("Framework");
	var Framework_startPos = buffer.reserveSize();
	Framework_serialize_external(buffer);
	buffer.writeSize(Framework_startPos);
	buffer.writeString("networkVisualizer");
	var networkVisualizer_startPos = buffer.reserveSize();
	networkVisualizer_serialize_external(buffer);
	buffer.writeSize(networkVisualizer_startPos);
	buffer.writeString("HTMLElement");
	var HTMLElement_startPos = buffer.reserveSize();
	HTMLElement_serialize_external(buffer);
	buffer.writeSize(HTMLElement_startPos);
	buffer.writeString("game");
	var game_startPos = buffer.reserveSize();
	game_serialize_external(buffer);
	buffer.writeSize(game_startPos);
	buffer.writeString("GameController");
	var GameController_startPos = buffer.reserveSize();
	GameController_serialize_external(buffer);
	buffer.writeSize(GameController_startPos);
	buffer.writeString("input");
	var input_startPos = buffer.reserveSize();
	input_serialize_external(buffer);
	buffer.writeSize(input_startPos);
	buffer.writeString("networkData");
	var networkData_startPos = buffer.reserveSize();
	networkData_serialize_external(buffer);
	buffer.writeSize(networkData_startPos);
}
function deserialize_external(buffer) {
	setup_deserialize();
	buffer.readPos = 0;
	for(;;) {
		switch(buffer.readString()) {
			case "Image":
				buffer.readInt32();
				Image_deserialize_external(buffer);
				break;
			case "EaseFunction":
				buffer.readInt32();
				EaseFunction_deserialize_external(buffer);
				break;
			case "math":
				buffer.readInt32();
				math_deserialize_external(buffer);
				break;
			case "Loca":
				buffer.readInt32();
				Loca_deserialize_external(buffer);
				break;
			case "fx":
				buffer.readInt32();
				fx_deserialize_external(buffer);
				break;
			case "Vector2":
				buffer.readInt32();
				Vector2_deserialize_external(buffer);
				break;
			case "IntVector2":
				buffer.readInt32();
				IntVector2_deserialize_external(buffer);
				break;
			case "Direction":
				buffer.readInt32();
				Direction_deserialize_external(buffer);
				break;
			case "Color":
				buffer.readInt32();
				Color_deserialize_external(buffer);
				break;
			case "gizmo":
				buffer.readInt32();
				gizmo_deserialize_external(buffer);
				break;
			case "lobby":
				buffer.readInt32();
				lobby_deserialize_external(buffer);
				break;
			case "Framework":
				buffer.readInt32();
				Framework_deserialize_external(buffer);
				break;
			case "networkVisualizer":
				buffer.readInt32();
				networkVisualizer_deserialize_external(buffer);
				break;
			case "HTMLElement":
				buffer.readInt32();
				HTMLElement_deserialize_external(buffer);
				break;
			case "game":
				buffer.readInt32();
				game_deserialize_external(buffer);
				break;
			case "GameController":
				buffer.readInt32();
				GameController_deserialize_external(buffer);
				break;
			case "input":
				buffer.readInt32();
				input_deserialize_external(buffer);
				break;
			case "networkData":
				buffer.readInt32();
				networkData_deserialize_external(buffer);
				break;
			default:
				buffer.skip(buffer.readInt32());
				break;
			case "":
				return;
		}
	}
}
function init() {
	List_init();
	EaseFunction_init();
	Loca_init();
	Buffer_init();
	fx_init();
	Vector2_init();
	IntVector2_init();
	Direction_init();
	Color_init();
	lobby_init();
	Framework_init();
	networkVisualizer_init();
	HTMLElement_init();
	IndexedDB_init();
	Snapshot_init();
	game_init();
	GameController_init();
	networkData_init();
	PeerNetwork_init();
	Physics_init();
	ServerNetwork_init();
	Date_init();
}
